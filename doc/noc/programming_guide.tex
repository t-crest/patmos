\documentclass[a4paper,fontsize=10pt,twoside,DIV15,BCOR12mm,headinclude=true,footinclude=false,pagesize,bibtotoc]{scrbook}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{pslatex} % -- times instead of computer modern
\usepackage[scaled=.84]{beramono} % a sane monospace font
\usepackage{microtype}

\usepackage{url}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xspace}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{colortbl}
\usepackage{multicol}
\usepackage{rotating}
\usepackage{subfig}
\usepackage{ulem}
\usepackage{enumerate}

% avoid clubs and widows
\clubpenalty=10000
\widowpenalty=10000

% tweak float placement
%% \renewcommand{\textfraction}{.15}
\renewcommand{\topfraction}{.75}
%% \renewcommand{\bottomfraction}{.7}
\renewcommand{\floatpagefraction}{.75}
%% \renewcommand{\dbltopfraction}{.66}
%% \renewcommand{\dblfloatpagefraction}{.66}
\setcounter{topnumber}{4}
%% \setcounter{bottomnumber}{4}
%% \setcounter{totalnumber}{16}
%% \setcounter{dbltopnumber}{4}

\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\codefoot}[1]{{\textsf{#1}}}
\def\figref#1{Figure~\ref{fig:#1}}

% ulem package, otherwise emphasized text becomes underlined
\normalem


\newcommand{\todo}[1]{{\emph{TODO: #1}}}
%\renewcommand{\todo}[1]{}

%
% generic command to comment something
%
\newcommand{\comment}[3]{

\textsf{\textbf{#1}} {\color{#3}#2}}

%
% commentators
%
\newcommand{\tommy}[1]{\comment{Tommy}{#1}{Red}}
\newcommand{\wolf}[1]{\comment{Wolfgang}{#1}{OliveGreen}}
\newcommand{\martin}[1]{\comment{Martin}{#1}{Blue}}
\newcommand{\stefan}[1]{\comment{Stefan}{#1}{RoyalPurple}}
\newcommand{\daniel}[1]{\comment{Daniel}{#1}{RoyalBlue}}
\newcommand{\cullmann}[1]{\comment{Christoph}{#1}{Maroon}}
\newcommand{\gebhard}[1]{\comment{Gernot}{#1}{RedOrange}}
\newcommand{\fb}[1]{\comment{Florian}{#1}{Emerald}}
\newcommand{\jack}[1]{\comment{Jack}{#1}{Magenta}}
\newcommand{\sahar}[1]{\comment{Sahar}{#1}{Green}}
\newcommand{\rasmus}[1]{\comment{Rasmus}{#1}{Mahogany}}

% uncomment to get rid of comments
%\renewcommand{\tommy}[1]{}
%\renewcommand{\wolf}[1]{}
%\renewcommand{\martin}[1]{}
%\renewcommand{\stefan}[1]{}
%\renewcommand{\daniel}[1]{}
%\renewcommand{\cullmann}[1]{}
%\renewcommand{\gebhard}[1]{}
%\renewcommand{\fb}[1]{}
%\renewcommand{\jack}[1]{}
%\renewcommand{\sahar}[1]{}
%\renewcommand{\rasmus}[1]{}

%
% custom colors
%
\definecolor{lightgray}{gray}{0.8}
\definecolor{gray}{gray}{0.5}

\usepackage{listings}

% general style for listings
\lstset{basicstyle=\ttfamily,keywordstyle=\ttfamily}

% listings style for Java
\lstnewenvironment{Java} {\lstset{
  xleftmargin=12pt,
  language=Java
}}{}

\usepackage[endianness=big]{bytefield}

% long immediate in second slot
\newcommand{\lconst}{\texttt{const}_{32}}
% short immediate in ALU instruction
\newcommand{\sconst}{\texttt{Constant}_{12}}
% constant in Rs2 field
\newcommand{\rconst}{\texttt{Constant}_{5}}

% SH: to be used in text mode .. maybe we should change this to math mode?
\newcommand{\XOR}{\textasciicircum\xspace}
\newcommand{\OR}{\textbar\xspace}
\newcommand{\AND}{\&\xspace}
\newcommand{\NOT}{\texttildelow}
\newcommand{\shl}{\textless$\!$\textless\xspace}
\newcommand{\shr}{\textgreater$\!$\textgreater$\!$\textgreater\xspace}
\newcommand{\ashr}{\textgreater$\!$\textgreater\xspace}

\newcommand{\bitsunused}{\rule{\width}{\height}}
\newcommand{\bitssubclass}{\color{lightgray}\rule{\width}{\height}}

%
% allow click-able links
%
\usepackage[open]{bookmark}
\usepackage[all]{hypcap}

%
% hyperref setup (depends on bookmark/hyperref}
%
\hypersetup{
    pdftitle = {Argo programming guide},
    pdfsubject = {Technical Report},
    colorlinks = {true},
    citecolor = {black},
    filecolor = {black},
    linkcolor = {black},
    urlcolor = {black},
    final
}

%
% document contents
%
\begin{document}

\title{Argo programming guide}

\author{Evangelia Kasapaki,  Rasmus Bo S{\o}rensen}

\lowertitleback{\todo{Copyright and license terms come here.}}

\frontmatter

\maketitle

\chapter{Preface}

This guide describes how the Argo noc can be programmed through a description of the API and code examples.
This document should evolve to be the documentation on writing multicore application for the T-CREST platform.

The most recent version of this guide is contained as LaTeX source in the Patmos repository in directory
\code{patmos/doc/noc} and can be built with \code{make}.

\section*{Acknowledgment}
This work was partially funded under the
European Union's 7th Framework Programme
under grant agreement no. 288008:
Time-predictable Multi-Core Architecture for Embedded
Systems (T-CREST).
And partially funded by:
The Danish Council for Independent Research | Technology and Production Sciences (FTP) 
project (Hard Real-Time Embedded Multiprocessor Platform - RTEMP)

\tableofcontents

\begingroup
\let\cleardoublepage\clearpage
\listoffigures
\listoftables
%\lstlistoflistings
\endgroup

\mainmatter

\chapter{Introduction}

\begin{itemize}
\item The purpose of Argo - To increase core-2-core communication bandwidth
\item How should the reader advance through the document
\item Which assumptions har the authors made
\end{itemize}

\chapter{The Architecture of Argo}
\label{sec:arch}

Argo is a time-predictable Network-on-Chip (NOC). An Argo NOC is made up of two different components,
network interfaces (NI) and routers.
The functionality of the NOC is to enable message passing between processing cores.
The NI is in charge of converting between the transaction based interface
of a processor to a streaming interface suited for network communication.
The router is routing the packets through the network.
To make the network time-predictable the NI and the router uses static 
time division multiplexing (TDM) to route communication through the network.
Meaning that allocation of links between routers follow a static pre-defined schedule.
A diagram of the architecture of Argo is shown in Figure~\ref{fig:diag}

\begin{figure}
\label{fig:diag}
\centering
%\includegraphics[width=\textwidth]{}
\caption{The architecture of a single Argo tile.}
\end{figure}

The poseidon scheduler can generate static TDM schedules for Argo.
\rasmus{I am not sure whether to reference the git repo or the techincal report.}

To enable full utilization of the static TDM schedule,
Argo has a direct memory access (DMA) channel per communication channel.
To send a message through the network a DMA needs to be setup.



\chapter{Memory address space and interface}
The network interface (NI) of Argo has 2 OCP\cite{ocp:spec} interfaces.


\section{Local and Global Address Space}


\chapter{Build Instructions}

In the following we present the Patmos build instructions on a Linux/Ubuntu
system.\footnote{I used the 32-bit version of Ubuntu to simplify the Quartus installation.}
Patmos and the compiler have also been successfully installed on a Mac OSX
system. The support of Windows is marginal, or basically not existent.


\section{Setup On Ubuntu 13.04}

After a plain Ubuntu installation several packages need to be installed.
The following apt-get lists the packages that need to be
installed:\footnote{Some packages might be available in newer version
when reading this document.}

\begin{verbatim}
sudo apt-get install git openjdk-7-jdk gitk cmake make g++ texinfo flex bison \
  subversion libelf-dev graphviz libboost-dev libboost-program-options-dev ruby1.9.1 \
  ruby1.9.1-dev python zlib1g-dev gtkwave gtkterm
\end{verbatim}

For the Quartus setup it is best to change the default shall to \code{/bin/bash}:

\begin{verbatim}
sudo rm /bin/sh
sudo ln -s /bin/bash /bin/sh
\end{verbatim}

\subsection{Compiler and Patmos}

We assume that the T-CREST project will live in \code{\$HOME/t-crest}.
Patmos and the compiler can be checked out from GitHub and built as follows:

\begin{verbatim}
mkdir ~/t-crest
cd ~/t-crest
git clone https://github.com/t-crest/patmos-misc.git misc
./misc/build.sh
\end{verbatim}

For developers with push permission generate an ssh key and upload
it at GitHub (see \url{https://help.github.com/articles/generating-ssh-keys}
for detailed instructions).
The ssh based clone string for write access is then:

\begin{verbatim}
git clone git@github.com:t-crest/patmos-misc.git misc
./misc/build.sh
\end{verbatim}

This will checkout several other repositories (the compiler, library,
the Patmos source, and benchmarks) and
build the compiler, the Patmos simulator, and the test benches.
Therefore, take a cup of coffee and find some nice reading.
After building the compiler add the path
to the compiler executables into your \code{.profile}:
\footnote{The path needs to be absolute. LLVM cannot handle
a path relative to the home folder \textasciitilde{}, e.g., \code{\textasciitilde{}/t-crest/local/bin}.}

\begin{verbatim}
export PATH=$PATH:$HOME/t-crest/local/bin
\end{verbatim}

A complete logout from Ubuntu is needed to take effect (just closing
a terminal window is not enough).

You can test your installation by checking if the compiler is available:

\begin{verbatim}
patmos-clang
\end{verbatim}

For correct correct signing of your changes set the username and
email in git with:

\begin{verbatim}
git config --global user.name "Joe Someone"
git config --global user.email "joe.someone@domain.com"
\end{verbatim}

\subsection{Quartus}

Download the free web edition of Quartus from Altera. The Linux version is
installed as follows:\footnote{\url{http://www.altera.com/literature/manual/quartus_install.pdf}}

\begin{verbatim}
tar xvf Quartus-web-xxx.tar
\end{verbatim}

The software installation is started with a plain \code{setup.sh}.\footnote{Or \code{bash steup.sh}}
Then add the bin directory of Quartus to your \$PATH.
%
For  the USB Blaster following additional steps are needed:

\begin{verbatim}
# Add user to dialout group for the serial port access
sudo usermod -a -G dialout user

# Add permissions to access the Altera USB Blaster
sudo su -
echo "SUBSYSTEM==\"usb\", DRIVER==\"usb\", ATTR{idVendor}==\"09fb\", \
ATTR{idProduct}==\"6001\", MODE=\"0666\"" > /etc/udev/rules.d/51-usbblaster.rules

udevadm control --reload-rules
\end{verbatim}

Quartus~13.1 drops the support of Cyclone~II devices. Therefore, the
(phased out) Altera DE2-70 board is not supported anymore. Version 13.0 supports Cyclone~II\
till Cyclone~V devices and might be the best option at the moment.

\section{Setup On Mac OS X}

Several tools are needed, best installed with MacPorts. For Patmos simulator and assembler:
\code{boost}, \code{libelf}.
For simulation with ModelSim: \code{wine}
For Aegean: python33, py33-lxml. Make a link from python3 to python3.3 as this is the way it is invoked.
\todo{Alex suggested a way to avoid this by querying how to invoke python.}

\section{Hello World}

We can start with the standard, harmless looking Hello
World:\footnote{This example code is not part of the distribution, but
can be put at any directory.}

\begin{verbatim}
main() {
    printf("Hello Patmos!\n");
}
\end{verbatim}

With the compiler installed it can be compiled to a Patmos executable
and run with the simulator as follows:

\begin{verbatim}
patmos-clang hello.c
pasim a.out
\end{verbatim}

However, this innocent examples is quiet challenging for an embedded system:
It needs a C compiler, an implementation of the standard C library, printf
itself is a challenging function, the generated ELF file needs to be understood
by a tool and the individual sections downloaded, and finally a terminal (often
a serial line) needs to be available on the target, and your test PC needs to
have a serial line as well and a terminal program needs to run.

Therefore, we might start from a minimal assembler program and execute
that in the simulator and emulator. From that base we can build up too
a multi-core version of Patmos that executes in an FPGA and bootstraps
with programs loaded via a serial port.


\section{Building Patmos}

The whole build process of Patmos,%
\footnote{Get the source from GitHub with: \code{git clone git@github.com:t-crest/patmos}}
applications in assembler
and in C, configuration of the FPGA, and downloading an application
is \code{Makefile} based. The build of Patmos is within the patmos folder,
therefore, the following descriptions assumes you have changed to:

\begin{verbatim}
    t-crest/patmos
\end{verbatim}


The complete design flow (including the LLVM
based C compiler) can execute in a Linux machine. The flow without
the C compiler should be able to execute in a Windows/Cygwin environment.
Under Mac OS X all tools, except Quartus, are working (ModelSim under
wine). For FPGA synthesis and configuration Windows XP within a VMWare
virtual machine is a possible solution.

On a Linux box with the installed LLVM compiler and Quartus in your PATH,
the complete build processes for a Hello World is as follows:

\begin{verbatim}
make BOOTAPP=bootable-bootloader APP=hello_puts \
   tools comp gen synth config download
\end{verbatim}

However, this involves quite many steps. Therefore, we suggest doing some \emph{manual}
buildup to explore the full build process and the possibilities.

As a start we build some tools (e.g., the assembler, simulator, file conversion
utility, and the boot loader). This has to be done once only.

\begin{verbatim}
make tools
\end{verbatim}

\subsection{A Few Assembler Instructions}

We start with a very small assembler program that moves a few values into registers
(see \code{asm/basic.s}). With following make command the program is assembled
and executed in the software simulator of Patmos.

\begin{verbatim}
make swsim BOOTAPP=basic
\end{verbatim}

The simulator options are set to write out the register contents after each instruction.
The emulator (the Chisel based simulator) can execute the same program
with following command:

\begin{verbatim}
make hwsim BOOTAPP=basic
\end{verbatim}

This command assembles the application, executes the Chisel based hardware
construction during which the program is used to initialize the on-chip ROM,
generates a C++ based emulator, compiles that emulator, and executes it.
The emulator show the register content after each instruction.

Those two Patmos simulations, the software simulator and the Chisel based emulator,
are used for a co-simulation based test. In this co-simulation all available assembler
programs are executed in both simulations and the register out put is compared.
The test can be started with:

\begin{verbatim}
make test
\end{verbatim}


\todo{ModelSim simulation}

\subsection{We Can Blink in Assembler}

\todo{write}

\subsection{A C Based Blinking LED}

As a first real example we build the embedded version of Hello World, the
blinking LED, from a C program. You can find the C source in \code{c/blinking.c}.

\begin{verbatim}
make BOOTAPP=bootable-blinking comp gen synth config
\end{verbatim}

Additionally to blinking an LED this program also writes alternating `0' and `1'
to the serial port. Connect the FPGA board to your serial port,
open a terminal of your choice (e.g., \code{gtkterm}), connect to the serial port,
set the baud rate to 115200, no parity, and no handshaking.
You should see alternating `0' and `1' sent out synchronous to the blinking.

Note that the program name (\code{blink}) is prefixed by \code{bootable-}.
The marker selects the right compiler settings for a program that ends up in
the Patmos on-chip ROM. As the on-chip memory is limited, only tiny programs
are supported in this execution mode.

Figure~\ref{fig:blink} shows the code for the embedded Hello World
C program. Two constants (0xF0000900 and 0xF0000804) are the addresses
of the IO devices LED and serial port. IO devices connected to Patmos are
connected to the local, uncached memory area. This is the same memory
area where data SPM and NoC SPM are connected. Therefore, to access them
one needs to use the local load/store instructions. With the attribute \code{\_SPM}
the compiler is instructed to emit the correct load and store instructions.

\begin{figure}
\begin{verbatim}
/*
    This is a minimal C program executed on the FPGA version of Patmos.
    An embedded Hello World program: a blinking LED.

    Additional to the blinking LED we write to the UART '0' and '1' (if available).

    Author: Martin Schoeberl
    Copyright: DTU, BSD License
*/

#include <machine/spm.h>

int main() {

    volatile _SPM int *led_ptr = (volatile _SPM int *) 0xF0000900;
    volatile _SPM int *uart_ptr = (volatile _SPM int *) 0xF0000804;
    int i, j;

    for (;;) {
        *uart_ptr = '1';
        for (i=2000; i!=0; --i)
            for (j=2000; j!=0; --j)
                *led_ptr = 1;


        *uart_ptr = '0';
        for (i=2000; i!=0; --i)
            for (j=2000; j!=0; --j)
                *led_ptr = 0;

    }
}\end{verbatim}
\caption{A blinking LED}
\label{fig:blink}
\end{figure}

\martin{I'm still a little bit confused when to use the APP and the BOOTAPP
thing.}

\martin{TODO: we need to streamline the make process a little bit.
The targets might be a little bit confusing. Patmos is compiled two times.}


\subsection{Make Targets}

A list of the most important make targets:

\begin{description}
\item[tools] build of all tools, including the Patmos software simulator
\item[asm] assemble source (from folder \code{asm})
\item[swsim] execute the Patmos emulator
\item[hwsim] execute the Patmos emulator
\item[emulator] build the Chisel based C++ emulator
\item[comp] compile a C program as loadable ELF binary
\item[bootcomp] compile a C program as a bootable image
\item[gen] generate the Verilog code
\item[synth] synthesize for an FPGA
\item[config] configure the FPGA
\item[download] download an elf file into the main memory via the Patmos bootloader
\item[test] run all assembler tests 
\end{description}

The name of an application that can execute from the on-chip ROM is set
with the BOOTAPP variable.

\subsection{Download of ELF Files}

On a Linux box with the installed LLVM compiler and Quartus in your PATH,
the complete build processes for the Hello World is as follows:

% make BOOTAPP=bootable-bootloader APP=hello_puts tools synth comp config download
\begin{verbatim}
make BOOTAPP=bootable-bootloader APP=hello_puts \
   tools comp gen synth config download
\end{verbatim}

You should see the download information and then the greeting from Patmos:

\begin{verbatim}
/home/martin/t-crest/patmos/install/bin/patserdow -v /dev/ttyUSB0 /home/martin/t-crest/patmos/tmp/hello_puts.elf
Port opened: true
Params set: true
Elf version is '1':true
CPU type is:48875
Instruction width is 32 bits:true
Is Big Endian:true
File is of type exe:true
Entry point:131076

[++++++++++] 49778/49778 bytes
Hello, World!

EXIT 0
\end{verbatim}

The \code{Makefile} use following variables to configure the build process:
\code{BOOTAPP} is an application that ends in the on-chip ROM. This may
be an assembler program or a simple C program;
most prominent the boot loader for ELF binaries.
A C program that shall be compiled as ROM target needs to be prefixed
with \code{bootable-}.
\code{APP} is a C program resulting in an ELF binary that can be either
loaded by the emulator or the boot loader when executing in an FPGA.
% TODO: test and talk about patsim. Having a complete ELF in the FPGA
% without the boot loader would be nice as well.

\todo{Describe ELF download without building the FPGA}


Here an example of the individual steps to build the blinking LED C
hello world (on a different FPGA board):
\begin{verbatim}
make tools
make BOOTAPP=bootable-echo bootcomp gen
make BOOTAPP=bootable-echo QPROJ=bemicro synth
make QPROJ=bemicro BLASTER_TYPE=Arrow-USB-Blaster config
\end{verbatim}

This split of the make commands is for demonstration. It is
possible to merge all steps into a single make (on Linux
systems) or two steps when using two operating
systems (e.g., Mac OSX for compilation and Windows for synthesis).

\paragraph{Emulator and elf File}

The emulator can read a standard ELF file. An example how to compile
a small C program that uses part of the standard library and executing
it on the emulator is as follows:

\begin{verbatim}
make emulator
make comp APP=hello_puts
hardware/build/emulator tmp/hello_puts.elf
\end{verbatim}

\martin{Where is the make target to run the emulator with an ELF file?}

\subsection{Supported FPGA Boards}

At the time of this writing we have mainly focused on Altera FPGA based boards. Following boards
are directly supported in the default build process:

\begin{itemize}
\item Altera DE2-70 (\code{altde2-70})
\item Altera DE2-115 (\code{altde2-115})
\item Altera/Farnell BeMicro (\code{bemicro})
\end{itemize}

The board is configured by setting the \code{BOARD} variable.
Without changing the \code{Makefile} the default of the board (and any other build variables)
can be overridden by providing a local \code{config.mk} that is included in the Makefile.

\subsection{Multicore Patmos}

In directory \code{aegean} run:

\begin{verbatim}
make platform
make synth
\end{verbatim}

to generate (and synthesize) the default project, which is the mandelbrot application on a 4 core
version of Patmos for an Altera DE2-115 FPGA board.

\section{ModelSim License}
In the case that you have a DTU Compute login you can access the license servers from outside the DTU network by setting up an SSH tunnel.
An example of how such a tunnel can be set up follows, you need to insert you own username.

\begin{verbatim}
ssh -L 1717:angel2:1717 -L 1718:angel2:1718 ${USERNAME}@sshlogin.compute.dtu.dk
\end{verbatim}

When the SSH tunnel is setup the LM\_LICENSE\_FILE needs to be set to:
\begin{verbatim}
LM_LICENSE_FILE=1717@localhost
\end{verbatim}

This way of setting up an SSH tunnel might also work for other institutions.

%% MS: there needs to be more content to have a chapter on the compiler.
%
%\chapter{The Patmos Compiler}
%\label{sec:compiler}
%
%The LLVM compiler has been adapted to emit code for the Patmos ISA
%and support the special features, e.g., the stack cache~\cite{Seus13:compiler}.
%
%\martin{Daniel and Stefan shall add here an overview of the compiler and
%some words on source organization. But let's start with some notes.}
%
%The compiler and libraries can be built with \code{misc/build.sh}.
%This script also contains the default options, which should work on a
%standard Linux machine out of the box. Options can be overwritten by
%entries in a personal \code{misc/build.cfg}. The file {misc/build.dist.cfg}
%is just an example configuration file, generated from build.sh, and ignored
%by the build process.


\chapter{Application Programming Interface}
\label{sec:api}

At the time of writing the only application programming interface is the libnoc.
libnoc has two kinds of functionality, the first is to initialize the network interface (NI) and the second is the setup DMA transferes for send messages to other processing cores.

\chapter{Pending Changes}

This is a live and temporary section that lists pending changes of Argo.

Currently we have following proposals for a change:

\begin{itemize}
\item DMA read
\item Generate an interrupt when a complete DMA transfere has been received. 
\end{itemize}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
\chapter{Potential Extensions}

\chapter{Conclusion}
\label{sec:conclusion}

Patmos is the next cool thing in the dry world of real-time systems.

\bibliographystyle{abbrv}
\bibliography{../handbook/patbib.bib}

\end{document}

\appendix


\end{document}
