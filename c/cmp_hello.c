/*
    A small test program testing the communication between patmos processors
    through the NoC

    Authors: Rasmus Bo SÃ¸rensen
             Wolfgang Puffitsch
    Copyright: DTU, BSD License
*/

#include <string.h>
#include <machine/spm.h>
#include "init.h" // Init.h is auto generated by Poseidon the T-CREST scheduler
                  // https://github.com/t-crest/poseidon.git

void init_ni(void);
int send(int rcv_id, short read_ptr, short write_ptr, int size);
int main(int argc, char **argv) __attribute__((naked,used));

extern int _stack_cache_base, _shadow_stack_base;

#define CPU_ID      *((volatile _SPM int *) 0xF0000000)

#define UART_STATUS *((volatile _SPM int *) 0xF0000800)
#define UART_DATA   *((volatile _SPM int *) 0xF0000804)

#define WRITE(data,len) do { \
  unsigned i; \
  for (i = 0; i < (len); i++) {        \
    while ((UART_STATUS & 0x01) == 0); \
    UART_DATA = (data)[i];             \
  } \
} while(0)

#define VALID_BIT 0x08000
#define DONE_BIT 0x04000

static const struct network_interface
{
    volatile _SPM int *dma;
    volatile _SPM int *dma_p;
    volatile _SPM int *st;
    volatile _SPM int *spm;
} ni = {
    (volatile _SPM int *) 0xE0000000,
    (volatile _SPM int *) 0xE1000000,
    (volatile _SPM int *) 0xE2000000,
    (volatile _SPM int *) 0xE8000000
};

int main(int argc, char **argv) {

    // setup stack frame and stack cache.
    asm volatile ("li $r29 = %0;" // initialize shadow stack pointer"
                  "mts $ss  = %1;" // initialize the stack cache's spill pointer"
                  "mts $st  = %1;" // initialize the stack cache's top pointer"
                  "li $r30 = %2;" // initialize return base"
                  : : "i" (&_shadow_stack_base), "r" (&_stack_cache_base), "i" (&main));

    volatile int *dummy = (int *) 0x123;

    volatile _SPM int *led_ptr = (volatile _SPM int *) 0xF0000900;

    init_ni();

    if (CPU_ID == 0)
    {
        int k;
        // Clear communication scratch pad
        for(k = 0; k < 8; k++)
        {
            *(ni.spm+k) = 0;
        }
        // Wait for messages from cores
        for(k = 1; k < CORES; k++)
        {
            while(*(ni.spm+2*k) == 0);
        }

        // Send a hello world message
        const char *msg = "Hello world ";
        char cid[CORES];
        for(k = 1; k < CORES; k++)
        {
            cid[k-1] = *(ni.spm+2*k);
        }
        WRITE(msg, strlen(msg));
        WRITE(cid,CORES-1);
        WRITE("\n",1);

        // Blinkenlights
        int i, j;
        for (;;)
        {
            UART_DATA = '1';
            for (i=2000; i!=0; --i)
                for (j=2000; j!=0; --j)
                    *led_ptr = 1;


            UART_DATA = '0';
            for (i=2000; i!=0; --i)
                for (j=2000; j!=0; --j)
                    *led_ptr = 0;

        }
    }
    else
    {
        // Send the own id to processor 0
        for (;;)
        {
            *(ni.spm) = CPU_ID+'A';
            while(!send(0, 0, CPU_ID, 1));
        }
    }

    return 0;
}

// Set up network interface
void init_ni(){
    int i;
    for (i = 0; i < TIMESLOTS; ++i)
    {
        *(ni.st+i) = 0x04 | init_array[CPU_ID][0][i];
    }
    for (i = 0; i < DMAS; ++i)
    {
        *(ni.dma_p+i) = init_array[CPU_ID][1][i];
    }
}

// Start a NoC transfer
// The addesses and the size are in double-words
int send(int rcv_id, short read_ptr, short write_ptr, int size){
    // Only send if the receiver id is valid
    if ((rcv_id == CPU_ID) || (rcv_id < 0) || (rcv_id > CORES-1))
    {
        return 0;
    }

    // Ony send if previous transfer is done
    if ((*(ni.dma+(rcv_id<<1)) & VALID_BIT) != 0
        && (*(ni.dma+(rcv_id<<1)) & DONE_BIT) == 0)
    {
        return 0;
    }

    // Read pointer and write pointer in the dma table
    *(ni.dma+(rcv_id<<1)+1) = (read_ptr << 16) | write_ptr;
    // DWord count and valid bit, done bit cleared
    *(ni.dma+(rcv_id<<1)) = (size | VALID_BIT) & ~DONE_BIT;

    return 1;
}
