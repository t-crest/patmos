Copyright 2000-2011 Free Software Foundation, Inc.

The material in this patch is a derivative work of the gcc package,
and is subject to licensing and copyright of its parent package.

This patch adds/enhances support for the Texas Instruments MSP430 family of
microcontrollers to GNU gcc.  The material incorporated is maintained
in a git repository hosted at:

  git://mspgcc.git.sourceforge.net/gitroot/mspgcc/gcc

This patch incorporates changes between:
  upstream/release/gcc-4.5.3 (ccf18e39f4a81bd4067286b52bbec3f8efe5deac)
and
  uniarch/release/gcc-4.5.3 (aca99892c6171b944200295f9788e27fb979ab35)

To build, obtain the upstream release distribution from:
  ftp://ftp.gnu.org/pub/gnu/gcc/gcc-4.5.3/gcc-4.5.3.tar.bz2

Unpack the distribution, apply the patch, and build.  (Note: The example
commands are in Bourne-shell syntax.)

  tar xjf gcc-4.5.3.tar.bz2
  ( cd gcc-4.5.3 ; patch -p1 < ../msp430-gcc-4.5.3-20110706.patch )
  mkdir -p BUILD/gcc
  cd BUILD/gcc
  ../../gcc-4.5.3/configure \
    --target=msp430 \
    --enable-languages=c,c++ \
    --prefix=/usr/local/msp430 \
  2>&1 | tee co
  make 2>&1 | tee mo
  make install 2>&1 | tee moi

For support please use the mspgcc-users mailing list.  You can subscribe at
https://lists.sourceforge.net/lists/listinfo/mspgcc-users.  Once subscribed,
you can post by email to mspgcc-users@lists.sourceforge.net.  To report
bugs, please file a tracker ticket on SourceForge at
https://sourceforge.net/tracker/?group_id=42303&atid=432701

Patch file generated: 2011-07-16T13:25:07-05:00

Log of relevant changes:
aca9989 [2011-03-22 16:06:23 -0500] Anticipatory patch for PR lto/45638
3deb7b2 [2011-01-18 13:13:21 -0600] Add %:include_noerr as spec function.
143cbed [2011-02-21 03:47:03 -0600] Anticipatory patch for PR middle-end/42722 (SF 3148801)
a9de61a [2011-01-09 17:13:53 -0600] Anticipatory patch for PR tree-optimization/45144 (SF 3152588)
781bd9e [2010-12-31 17:57:15 -0600] Anticipate PR rtl-optimization/47138 back-port r158175
2d754e3 [2010-12-31 12:00:02 -0600] Anticipate PR rtl-optimization/45235
ed0814c [2011-07-16 12:46:38 -0500] Regenerate
7b5d834 [2011-07-16 12:21:25 -0500] Add msp430 target support to GCC
b3bc594 [2011-07-05 17:09:07 -0500] Update for release
203cd7e [2011-07-05 17:03:47 -0500] SF 3354800 put back -mdisable-hwmul
5a9eec4 [2011-07-05 16:42:49 -0500] SF 3354807 ICE with -mmpy=16 on 32-bit constant multiplies
c17a05a [2011-07-05 16:08:47 -0500] Update for release
356dce9 [2011-07-05 15:56:40 -0500] Fix illegal extraction of low part of constant multiplication operand
29af6de [2011-07-05 15:19:06 -0500] Complete support for MPY32
339ecc8 [2011-07-05 15:06:47 -0500] Tested hardware multiply for non-MPY32 support
e018493 [2011-07-05 15:01:28 -0500] Tiny optimization in mulsidi3
0808b4d [2011-07-05 14:59:27 -0500] Add library functions for widen-to-64 multiply
a74eec7 [2011-07-05 14:33:06 -0500] Validate muldi3
391b168 [2011-07-05 10:39:24 -0500] Use mode iterators for multiplication insns
3fd730b [2011-07-05 10:03:32 -0500] Clean up multiplication
f6048bb [2011-07-05 09:03:08 -0500] Use correct "can't happen" function
5ceb03b [2011-07-05 07:21:04 -0500] Remove patterns from non-expanded RTL templates
c8d5bff [2011-07-04 21:29:21 -0500] Avoid unnecessary sign extension on mulqihi operations
c692ec0 [2011-07-04 21:24:19 -0500] Refine multiplier peripheral indicator values
c979dee [2011-07-04 21:16:18 -0500] SF 3354053 remove -mforce-hwmul, -mdisable-hwmul
c4cc7fd [2011-07-04 20:13:07 -0500] Fix indentation
defe95e [2011-07-04 15:43:25 -0500] More syntax cleanup
7ae064f [2011-07-04 15:38:45 -0500] Syntax cleanup
c6f5686 [2011-07-04 14:57:11 -0500] SF 3317421 -Os generates unrecognized insn for multiply-by-constant
e534b53 [2011-07-04 14:08:58 -0500] Run things through GNU indent again
c6b9d85 [2011-07-04 13:44:11 -0500] Eliminate special insns for MPY peripheral access
7301357 [2011-07-04 12:56:41 -0500] Rework multiply interrupt protection insns
81c5841 [2011-07-04 07:30:03 -0500] pophi sr clobbers condition codes
596fe75 [2011-07-04 08:02:06 -0500] Clean up msp430_init_once
4f1b02a [2011-06-25 15:15:52 -0500] Remove distracting disabled code
2b1e36a [2011-06-25 15:01:31 -0500] Reformat macros so they are readable
0aa02ac [2011-06-25 15:00:52 -0500] Remove unreferenced multiply-related registers
0b0cd25 [2011-06-25 13:43:53 -0500] Remove outdated push helper functions
b680b48 [2011-06-25 13:20:43 -0500] SF 3317711 path to ldscripts broken if installation moved
73007d8 [2011-06-25 11:07:53 -0500] Patch provided by submitter
9f6f736 [2011-06-12 08:35:07 -0500] Update for release
e0d67b8 [2011-06-12 08:33:32 -0500] SF 3313978 ICE (unrecognizable insn) related to rotate
c67eb41 [2011-05-30 11:39:49 -0500] Update for release
c5b4fc7 [2011-05-30 10:23:18 -0500] SF 3302511: ICE building newlib 1.19.0
eb98053 [2011-05-15 15:36:20 -0500] Update for release
a6911fa [2011-05-10 20:02:57 -0500] SF 300205 regression: sizeof(short) != 2
7949660 [2011-05-03 06:15:17 -0500] SF 3296698: unoptimized code for bit field/union
d372fa6 [2011-04-30 14:21:18 -0500] Use a less obscure RTL pattern for swpb
7aceebf [2011-04-30 12:35:41 -0500] Remove repeated calculation in cost expression calculation
6e3c8e9 [2011-04-24 04:32:16 -0500] SF 3291533 __cmpdi2 wrong redux
f4dcf98 [2011-04-23 13:34:41 -0500] Lift out function that splits multiword operands
bbb040e [2011-04-23 09:48:47 -0500] Simplify absm2
2cf5283 [2011-04-23 09:48:24 -0500] Avoid mode-less constants as op0
f3c5554 [2011-04-22 20:50:21 -0500] New solution to expansion of multi-word comparisons
87310b1 [2011-04-22 17:36:53 -0500] Strip cbranchsi4 support
e545f89 [2011-04-22 13:25:29 -0500] SF 3291533 __cmpdi2 wrong
5111472 [2011-04-21 17:33:06 -0500] Refactor high/low part extraction
d24a5af [2011-04-21 16:58:42 -0500] Consolidate cbranch-related functions
c5cacde [2011-04-21 15:44:34 -0500] Inline the operation to use canonical MSP430 comparison operator
138db44 [2011-04-21 15:33:24 -0500] Eliminate unreferenced functions
74cc7c0 [2011-04-21 11:36:18 -0500] br is an emulated format II instruction
629871e [2011-04-21 10:22:56 -0500] Update for release
e3b4304 [2011-04-21 09:09:11 -0500] SF 3195322 remove profile options -mpgs, -mpgl, -mpgr
378cb1e [2011-04-21 09:02:14 -0500] SF 3288916 dint builtin should emit noop
6809b99 [2011-04-21 08:55:04 -0500] SF 3290923 sequence of calls can overrun stack
e0cda89 [2011-04-19 16:04:42 -0500] Eliminate introduction of temporary
c638954 [2011-04-19 15:11:38 -0500] Strip out unused code
1ed8438 [2011-04-19 14:52:02 -0500] Remove useless TARGET_LEGITIMIZE_ADDRESS
4f07ba8 [2011-04-19 14:30:54 -0500] Tighten up checks on base register validity
731f995 [2011-04-19 13:27:14 -0500] Rework strlenhi
1b0bb04 [2011-04-19 09:27:41 -0500] Review use of vwa predicates in new insn definitions
1f5fd5c [2011-04-19 08:29:15 -0500] Rename predicates associated with volatile work-around
212891e [2011-04-18 10:36:32 -0500] Implement xorm3
5d19c1f [2011-04-18 10:09:09 -0500] Replace iorm3
244b312 [2011-04-18 09:53:07 -0500] Implement andm3
f9ff60d [2011-04-18 08:06:10 -0500] Move validated instructions up in file
2a623d5 [2011-04-18 08:05:46 -0500] Mode-specific condition code iterator macro
d832a5d [2011-04-16 21:32:00 -0500] Add unary output support (ones complement, neg expansion)
b87855f [2011-04-16 21:16:19 -0500] Correct push/pop length calculations
36f2fdf [2011-04-16 18:38:10 -0500] Eliminate compile-time warnings
5b7f8b4 [2011-04-16 14:41:57 -0500] Use iterator to generate RMW insn patterns
2ac17c0 [2011-04-16 13:47:25 -0500] Calculate default instr_mult from destination mode
e08079c [2011-04-16 13:34:32 -0500] Normalize NAND and check resulting lengths
214da4a [2011-04-16 12:55:38 -0500] Combine indirect_jump and verify length calculations
7f4e613 [2011-04-16 12:19:05 -0500] Remove explicit_br
5237148 [2011-04-16 11:59:03 -0500] Remove unused code
f3f561b [2011-04-16 11:53:44 -0500] Disallow use of stack or pseudo-registers in non-HImode operations
15a2411 [2011-04-16 11:49:05 -0500] SF 3288235 : clobber in non-move operations
7101e2e [2011-04-16 09:30:11 -0500] Re-optimize frame register adjustments
325baaa [2011-04-15 17:22:42 -0500] Clean up subm3
823391e [2011-04-15 14:21:14 -0500] Remove old addm3 code
a508e2a [2011-04-15 13:50:45 -0500] Use iterator to avoid duplicating CG plus-to-minus split
549a067 [2011-04-15 13:44:39 -0500] Use split to detect negative CG matches
9070d43 [2011-04-15 13:20:59 -0500] Update for lengths for addhi3
11c06de [2011-04-15 12:48:49 -0500] Use iterator to define addm3 expansions
43b08b3 [2011-04-15 12:32:26 -0500] Implement swpb as rotate:HI for better optimization
b812758 [2011-04-15 04:02:06 -0500] Define SHIFT_COUNT_TRUNCATED
e00e7f5 [2011-04-14 14:33:17 -0500] Reduce alternatives in multi-word push operations
91c9f6d [2011-04-14 14:32:44 -0500] pop operands are indirect stack references with side effects
c298a78 [2011-04-14 14:13:25 -0500] Normalize order of attributes
d4afe8c [2011-04-14 13:47:58 -0500] Handle parallel patterns, adjust delay_cycles builtin
c08216c [2011-04-14 13:18:45 -0500] Refine format/length/alternatives for builtins
2e169bf [2011-04-14 13:04:28 -0500] Indirect register as destination requires offset word
95e0c28 [2011-04-14 12:48:29 -0500] Make instruction length based on format, not specific insn
32585d4 [2011-04-14 09:57:01 -0500] Step to refining instruction length calculations
b0c3415 [2011-04-15 12:32:26 -0500] Implement swpb as rotate:HI for better optimization
0e7b758 [2011-04-15 04:02:43 -0500] Add a delay_cycles where the constant is not compatible with CG
d69a3cf [2011-04-15 16:01:51 -0500] Remove dead dummy updates
4d8b01e [2011-04-15 15:50:28 -0500] Remove unnecessary arguments from msp430_cbranch
be559d2 [2011-04-14 17:52:13 -0500] SF 3286842 Compiler stores r2 but does not restore it
4092793 [2011-04-13 18:06:16 -0500] Avoid potentially too strict requirement on index expressions
1a62597 [2011-04-13 18:03:58 -0500] Replace imprecisely named function with new version
6078f25 [2011-04-13 17:55:02 -0500] Provide utility functions to characterize rtx addressing mode
a661df5 [2011-04-13 17:31:25 -0500] Eliminate whines from callers using unsigned regnum expressions
17641ef [2011-04-12 15:43:47 -0500] Update for release
b4aa2cb [2011-04-12 14:43:03 -0500] SF 3207700 make watchdog optional
a32ae89 [2011-04-12 11:14:12 -0500] SF 3237009 default task for main
31da821 [2011-04-12 15:39:54 -0500] Correct mis-use of force_reg
d5e6c6d [2011-04-11 13:53:14 -0500] Update for release
512271a [2011-04-11 11:05:12 -0500] Correct another frame/stack misunderstanding
7526887 [2011-04-11 09:18:25 -0500] Improve optimization of zero-extended byte values
4a492a8 [2011-04-11 09:14:41 -0500] Remove extranous space from movhi2 template
56556b7 [2011-04-10 21:31:41 -0500] Correct potential mis-assignment of registers
b0cabfe [2011-04-10 21:25:31 -0500] Fix suboptimal register reloading
703a8d0 [2011-04-10 21:19:16 -0500] Make internal functions/data static
c40ae95 [2011-04-10 16:47:46 -0500] Avoid abort() in ASM_OUTPUT macros
972c5d5 [2011-04-10 16:46:31 -0500] Use register as more evocative unspecv parameter
2d5b4cd [2011-04-10 16:33:44 -0500] SF 3260589 change frame pointer semantics
9924371 [2011-04-10 10:38:14 -0500] SF 3191622 register use cleanup: SMALL_REGISTER_CLASSES
cc2a80e [2011-04-09 19:17:06 -0500] Become much more strict about register uses.
cd59dd3 [2011-04-09 18:54:30 -0500] Revert SF 3188386
263c35c [2011-04-09 15:03:48 -0500] Fix wrong operator
2d28aa6c [2011-04-09 13:33:44 -0500] Get rid of unnecessary TFPR (alloca already handled)
3065f10 [2011-04-09 10:47:42 -0500] Rework implementation of critical to avoid RETI
6583166 [2011-04-09 10:16:15 -0500] Minor documentation cleanup
927f4d3 [2011-04-08 21:27:25 -0500] SF 3261372: critical attribute incompatible with -g flag
8cc29a6 [2011-04-08 09:38:52 -0500] SF 3191614: register use cleanup: old constraints
c155abc [2011-04-08 08:26:05 -0500] Uniformly use pushm1 insns
c04654b [2011-04-07 21:18:44 -0500] Fix problem with pseudo-register assignment
0bd318a [2011-04-07 09:15:04 -0500] Handle SFmode in msp430_mov_noclobber
764d7f5 [2011-04-05 13:47:30 -0500] Use utility function to create offset mem exprs
507ebad [2011-04-05 13:11:42 -0500] Inhibit peephole code when no peepholes defined
5f4f010 [2011-04-05 13:09:19 -0500] Storing into memory cannot clobber registers
2fd1283 [2011-04-05 12:54:38 -0500] Handle interior clobbers
b452d9c [2011-04-05 12:47:17 -0500] Implement alternative no-clobber solution
632da2f [2011-04-05 10:09:12 -0500] Use mode iterators to reduce duplication in extend insns
d8381a8 [2011-04-05 08:05:06 -0500] Use pushqi1 instead of relaxing constraint on push_operand
7be7f29 [2011-04-05 07:20:57 -0500] Avoid corrupting registers in moves
f53a4cd [2011-04-04 22:44:25 -0500] Correct constraint documentation; clobber regs in builtins
2d8a38e [2011-04-04 22:37:04 -0500] Remove some magic numbers
6b77e9a [2011-04-04 22:22:46 -0500] Use a move iterator to handle SF using SI at no extra charge
07b1838 [2011-04-04 22:04:28 -0500] Remove unused code
3fc7864 [2011-04-04 21:53:12 -0500] Add movdi code
5a5e4bc [2011-04-04 21:41:19 -0500] Combine alternatives with same pattern and lengths
cd5a82e [2011-04-04 21:27:11 -0500] Implement movsi
7cbd810 [2011-04-04 15:24:18 -0500] Support offset for stack-relative pushes
0071bac [2011-04-04 12:47:03 -0500] Add movhi*
0b2ce1e [2011-04-04 12:46:19 -0500] Disable ADJUST_INSN_LENGTH
1db0967 [2011-04-04 12:22:14 -0500] Incorporate pushqi into movqi handling.
bca4d4e [2011-04-04 08:47:25 -0500] Validation of movqi
e5ff982 [2011-04-04 08:58:41 -0500] Remove unreferenced sameoperand code (leftover pre extend rewrite)
6ed2af5 [2011-04-04 08:17:28 -0500] Move all peephole definitions to separate file.
77f1c6a [2011-04-03 17:43:29 -0500] Cleanup around extend insns
df372c4 [2011-04-03 17:17:33 -0500] Implement zero_extendmn2 sharing extendmn2 code
29099e7 [2011-04-03 16:28:48 -0500] Re-implement sign extension insns (extendmn2)
8ce32c4 [2011-04-03 12:45:56 -0500] Avoid overwrite when r11:di is copied to r12:di
f74872c [2011-03-31 15:07:36 -0500] SF 3264484: need naked with stack variables
14f89fa [2011-03-31 14:14:36 -0500] Trivial cleanups
9a3f541 [2011-03-31 09:38:35 -0500] Remove RTX_FRAME_RELATED_P from prologue insns not affecting frame
ed80052 [2011-03-30 11:14:56 -0500] Verify critical attribute results in reti
3c63c7f [2011-03-30 09:24:53 -0500] Remove unreferenced variable
dcbe77e [2011-03-30 08:55:23 -0500] SF 3257192: obey noreturn
a11a4b6 [2011-03-30 08:37:16 -0500] Convert saveprologue elimination to warning
9982fac [2011-03-29 11:46:52 -0500] Remove debug messages
0d370a4 [2011-03-29 10:50:28 -0500] Update for release
a72612b [2011-03-29 10:49:11 -0500] SF 3257021, 3257192: function attribute rework
3abb531 [2011-03-28 12:50:38 -0500] Run everything through indent again
091b3d0 [2011-03-28 12:36:12 -0500] SF 3250899: error right shift 32-bit values
64c6735 [2011-03-27 19:33:36 -0500] SF 3250605: error left shift 64-bit values
5a0a5da [2011-03-27 18:58:59 -0500] SF 3250633: error right logical shift 64-bit values
53cbbd9 [2011-03-26 12:43:06 -0500] Reformatting in shift code
96ecb5a [2011-03-26 11:50:34 -0500] Remove uncalled statics, inline uniquely called statics
d1dcc05 [2011-03-26 11:42:21 -0500] Remove length calculations in shift operations
bb404e2 [2011-03-26 11:02:41 -0500] Clear out more bogus instruction length infrastructure
4e598c6 [2011-03-25 14:07:41 -0500] Partial SF 3244669: remove hard-coded lengths from msp430_name_code
5fef21d [2011-03-25 13:43:40 -0500] Remove patterns which use @Rn+ naturally.
c1fbc59 [2011-03-25 12:54:35 -0500] Reduce visibility of utility functions.
c42f445 [2011-03-25 12:47:22 -0500] Correct instruction lengths for set expressions in builtins.
3d2dd01 [2011-03-25 11:50:40 -0500] Consistent placement of unspec_volatile on set patterns.
a059b93 [2011-03-25 11:50:34 -0500] Eliminate build warnings from use of HOST_WIDE_INT in printf formats
6b16b08 [2011-03-26 07:48:23 -0500] Update version for next release
238764f [2011-03-25 22:00:19 -0500] Fix delay_cycles on CPUXV2
a454332 [2011-03-25 00:36:23 -0500] SF 3237005: add __delay_cycles intrinsic
660b860 [2011-03-24 13:25:27 -0500] Fix varargs problem on 64-bit hosts.
c3279c7 [2011-03-22 17:44:06 -0500] Update version for next release
0820353 [2011-03-22 15:25:24 -0500] Remove problematic and unuseful example
fd873cf [2011-03-22 10:34:07 -0500] Rename builtin for consistency
eea6dd2 [2011-03-21 12:18:51 -0500] Clean up interrupt attribute parameter processing
a0beb09 [2011-03-21 11:34:46 -0500] Clean up prototypes/public functions
0875583 [2011-03-21 11:12:57 -0500] Improve validation of naked/task attributes.
1e086ab [2011-03-21 10:19:17 -0500] Check for incompatibility among attribute declarations
240b794 [2011-03-20 15:30:08 -0500] Replace code that detected empty epilogue
6fe5e6c [2011-03-20 14:20:59 -0500] Use flags to specify frame prologue/epilogue actions
3e9047c [2011-03-20 13:05:45 -0500] Disable saveprologue
a65f990 [2011-03-20 11:56:58 -0500] Remove unused references to instruction address data
2dbd885 [2011-03-20 11:46:25 -0500] Clean up stack alignment and adjustment for frame size
3a69c2f [2011-03-20 11:16:20 -0500] Regression test for saveprologue.
8973349 [2011-03-20 10:28:23 -0500] Calculate frame-saved register set in one place.
f917da2 [2011-03-19 14:22:36 -0500] Use attribute trees instead of booleans to record function attributes
ac08763 [2011-03-19 11:00:10 -0500] Make machine_status the ultimate source of function attributes.
cdadcad [2011-03-19 10:44:36 -0500] Remove sibcall-related code.
a5a0f44 [2011-03-19 09:43:11 -0500] Avoid marking interrupt functions as used until is_interrupt validated.
70197bb [2011-03-19 09:27:31 -0500] Attribute cleanup: consistent format for warning messages
105eb82 [2011-03-19 08:24:40 -0500] Run through indent
cd4f3b6 [2011-03-19 08:19:36 -0500] Inline once-called, remove never-called frame handler functions
96d200c [2011-03-16 12:27:20 -0500] Collect function attribute analysis into one place.
cfbbf71 [2011-03-16 10:19:49 -0500] Remove unreferenced reserve attribute
b950248 [2011-03-15 15:25:22 -0500] SF 3214051: validate is_leaf workaround
8cdad9e [2011-03-14 20:47:40 -0500] Rename function to reflect what it does
c657168 [2011-03-14 20:39:28 -0500] Remove -mendup-at and -minit-stack
c0d0094 [2011-03-15 13:53:42 -0500] Remove calculation of function prologue/epilogue size.
ddae3bc [2011-03-14 19:35:40 -0500] Remove .L__FrameSize/.L__FrameOffset
f1f180b [2011-03-15 13:44:02 -0500] Remove GCC_VERSION_INT.
33a486a [2011-03-14 19:24:32 -0500] SF 3195317: clean up -maccumulate-outgoing-args
dfdf943 [2011-03-14 13:04:51 -0500] SF 3193396: fix uniarch ctors/dtors
4b859f0 [2011-03-12 15:34:40 -0600] SF 3207046: get rid of jump to main
b00681e [2011-03-12 15:21:44 -0600] Recognize that stack pointer may be a 20-bit pointer (not an unsigned int)
04b7030 [2011-03-12 14:48:26 -0600] Correct support for named sections
7856ccc [2011-03-12 11:56:08 -0600] SF 3207853: bad constant extraction on 64-bit systems
b4fa76e [2011-03-11 17:40:27 -0600] Mark frame-related instructions
b984f27 [2011-03-11 15:26:59 -0600] Inline the inline functions (not shared, no reason to put in separate file)
e640bc6 [2011-03-11 15:24:47 -0600] Baby step: remove unused garbage from framehelpers.inl
935d403 [2011-03-11 14:29:23 -0600] SF 3195323: remove -mrtl
1294c59 [2011-03-11 12:08:51 -0600] Unit tests validating SF 3104943
85bd56d [2011-03-11 11:40:16 -0600] SF 3206654: provide facility to identify mspgcc version
39596e3 [2011-03-11 10:15:12 -0600] Implement __builtin_{read,write}_stack_pointer
f02889e [2011-03-11 10:05:57 -0600] Implement __bis_status_register
1dfce7c [2011-03-11 09:59:10 -0600] Implement __bic_status_register
34c43ae [2011-03-11 09:47:08 -0600] Implement __write_status_register
4d3889b [2011-03-11 09:24:09 -0600] Stub status-register builtins; implement read
e5a7012 [2011-03-11 08:46:24 -0600] SF 3195325: remove -mdeb
7cd7646 [2011-03-11 08:36:42 -0600] SF 3195329: remove -mIAR
5a9c069 [2011-03-06 20:38:53 -0600] SF 3201686: gcc optimizes away static isr
53eb3ab [2011-03-06 20:18:23 -0600] SF 3198920: bi*_sr_irq incorrect
a026cc3 [2011-03-05 14:34:35 -0600] SF 3198924: get_frame_address wrong
ff69c66 [2011-03-05 13:45:44 -0600] Test builtins for return address and frame address.
537f549 [2011-03-03 15:55:14 -0600] Rework intrinsics that require frame pointers.
aafe5cc [2011-03-03 12:44:05 -0600] Cleanup/consistency in nop/eint/dint
a5a6811 [2011-03-03 12:31:04 -0600] Clean up bi*_sr_irq builtins.
4af5a14 [2011-03-02 13:39:37 -0600] Add built-ins for nop, eint, dint
1cad52d [2011-03-02 13:19:54 -0600] Unit test for get_frame_address
5e8a925 [2011-03-02 13:19:33 -0600] Refine parameter to builtins
df9cf2a [2011-03-02 09:46:35 -0600] Tests for bi[cs]_sr_irq intrinsics
32a021d [2011-03-01 10:18:06 -0600] Generate preprocessor symbols for cpu, mpy, and ivcnt values.
6371377 [2011-02-28 17:20:04 -0600] Clean up built-in declarations.
5813cf3 [2011-02-28 16:49:53 -0600] Remove more magic numbers
67fae96 [2011-02-28 16:31:36 -0600] Clean up built-in RTX expressions.
9d18745 [2011-02-28 16:17:00 -0600] Replace magic numbers with constants from md file
8102441 [2011-02-28 15:54:04 -0600] Eliminate magic numbers for unspec indices
7d5c8f8 [2011-02-27 13:13:11 -0600] Make everything just depend on cpu/mpy/ivcnt
2ce5df8 [2011-02-27 12:53:39 -0600] Enable calculation of proper multilib directory.
81f6003 [2011-02-27 11:50:39 -0600] Correct various problems with multilib specification
9096dee [2011-02-27 10:32:54 -0600] Basic multilib support.
6e41a2b [2011-02-27 09:19:26 -0600] Sort target hooks by manual section
727739a [2011-02-26 13:29:45 -0600] Remove all the declarations by moving the reference to follow the definition
4abff5d [2011-02-26 13:11:55 -0600] Do not presume that c++ is the same as c
600cad3 [2011-02-26 13:11:37 -0600] Put more things back where they belong.
bd7b5e8 [2011-02-26 13:02:02 -0600] Remove more unreferenced stuff; keep in the one legitimate one
f7a48de [2011-02-26 12:57:52 -0600] Replace unnecessary global macro
c23994a [2011-02-26 12:51:19 -0600] Put things where they belong
8f4fefa [2011-02-26 12:18:10 -0600] Go back and do the first subsections of Target Macros
cb4494f [2011-02-26 12:02:29 -0600] Move private macro to implementation file; remove outdated comments
30404eb [2011-02-26 11:59:28 -0600] Complete target macros.
8f0e198 [2011-02-26 11:36:50 -0600] Debugging info.
8d1c576 [2011-02-26 11:25:47 -0600] Complete Assembler Format
909929d [2011-02-26 11:18:14 -0600] Instruction output
4bde3c0 [2011-02-26 11:03:54 -0600] Macros for initialization
7332c83 [2011-02-26 11:00:51 -0600] Initialization
6ff0a5d [2011-02-26 11:00:43 -0600] Correct function name; add documentation removed from libgcc.S
4b07834 [2011-02-26 11:00:16 -0600] Remove material now located in crt0.S
f601076 [2011-02-25 16:04:32 -0600] Data and label output
4bc8c86 [2011-02-25 15:20:25 -0600] Reverse incorrect code standard change.
3be4849 [2011-02-25 15:10:18 -0600] Move hook to msp430.c; do 17.21.2 Data Output
405c77e [2011-02-25 14:56:42 -0600] Remove outdated/unreferenced asm_output_* functions
b1f3392 [2011-02-25 14:40:03 -0600] Sections
257efb3 [2011-02-25 14:19:26 -0600] Costs and scheduling
c9f5a9d [2011-02-25 13:58:35 -0600] Condition codes.
7a283c2 [2011-02-25 13:37:54 -0600] Run things through indent again
e45d06f [2011-02-25 13:33:00 -0600] Replace GO_IF_LEGITIMATE_ADDRESS with target hook
213ce55 [2011-02-25 13:20:44 -0600] Cleanup varargs, trampolines, library calls, addressing modes
d32099b [2011-02-25 10:14:15 -0600] Minor cleanup
d93445d [2011-02-25 09:33:21 -0600] Complete review of msp430.h for 17.10 Stack and Calling
c801827 [2011-02-25 09:19:37 -0600] 17.10.7 Register Arguments
6555205 [2011-02-25 08:55:15 -0600] 17.10.6 Stack Arguments
1f2ccd3 [2011-02-25 08:45:07 -0600] Stack/call up to 17.10.6
cd569f1 [2011-02-24 15:31:31 -0600] Review 17.8 and 17.9 (register classes and outdated constraints)
ef9e05c [2011-02-24 14:38:22 -0600] Review 17.7 Registers
c3beb73 [2011-02-24 13:31:06 -0600] Clean up section 17.6 Layout of Source Language Data Types
99fc7e4 [2011-02-24 13:08:51 -0600] Review and cleanup storage-related target data
acfd4e4 [2011-02-24 12:14:53 -0600] Consistent names for macros related to register returns
3adeb1d [2011-02-21 12:23:03 -0600] Convert LIBCALL_VALUE to target hook.
a98a5e7 [2011-02-21 12:07:03 -0600] SF 3188386: inefficient struct return convention
46f8277 [2011-02-21 11:52:13 -0600] Convert FUNCTION_VALUE to target hook
7689eb5 [2011-02-21 10:58:45 -0600] Remove STRUCT_VALUE macro.
94fccc8 [2011-02-21 10:55:06 -0600] Convert RETURN_IN_MEMORY to target hook
feee18d [2011-02-21 10:54:24 -0600] Correct target macro selection
d230668 [2011-02-10 09:04:44 -0600] Remove multilib and default mcu
7d72ab9 [2011-02-07 09:59:05 -0600] Emit cpu and mpy in generated assembly source
634cd52 [2011-02-24 11:52:32 -0600] Reduce check to accommodate gcc 4.5 limitation.
669ba0c [2011-02-21 03:46:48 -0600] Test case for PR middle-end/42722 (SF 3148801)
d6772e6 [2011-02-20 12:18:35 -0600] Test case for SF 3177314
951a044 [2011-02-20 11:39:38 -0600] Test case for SF 3112089
78fbbf0 [2011-02-19 16:14:12 -0600] Infrastructure for dejagnu autotests.
ebd6be7 [2011-02-24 09:47:54 -0600] Remove hard-coded MCU-specific information from msp430 port.
a13c84e [2011-01-01 19:51:09 -0600] Decouple front-end dependencies from target.
b2accf6 [2011-01-01 15:10:24 -0600] Update trampoline interface to current GCC implementation.
de467e5 [2011-01-01 14:46:49 -0600] Remove CAN_ELIMINATE.
50fd87a [2011-01-01 14:39:16 -0600] Update frame pointer support to current GCC implementation.
63cb597 [2011-01-01 14:25:04 -0600] Update for cond-optab branch.
2354f1f [2011-01-01 13:46:09 -0600] Remove poisoned LEGITIMIZE_ADDRESS.
6cf95dd [2011-01-01 13:41:09 -0600] Correct placement of GC marker
03a9106 [2011-01-01 12:22:52 -0600] Avoid reference to uninitialized operands.
36b4cae [2011-01-01 12:21:13 -0600] Fix mis-use of MEM_VOLATILE_P.
4c59517 [2010-12-31 18:43:31 -0600] Run through indent again
cba5a77 [2010-11-14 10:11:57 -0600] SF 3109143: Support value-line MSP430G22x1 devices
5092e93 [2010-08-29 13:10:46 -0500] SF 3055519: add support for 55xx chips
526fee6 [2010-08-29 10:45:10 -0500] Provide machine mode for certain constant integer operands.
7401fc6 [2010-08-29 10:22:54 -0500] SF 3055171: ICE in trunc_int_for_mode
d7d7602 [2010-11-19 14:50:58 -0600] SF 3112089: improper elimination of condition code set
1b0f6ad [2010-11-06 14:58:21 -0500] SF 3090574: -fPIC silently won't work
d89c540 [2010-08-15 08:58:26 -0500] Correct function prototype
735355e [2010-08-14 21:57:21 -0500] Down to one last warning that I plan to ignore for now
d2104bf [2010-08-14 21:45:10 -0500] C++ comments, format spec, const and signed qualifiers
4b508e3 [2010-08-14 21:36:00 -0500] Remove invalid comma, fix function declarations
acc8075 [2010-08-14 21:23:20 -0500] Eliminate warnings about C++ comments, mixed code/decl, unused variable
d0d36e1 [2010-08-14 21:12:01 -0500] Run through indent again
03bff4b [2010-08-14 21:11:32 -0500] Remove old-style definitions
136e923 [2010-08-14 20:36:44 -0500] Remove PARAMS wrappers, re-run indent.
3785875 [2010-08-14 20:27:26 -0500] Run everything through GNU indent version 2.2.10.
7ba79e4 [2010-07-16 19:00:47 -0500] Merge branch 'msp430' into dev/4.4.4
95b0112 [2010-07-16 18:11:23 -0500] Avoid dereferencing SET_SRC if instruction is not SET.
8288f6e [2010-05-27 14:19:20 -0500] Correct chip name
9da84ee [2010-05-20 19:17:08 +0000] Add file missed in commit 133
1b52f5f [2010-05-20 19:04:47 +0000] Revise generic categorization to match binutils and support new architectures.
2de401c [2010-02-15 21:26:05 -0700] Revise generic categorization to match binutils and support new architectures.
f7a3ca5 [2010-02-09 21:58:10 +0000] Integrated cc430 patches
4681bf9 [2010-02-03 09:53:20 +0000] Fixed incorrect stack allocation in main()
8efbb4c [2010-01-24 17:23:32 +0000] Improved MinGW compatibility
ed54f2c [2010-01-14 13:09:59 +0000] Fixed 'critical' and 'reentrant' attributes.
0cbc9ff [2010-01-14 11:58:49 +0000] Added patch for gcc 4.4.2 fixing incorrect structure pushing Fixed incorrect "call offset(sp)" instruction generation and simulation Fixed incorrect prologue generation for function with stack frame pointer caused by stack arguments and without local variables
b596201 [2009-12-23 14:37:11 +0000] Fixed frame structure generation
14dc41f [2009-12-19 11:07:46 +0000] Fixed the cc1 crash when a "push SP" instruction was generated. Eliminated the need to use R5 as an argument pointer. Added experimental support for -maccumulate-outgoing-args
fb8c53c [2009-11-21 19:30:36 +0000] Added full support for DWARF2 frame info and epilogue-based unwinder.
2d439aa [2009-11-21 14:57:38 +0000] Upgraded prologue/epilogue generation to INSN-level interface. Added support for DWARF2 frame unwind info generation.
df2957c [2009-11-03 15:21:55 +0000] Fixed ret/reti bug
a0c7049 [2009-11-03 12:45:40 +0000] git-svn-id: http://mspgcc4.svn.sourceforge.net/svnroot/mspgcc4@25 9c79f009-54bf-40f1-a1dd-edde5f34ab85
716d2c5 [2009-10-25 12:24:55 +0000] Temporary disabled incomplete DWARF2 unwind info generation
710a650 [2009-10-24 20:56:37 +0000] git-svn-id: http://mspgcc4.svn.sourceforge.net/svnroot/mspgcc4@16 9c79f009-54bf-40f1-a1dd-edde5f34ab85
236305a [2009-10-24 20:41:22 +0000] Added unwind info generation flag
f948168 [2009-10-24 19:14:13 +0000] Added full support for GDB 6.8 and 7.0 Added support for GCC 4.4.2
e72d34a [2009-10-01 10:49:22 +0000] Updated copyright notes
d730759 [2009-09-08 14:21:29 +0000] Initial version

diff --git gcc-4.5.3.orig/configure gcc-4.5.3/configure
index c60f1b3..6f5c066 100755
--- gcc-4.5.3.orig/configure
+++ gcc-4.5.3/configure
@@ -3588,6 +3588,9 @@ case "${target}" in
   mn10300-*-*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  msp430-*-*)
+    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj} target-libssp"
+    ;;
   mt-*-*)
     noconfigdirs="$noconfigdirs sim"
     ;;
diff --git gcc-4.5.3.orig/configure.ac gcc-4.5.3/configure.ac
index 35812aa..8acb7c8 100644
--- gcc-4.5.3.orig/configure.ac
+++ gcc-4.5.3/configure.ac
@@ -825,6 +825,9 @@ case "${target}" in
   mn10300-*-*)
     noconfigdirs="$noconfigdirs ${libgcj}"
     ;;
+  msp430-*-*)
+    noconfigdirs="$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj} target-libssp"
+    ;;
   mt-*-*)
     noconfigdirs="$noconfigdirs sim"
     ;;
diff --git gcc-4.5.3.orig/gcc/config.gcc gcc-4.5.3/gcc/config.gcc
index 0ff189c..9cee8b2 100644
--- gcc-4.5.3.orig/gcc/config.gcc
+++ gcc-4.5.3/gcc/config.gcc
@@ -835,6 +835,10 @@ avr-*-*)
 	extra_gcc_objs="driver-avr.o avr-devices.o"
 	extra_objs="avr-devices.o"
 	;;
+msp430-*-*)
+	tm_file="msp430/msp430.h dbxelf.h"
+	extra_objs="msp430-cbranch.o msp430-builtins.o msp430-function.o"
+	;;
 bfin*-elf*)
 	tm_file="${tm_file} dbxelf.h elfos.h newlib-stdint.h bfin/elf.h"
 	tmake_file=bfin/t-bfin-elf
diff --git gcc-4.5.3.orig/gcc/config/msp430/constraints.md gcc-4.5.3/gcc/config/msp430/constraints.md
new file mode 100644
index 0000000..5c2a5de
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/constraints.md
@@ -0,0 +1,104 @@
+;; -*- Mode: Scheme -*-
+;; Constraint definitions for Texas Instruments MSP430.
+;; Copyright (C) 2011 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 3, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;;; Available letters:
+;;;    ABCD  GHIJKLMNO Q        Z
+;;;    abcdef h jkl    q  t v x  
+;;; (nb: generic used are EFVXgimnoprs)
+
+;; Note that the hard frame pointer is also a general register.
+
+(define_register_constraint "z" "PC_REG"
+  "Program counter r0")
+
+(define_register_constraint "y" "SP_REG"
+  "Stack pointer r1")
+
+(define_register_constraint "Y" "GENERAL_SP_REGS"
+  "Union of r (GENERAL), y (SP)")
+
+(define_register_constraint "w" "SR_REG"
+  "Status register r2")
+
+(define_register_constraint "W" "GENERAL_SR_REGS"
+  "Union of r (GENERAL), w (SR)")
+
+(define_register_constraint "u" "FIXED_PSEUDO_REGS"
+  "Fixed pseudo-register (argp, soft fp)")
+
+(define_register_constraint "U" "FIXED_PSEUDO_GENERAL_SP_REGS"
+  "Union of u (FIXED PSEUDO), r (GENERAL), y (SP)")
+
+(define_constraint "R"
+  "Indirect register @rN (general or stack pointer)"
+  (match_test "msp430_indirect_register_operand (op)"))
+
+;(define_constraint "Q"
+;  "Indexed register X(rN) (general or stack pointer)"
+;  (match_test "msp430_indexed_register_operand (op)"))
+
+(define_constraint "S"
+  "Indirect stack pointer @r2"
+  (match_test "msp430_indirect_register_operand (op) && REGNO (XEXP (op, 0)) == STACK_POINTER_REGNUM"))
+
+(define_constraint "T"
+  "Indexed stack pointer X(r2)"
+  (match_test "msp430_indexed_register_operand (op) && REGNO (XEXP (XEXP (op, 0), 0)) == STACK_POINTER_REGNUM"))
+
+;(define_constraint "I"
+;  "Signed 16-bit integer"
+;  (and (match_code "const_int")
+;       (match_test "IN_RANGE (ival, -32768, 32767)")))
+
+;(define_constraint "J"
+;  "Non-positive signed 16-bit integer"
+;  (and (match_code "const_int")
+;       (match_test "IN_RANGE (ival, -32768, 0)")))
+
+;(define_constraint "K"
+;  "Non-negative signed 16-bit integer"
+;  (and (match_code "const_int")
+;       (match_test "IN_RANGE (ival, 0, 32767)")))
+
+;(define_constraint "L"
+;  "Unsigned 8-bit integer"
+;  (and (match_code "const_int")
+;       (match_test "IN_RANGE (ival, 0, 255)")))
+
+;(define_constraint "M"
+;  "Unsigned 8-bit integer requiring more than 4 bits"
+;  (and (match_code "const_int")
+;       (match_test "IN_RANGE (ival, 16, 255)")))
+
+;(define_constraint "N"
+;  "Unsigned 9-bit integer with high bit set"
+;  (and (match_code "const_int")
+;       (match_test "IN_RANGE (ival, 256, 511)")))
+
+;(define_constraint "O"
+;  "Integer one (1)"
+;  (and (match_code "const_int")
+;       (match_test "(ival == 1)")))
+
+(define_constraint "P"
+  "Integer constant supported by constant generator registers"
+  (and (match_code "const_int")
+       (match_test "(ival == -1 || ival == 0 || ival == 1 || ival == 2 || ival == 4 || ival == 8)")))
+
diff --git gcc-4.5.3.orig/gcc/config/msp430/crt0.S gcc-4.5.3/gcc/config/msp430/crt0.S
new file mode 100644
index 0000000..e469295
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/crt0.S
@@ -0,0 +1,307 @@
+/*  -*- Mode: Asm -*-  */
+#if WITH_DISABLE_WDT
+#define WDTIMER_KICK
+#else /* WITH_DISABLE_WDT */
+#define WDTIMER_KICK \
+	mov	r5, &__WDTCTL
+#endif /* WITH_DISABLE_WDT */
+/******* CRT support functions *********/
+
+/* The following sections are arranged in exactly this order by the loader,
+ * right before the text region.
+	;; .init0 (_reset_vector__: Start here after reset)
+	;; .init1 (User definable)
+	;; .init2 (__init_stack: Initialize stack)
+	;; .init3 (__low_level_init: Initialize hardware; user definable)
+	;; .init4 (__do_copy_data; __do_clear_bss: Copy data to .data, clear bss)
+	;; .init5 (User definable)
+	;; .init6 (__do_global_ctors: C++ constructors)
+	;; .init7 (User definable)
+	;; .init8 (User definable)
+	;; .init9 (main)
+	;; .fini9 (__stop_progExec__: Falls into here after main(). User definable)
+	;; .fini8 (User definable)
+	;; .fini7 (User definable)
+	;; .fini6 (C++ destructors)
+	;; .fini5 (User definable)
+	;; .fini4 (User definable)
+	;; .fini3 (User definable)
+	;; .fini2 (User definable)
+	;; .fini1 (User definable)
+	;; .fini0 (_endless_loop__: Infinite loop after program termination)
+
+NOTE: If you override any of the startup functions, ensure you put the
+	replacement in the correct section.
+*/
+
+#if defined(L_reset_vector__)
+/*****************************************************************
+ * Program starts here.
+ *   overwriting this label in the user program
+ *   causes removing all startup code except __do_global_ctors
+ *****************************************************************/
+	.section .init0, "ax", @progbits
+
+	.global	_reset_vector__
+	.weak   _reset_vector__
+
+	.func   _reset_vector__
+
+	;; .init0 (Start here after reset)
+_reset_vector__:
+
+	;; .init1 (User definable)
+	;; .init2 (Initialize stack)
+	.global	__init_stack
+	;; .init3 (Initialize hardware; user definable)
+	.global	__low_level_init
+	;; .init4 (Copy data to .data, clear bss)
+	.global __do_copy_data
+	.global __do_clear_bss
+	;; .init5 (User definable)
+	;; .init6 (C++ constructors)
+	/* .global __do_global_ctors ; Do not reference unless ctors exist */
+	;; .init7 (User definable)
+	;; .init8 (User definable)
+	;; .init9 (Main routine)
+	
+	;; compiler places the main routine in .init9 unless it is "hosted"
+	
+	;; .fini9 (__stop_progExec__: Falls into here after .init9. User definable)
+	.global __stop_progExec__
+	;; .fini8 (User definable)
+	;; .fini7 (User definable)
+	;; .fini6 (C++ destructors)
+	/* .global __do_global_dtors ; Do not reference unless dtors exist */
+	;; .fini5 (User definable)
+	;; .fini4 (User definable)
+	;; .fini3 (User definable)
+	;; .fini2 (User definable)
+	;; .fini1 (User definable)
+	;; .fini0 (_endless_loop__: Infinite loop after program termination)
+	.global _endless_loop__
+
+	.endfunc
+#endif  /* defined(L_reset_vector__) */
+	
+#if defined(L__init_stack)
+/*****************************************************************
+ * Set stack pointer
+ * can be overwriten
+    stack can be initialized in main() prologue,
+    but setting stack pointer here allows to call subroutines 
+    from startup code and call constructors of statically allocated C++ objects.
+    Stack pointer will have the same value entering main() as here,
+    so -mno-stack-init can be used to reduce code size.
+    initial stack value can be set in ld script as __stack symbol 
+    (end of RAM by default), or via -defsym __stack=<address> ld option
+    or via -Wl,defsym,__stack=<address> gcc option, or by redefining
+    __init_stack function as follows:
+
+#if defined (__cplusplus)
+extern "C" 
+endif
+__attribute__((__naked__)) __attribute__((section(".init2"))) void __init_stack()
+{
+    asm volatile("\tmov\t#stack_addr, r1\n");
+}
+
+ *****************************************************************/
+	.section .init2, "ax", @progbits
+
+	.global	__init_stack
+	.weak   __init_stack
+
+	.func   __init_stack
+
+__init_stack:
+	mov     #__stack, r1
+
+	.endfunc
+#endif
+
+#if defined(L__low_level_init)
+/*****************************************************************
+ * Initialize peripherals
+ * Default implemenation disables watchdog timer (conditional)
+ *****************************************************************/
+	.section .init3, "ax", @progbits
+
+	.global	__low_level_init
+	.weak   __low_level_init
+
+	.func   __low_level_init
+
+__low_level_init:
+#if WITH_DISABLE_WDT
+	mov     #0x5a80, &__WDTCTL
+#else /* WITH_DISABLE_WDT */
+	mov	&__WDTCTL, r5
+	and.b	#-1, r5
+	bis	#0x5a08, r5
+#endif /* WITH_DISABLE_WDT */
+	.endfunc
+#endif
+
+#if defined(L_copy_data)
+/*****************************************************************
+ * Initialize data: copy data 
+ * from __data_load_start ( = _etext) to __data_start
+ * can be overwriten
+ *****************************************************************/
+	.section .init4, "ax", @progbits
+
+	.global __do_copy_data
+	.weak   __do_copy_data
+
+	.func   __do_copy_data
+
+__do_copy_data:
+	mov     #__data_size, r15
+	tst     r15
+	jz      .L__copy_data_end
+.L__copy_data_loop:
+	WDTIMER_KICK
+	decd    r15
+	mov.w   __data_load_start(r15), __data_start(r15)    ; data section is word-aligned, so word transfer is acceptable
+	jne     .L__copy_data_loop
+.L__copy_data_end:
+
+	.endfunc
+#endif /* defined(L_copy_data) */
+    
+#if defined(L_clear_bss)
+/*****************************************************************
+ * Initialize data: clear .bss
+ * can be overwriten
+ *****************************************************************/
+	.section .init4, "ax", @progbits
+
+	.global __do_clear_bss
+	.weak   __do_clear_bss
+
+	.func   __do_clear_bss
+
+__do_clear_bss:
+	mov     #__bss_size, r15
+	tst     r15
+	jz      .L__clear_bss_end
+.L__clear_bss_loop:
+	WDTIMER_KICK
+	dec     r15
+	clr.b   __bss_start(r15)
+	jne     .L__clear_bss_loop
+.L__clear_bss_end:
+
+	.endfunc
+#endif  /* defined(L_clear_bss) */
+
+#if defined(L__stop_progExec__)
+/*****************************************************************
+ * Execute after main returns
+ * Default implementation does nothing
+ *****************************************************************/
+	.section .fini9, "ax", @progbits
+	.global __stop_progExec__
+	.weak	__stop_progExec__
+
+	.func  __stop_progExec__
+__stop_progExec__:
+	.endfunc
+	
+#endif
+
+#if defined(L_endless_loop__)
+/*****************************************************************
+ * Placed at end of CRT code unless overridden
+ * Default implementation loops entering LPM4, leaving GIE unchanged
+ *****************************************************************/
+	.section .fini0, "ax", @progbits
+
+	.global _endless_loop__
+	.weak	_endless_loop__
+	.func   _endless_loop__
+
+_endless_loop__:
+	bis	#0xf0, r2
+	jmp  _endless_loop__
+
+	.endfunc
+
+#endif  /* defined(L_endless_loop__) */
+    
+#if defined(L_ctors430)
+/*****************************************************************
+ * Call constructor functions.
+ *
+ * No reference to this should be generated unless a function pointer
+ * is added to the .ctors section.  This means that the code will
+ * be absent from the executable unless at least one pointer is
+ * present, which also means we don't have to check for an empty
+ * function list.
+ *****************************************************************/
+	.section .init6, "ax", @progbits
+	.global __do_global_ctors
+	.weak   __do_global_ctors
+    
+	.func   __do_global_ctors
+
+__do_global_ctors:
+	mov     #__ctors_start, r11
+	mov     #__ctors_end,   r10
+.L__ctors_loop:
+	WDTIMER_KICK
+	call	@r11+	; call constructor
+	cmp     r10, r11
+	jne     .L__ctors_loop
+
+	.endfunc
+#endif
+    
+#if defined(L_dtors430)
+/*****************************************************************
+ * Call destructor functions.
+ *
+ * No reference to this should be generated unless a function pointer
+ * is added to the .dtors section.  This means that the code will
+ * be absent from the executable unless at least one pointer is
+ * present, which also means we don't have to check for an empty
+ * function list.
+ *****************************************************************/
+	.section .fini6,"ax",@progbits
+	.global __do_global_dtors
+	.weak   __do_global_dtors
+    
+	.func   __do_global_dtors
+
+__do_global_dtors:
+	mov     #__dtors_start, r11
+	mov     #__dtors_end, r10
+.L__dtors_loop:
+	WDTIMER_KICK
+	call    @r11+
+	cmp     r10, r11
+	jne     .L__dtors_loop
+
+	.endfunc
+#endif
+
+#if defined(L_unexpected_)
+
+/*****************************************************************
+ * unexpected interrupt vector handler
+ * can be overwriten by user function with the same name:
+ *   void _unexpected_ __attribute__((interrupt)) { }
+ *
+ *****************************************************************/
+
+	.section .text.crt0, "ax", @progbits
+
+	.global	_unexpected_
+        .weak   _unexpected_
+
+        .p2align 1,0
+_unexpected_:
+        reti
+	
+#endif
diff --git gcc-4.5.3.orig/gcc/config/msp430/crt0ivtbl.S gcc-4.5.3/gcc/config/msp430/crt0ivtbl.S
new file mode 100644
index 0000000..696f6aa
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/crt0ivtbl.S
@@ -0,0 +1,102 @@
+/*  -*- Mode: Asm -*-  */
+
+	.section .text.crt0, "ax", @progbits
+	
+/***************************************************************
+ *	Interrupt Vectors:
+ *	WARNING!!! All vectors must be defined here!!!
+ *	User may not define its interrupt service routines!
+ ***************************************************************/
+	
+.macro  INITIALIZE_ISR_SLOT sn
+        .weak   __isr_\sn
+        .equ    __isr_\sn, __br_unexpected_
+        .word   __isr_\sn
+.endm
+
+.macro	DEFINE_IVTABLE _n
+	.global	__ivtbl_\_n
+	.type	__ivtbl_\_n, @object
+	.size	__ivtbl_\_n, 2*\_n
+__ivtbl_\_n:
+.endm	
+
+.text
+        .p2align 1,0
+__br_unexpected_:
+        br     #_unexpected_
+
+	.global	_unexpected_
+	.global	_reset_vector__
+        .section .vectors, "ax", @progbits
+	
+DEFINE_IVTABLE INTERRUPT_VECTOR_COUNT
+	
+	INITIALIZE_ISR_SLOT 0
+	INITIALIZE_ISR_SLOT 1
+	INITIALIZE_ISR_SLOT 2
+	INITIALIZE_ISR_SLOT 3
+	INITIALIZE_ISR_SLOT 4
+	INITIALIZE_ISR_SLOT 5
+	INITIALIZE_ISR_SLOT 6
+	INITIALIZE_ISR_SLOT 7
+	INITIALIZE_ISR_SLOT 8
+	INITIALIZE_ISR_SLOT 9
+	INITIALIZE_ISR_SLOT 10
+	INITIALIZE_ISR_SLOT 11
+	INITIALIZE_ISR_SLOT 12
+	INITIALIZE_ISR_SLOT 13
+	INITIALIZE_ISR_SLOT 14
+#if 16 < INTERRUPT_VECTOR_COUNT
+	INITIALIZE_ISR_SLOT 15
+	INITIALIZE_ISR_SLOT 16
+	INITIALIZE_ISR_SLOT 17
+	INITIALIZE_ISR_SLOT 18
+	INITIALIZE_ISR_SLOT 19
+	INITIALIZE_ISR_SLOT 20
+	INITIALIZE_ISR_SLOT 21
+	INITIALIZE_ISR_SLOT 22
+	INITIALIZE_ISR_SLOT 23
+	INITIALIZE_ISR_SLOT 24
+	INITIALIZE_ISR_SLOT 25
+	INITIALIZE_ISR_SLOT 26
+	INITIALIZE_ISR_SLOT 27
+	INITIALIZE_ISR_SLOT 28
+	INITIALIZE_ISR_SLOT 29
+	INITIALIZE_ISR_SLOT 30
+#endif /* 16 < INTERRUPT_VECTOR_COUNT */
+#if 32 < INTERRUPT_VECTOR_COUNT
+	INITIALIZE_ISR_SLOT 31
+	INITIALIZE_ISR_SLOT 32
+	INITIALIZE_ISR_SLOT 33
+	INITIALIZE_ISR_SLOT 34
+	INITIALIZE_ISR_SLOT 35
+	INITIALIZE_ISR_SLOT 36
+	INITIALIZE_ISR_SLOT 37
+	INITIALIZE_ISR_SLOT 38
+	INITIALIZE_ISR_SLOT 39
+	INITIALIZE_ISR_SLOT 40
+	INITIALIZE_ISR_SLOT 41
+	INITIALIZE_ISR_SLOT 42
+	INITIALIZE_ISR_SLOT 43
+	INITIALIZE_ISR_SLOT 44
+	INITIALIZE_ISR_SLOT 45
+	INITIALIZE_ISR_SLOT 46
+	INITIALIZE_ISR_SLOT 47
+	INITIALIZE_ISR_SLOT 48
+	INITIALIZE_ISR_SLOT 49
+	INITIALIZE_ISR_SLOT 50
+	INITIALIZE_ISR_SLOT 51
+	INITIALIZE_ISR_SLOT 52
+	INITIALIZE_ISR_SLOT 53
+	INITIALIZE_ISR_SLOT 54
+	INITIALIZE_ISR_SLOT 55
+	INITIALIZE_ISR_SLOT 56
+	INITIALIZE_ISR_SLOT 57
+	INITIALIZE_ISR_SLOT 58
+	INITIALIZE_ISR_SLOT 59
+	INITIALIZE_ISR_SLOT 60
+	INITIALIZE_ISR_SLOT 61
+	INITIALIZE_ISR_SLOT 62
+#endif /* 32 < INTERRUPT_VECTOR_COUNT */
+        .word _reset_vector__
diff --git gcc-4.5.3.orig/gcc/config/msp430/libgcc.S gcc-4.5.3/gcc/config/msp430/libgcc.S
new file mode 100644
index 0000000..ef234d4
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/libgcc.S
@@ -0,0 +1,1135 @@
+/*  -*- Mode: Asm -*-  */
+
+/* Offset from r1 to first word of stack-pushed arguments. */
+#define	ARGP_OFFSET	2	
+
+	.section .text.libgcc, "ax", @progbits
+
+#if defined (L_cmpsi2)
+	
+	.global	__cmpsi2
+	.func	__cmpsi2
+__cmpsi2:
+	sub	r12, r14
+	subc	r13, r15
+	jge	.L_ge
+	mov	#0, r15		; a < b return 0
+	ret
+	
+.L_ge:
+	bis	r14, r15
+	tst	r15
+	jz	.L_eq
+
+	mov	#2, r15		; a > b return 2
+	ret
+.L_eq:
+	mov	#1, r15		; a == b return 1
+	ret
+.endfunc
+#endif
+
+#if defined (L_ucmpsi2)
+	
+	.global	__ucmpsi2
+	.func	__ucmpsi2
+__ucmpsi2:
+	sub	r12, r14
+	subc	r13, r15
+	jhs	.L_ge
+	mov	#0, r15		; a < b return 0
+	ret
+	
+.L_ge:
+	bis	r14, r15
+	tst	r15
+	jz	.L_eq
+
+	mov	#2, r15		; a > b return 2
+	ret
+.L_eq:
+	mov	#1, r15		; a == b return 1
+	ret
+.endfunc
+#endif
+
+#if defined (L_cmpdi2)
+	.global	__cmpdi2
+	.func	__cmpdi2
+__cmpdi2:
+	sub	ARGP_OFFSET(r1), r12
+	subc	2+ARGP_OFFSET(r1), r13
+	subc	4+ARGP_OFFSET(r1), r14
+	subc	6+ARGP_OFFSET(r1), r15
+	jge	.L_ge
+	mov	#0, r15		; a < b return 0
+	ret
+	
+.L_ge:
+	bis	r12, r15
+	bis	r13, r15
+	bis	r14, r15
+	tst	r15
+	jz	.L_eq
+
+	mov	#2, r15		; a > b return 2
+	ret
+.L_eq:
+	mov	#1, r15		; a == b return 1
+	ret
+.endfunc
+#endif
+
+#if defined (L_ucmpdi2)
+	
+	.global	__ucmpdi2
+	.func	__ucmpdi2
+__ucmpdi2:
+	sub	ARGP_OFFSET(r1), r12
+	subc	2+ARGP_OFFSET(r1), r13
+	subc	4+ARGP_OFFSET(r1), r14
+	subc	6+ARGP_OFFSET(r1), r15
+	jhs	.L_ge
+	mov	#0, r15		; a < b return 0
+	ret
+	
+.L_ge:
+	bis	r12, r15
+	bis	r13, r15
+	bis	r14, r15
+	tst	r15
+	jz	.L_eq
+
+	mov	#2, r15		; a > b return 2
+	ret
+.L_eq:
+	mov	#1, r15		; a == b return 1
+	ret
+.endfunc
+#endif
+
+#if defined (L_cmpsf2)
+	.global __cmpsf2
+	.func	__cmpsf2
+__cmpsf2:
+        cmp     r12, r14	;  11  cmpsi   [length = 3]
+        jne     .L2
+        cmp     r13, r15
+        jne     .L2      	;  12  bne     [length = 1]
+        mov     #llo(0), r15	;  15  *movhi3/7       [length = 1]
+	ret
+.L2:
+        tst     r15		;  20  tstsi   [length = 1]
+        jge     .L3		;  21  bge     [length = 1]
+        tst     r13		;  22  tstsi   [length = 1]
+        jge     .L3		;  23  bge     [length = 1]
+        xor     #lhi(-2147483648), r15		;  27  *xorsi3_3       [length = 2]
+        xor     #lhi(-2147483648), r13		;  29  *xorsi3_3       [length = 2]
+.L3:
+        sub     r14, r12	;  64  *subsi3_3       [length = 2]
+        subc    r15, r13
+        jge     .L4		;  33  bge     [length = 1]
+        mov     #llo(1), r15	;  36  *movhi3/7       [length = 1]
+	ret
+.L4:
+        mov     #llo(-1), r15	;  43  *movhi3/7       [length = 1]
+.L1:
+/* epilogue: frame size=0 */
+        ret
+/* epilogue end (size=3) */
+/* function __cmpsf2 size 25 (20) */
+
+.endfunc
+
+#endif
+
+
+
+/*******************************************************
+               Multiplication  8 x 8
+*******************************************************/
+#if defined (L_mulqi3)
+/* 
+	a = reg:qi 10	clobber
+	b = reg:qi 12	clobber
+	res = reg:qi 14
+*/
+
+	.global	__mulqi3
+	.func	__mulqi3
+__mulqi3:
+	clr	r14
+.L__mulqiloop:
+	tst.b	r10
+	jz	.L__mulqiexit
+	clrc
+	rrc.b	r12
+	jnc	+2
+	add.b	r10, r14
+	rla.b	r10
+	tst.b	r12
+	jne	.L__mulqiloop
+.L__mulqiexit:
+	ret
+	.endfunc
+#endif 	/* defined (L_mulqi3) */
+
+
+#if defined (L_mulqihi3)
+	.global	__mulqihi3
+	.func	__mulqihi3
+__mulqihi3:
+	sxt	r10
+	sxt	r12
+	br	#__mulhi3
+.endfunc
+#endif /* defined (L_mulqihi3) */
+
+#if defined (L_umulqihi3)
+	.global	__umulqihi3
+	.func	__umulqihi3
+__umulqihi3:
+	and.b	#-1, r10
+	and.b	#-1, r12
+	br	#__mulhi3
+	.endfunc
+#endif /* defined (L_umulqihi3) */
+
+/*******************************************************
+               Multiplication  16 x 16
+*******************************************************/
+#if defined (L_mulhi3)
+/* 
+	a = reg:hi 10	clobber
+	b = reg:hi 12	clobber
+	res = reg:hi 14
+*/
+
+	.global	__mulhi3
+	.func	__mulhi3
+__mulhi3:
+	clr	r14
+.L__mulhiloop:
+	tst	r10
+	jz	.L__mulhiexit
+	clrc
+	rrc	r12
+	jnc	+2
+	add	r10, r14
+	rla	r10
+	tst     r12
+	jne	.L__mulhiloop
+.L__mulhiexit:
+	ret
+	.endfunc
+#endif /* defined (L_mulhi3) */
+
+#if defined (L_mulhisi3)
+/* clobber r11, r13 */
+	.global	__mulhisi3
+	.func	__mulhisi3
+__mulhisi3:
+	clr	r11
+	tst	r10
+	jge	1f
+	mov	#-1, r11
+1:	clr	r13
+	tst	r12
+	jge	2f
+	mov	#-1, r13
+2:	br	#__mulsi3
+	.endfunc
+#endif /* defined (L_mulhisi3) */
+
+#if defined (L_umulhisi3)
+	.global	__umulhisi3
+	.func	__umulhisi3
+__umulhisi3:
+	clr	r11
+	clr	r13
+	br	#__mulsi3
+	.endfunc
+#endif /* defined (L_umulhisi3) */
+
+#if defined (L_mulsi3)
+/*******************************************************
+               Multiplication  32 x 32
+*******************************************************/
+/*
+res = a*b
+	a - reg:SI 10 clobber
+	b - reg:SI 12 clobber
+	res - reg: SI 14
+*/
+	.global	__mulsi3
+	.func	__mulsi3
+
+__mulsi3:
+	clr	r14
+	clr	r15
+	jmp	.L__mulsi3st
+.L__mulsi3loop:
+	clrc
+	rrc	r13		;	b >>= 1
+	rrc 	r12
+	jnc	+4		;	
+	add	r10, r14	;	res = res + a
+	addc	r11, r15
+	rla	r10
+	rlc	r11		;	a <<= 1
+.L__mulsi3st:
+	tst	r12		; if b ne 0 goto L__mulsi3loop
+	jne	.L__mulsi3loop
+	tst	r13
+	jne	.L__mulsi3loop
+	ret
+	.endfunc
+
+#endif
+
+#if defined (L_mulsi3hw)
+	
+	.global	__umulsi3hw
+	.func	__umulsi3hw
+__umulsi3hw:
+	mov	r12, &__MPY
+	mov	r10, &__OP2
+	mov	r12, &__MAC
+	mov	&__RESLO, r14
+	mov	&__RESHI, &__RESLO
+	mov	r11, &__OP2
+	mov	r13, &__MAC
+	mov	r10, &__OP2
+	mov	&__RESLO, r15
+	ret
+.endfunc
+
+#endif
+
+	
+/*******************************************************
+       Division 8 / 8 => (result + remainder)
+*******************************************************/
+
+#define r_rem   r14	/* remainder */
+#define r_arg1  r12	/* dividend, quotient */
+#define r_arg2  r10	/* divisor */
+#define r_cnt   r11	/* loop count */
+#define r_tmp	r13	/* save carry flag */
+
+
+#if defined (L_udivmodqi4)
+	.global	__udivmodqi4
+	.func	__udivmodqi4
+__udivmodqi4:
+	xor.b	r_rem, r_rem		; clear reminder and carry
+	mov.b	#9, r_cnt
+	jmp	.L__udivmodqi4_ep
+.L__udivmodqi4_loop:	
+	rrc	r_tmp			; restore carry bit
+	rlc.b	r_rem
+	cmp.b	r_arg2, r_rem
+	jlo	.L__udivmodqi4_ep
+	sub.b	r_arg2, r_rem		; FIXME: will this clobber carry ?
+.L__udivmodqi4_ep:
+	rlc.b	r_arg1			; shift divident
+	rlc	r_tmp			; save carry bit
+	dec.b	r_cnt			; this clobbers C bit.
+	jnz	.L__udivmodqi4_loop
+	ret
+	.endfunc
+#endif /* defined (L_udivmodqi4) */
+
+
+#if defined (L_divmodqi4)
+	.global	__divmodqi4
+	.func	__divmodqi4
+__divmodqi4:
+	clr	r_tmp
+	bit	#0x80, r_arg1		; save divident sign
+	jnc	.L__divmodqi4arg1pos
+	inv.b	r_arg1			; negate
+	inc.b	r_arg1
+	bis	#4, r_tmp
+
+.L__divmodqi4arg1pos:
+	bit	#0x80, r_arg2		; check divisor sign
+	jnc	.L__divmodqi4arg2pos
+	inv.b	r_arg2			; negate
+	inc.b	r_arg2
+	bis	#8, r_tmp
+
+.L__divmodqi4arg2pos:
+	
+	call	#__udivmodqi4		; do unsigned division
+	rrc	r_tmp			; restore carry and sign bits
+
+	bit	#4, r_tmp		; is divident < 0 ?
+	jnc	.L__divmodqi4rem	; no. skip
+	inv.b	r_rem			; negate remainder
+	inc.b	r_rem
+
+;;	bit	#8, r_tmp
+;;	jc	.L__divmodqi4end
+	inv.b	r_arg1			; negate quotient
+	inc.b	r_arg1
+
+.L__divmodqi4rem:
+	bit	#8, r_tmp
+	jnc	.L__divmodqi4end
+	inv.b	r_arg1
+	inc.b	r_arg1
+
+.L__divmodqi4end:
+	ret
+
+	.endfunc
+#endif /* defined (L_divmodqi4) */
+
+#undef r_rem
+#undef r_arg1
+#undef r_arg2
+#undef r_cnt 
+#undef r_tmp
+
+
+/*******************************************************
+       Division 16 / 16 => (result + remainder)
+*******************************************************/
+
+#define r_rem   r14	/* remainder */
+#define r_arg1  r12	/* dividend, quotient */
+#define r_arg2  r10	/* divisor */
+#define r_cnt   r11	/* loop count */
+#define r_tmp	r13
+
+
+#if defined (L_udivmodhi4)
+	.global	__udivmodhi4
+	.func	__udivmodhi4
+__udivmodhi4:
+	xor	r_rem, r_rem		; clear reminder and carry
+	mov	#17, r_cnt
+	jmp	.L__udivmodhi4_ep
+.L__udivmodhi4_loop:	
+	rrc	r_tmp			; restore carry bit
+	rlc	r_rem
+	cmp	r_arg2, r_rem
+	jlo	.L__udivmodhi4_ep
+	sub	r_arg2, r_rem
+.L__udivmodhi4_ep:
+	rlc	r_arg1
+	rlc	r_tmp			; save carry bit
+	dec	r_cnt			; this clobbers C bit.
+	jnz	.L__udivmodhi4_loop
+	ret
+	.endfunc
+#endif /* defined (L_udivmodhi4) */
+
+
+#if defined (L_divmodhi4)
+#define r_rem   r14     /* remainder */
+#define r_arg1  r12     /* dividend, quotient */
+#define r_arg2  r10     /* divisor */   
+#define r_cnt   r11     /* loop count */
+#define r_tmp   r13
+
+
+	.global	__divmodhi4
+	.func	__divmodhi4
+__divmodhi4:
+	clr	r_tmp			; clear reg is cheaper than clr 2 bits.
+	bit	#0x8000, r_arg1		; save divident sign
+	jnc	.L__divmodhi4arg1pos
+	inv	r_arg1			; negate
+	inc	r_arg1
+	bis	#4, r_tmp
+
+.L__divmodhi4arg1pos:
+	bit	#0x8000, r_arg2		; check divisor sign
+	jnc	.L__divmodhi4arg2pos
+	inv	r_arg2			; negate
+	inc	r_arg2
+	bis	#8, r_tmp
+
+.L__divmodhi4arg2pos:	
+	call	#__udivmodhi4		; do unsigned division
+	rrc	r_tmp			; restore carry and sign bits
+
+	bit	#4, r_tmp		; is divident < 0 ?
+	jnc	.L__divmodhi4rem	; no. skip
+	inv	r_rem			; negate remainder
+	inc	r_rem
+
+;;	bit	#8, r_tmp
+;;	jc	.L__divmodhi4end
+	inv	r_arg1			; negate quotient
+	inc	r_arg1
+
+.L__divmodhi4rem:
+	bit	#8, r_tmp
+	jnc	.L__divmodhi4end
+	inv	r_arg1
+	inc	r_arg1
+
+.L__divmodhi4end:
+	ret
+	.endfunc
+#endif /* defined (L_divmodhi4) */
+
+#undef r_rem
+#undef r_arg1
+#undef r_arg2
+#undef r_cnt 
+#undef r_tmp
+
+/*******************************************************
+       Division 32 / 32 => (result + remainder)
+*******************************************************/
+
+#if defined (L_udivmodsi4)
+
+#define r_remh  r15  
+#define r_reml  r14	/* remainder */
+#define r_arg1h r13
+#define r_arg1l r12	/* dividend, quotient */
+#define r_arg2h r11   
+#define r_arg2l r10	/* divisor */
+#define r_cnt   r9	/* loop count */
+#define r_tmp   r8
+
+	.global	__udivmodsi4
+	.func	__udivmodsi4
+__udivmodsi4:
+	xor	r_remh, r_remh		; clear reminder and carry
+	xor	r_reml, r_reml
+	mov	#33, r_cnt
+	jmp	.L__udivmodsi4_ep
+.L__udivmodsi4_loop:	
+	rrc	r_tmp			; restore carry bit
+	rlc	r_reml
+	rlc	r_remh
+
+	cmp	r_arg2h, r_remh		; is reminder < divisor ?
+	jlo	.L__udivmodsi4_ep	; yes, skip correction
+	jne	+4
+					; they equal. check LSBytes
+	cmp	r_arg2l, r_reml
+	jlo	.L__udivmodsi4_ep	; is reminder still < divisor ?
+
+	sub	r_arg2l, r_reml		; adjust reminder
+	subc	r_arg2h, r_remh
+
+.L__udivmodsi4_ep:
+	rlc	r_arg1l
+	rlc	r_arg1h
+	rlc	r_tmp
+	dec	r_cnt			; this clobbers C bit.
+	jnz	.L__udivmodsi4_loop
+	ret
+	.endfunc
+
+#undef r_remh
+#undef r_reml  
+#undef r_arg1h
+#undef r_arg1l
+#undef r_arg2h
+#undef r_arg2l
+
+#undef r_cnt
+#undef r_tmp
+
+#endif /* defined (L_udivmodsi4) */
+
+
+#if defined (L_divmodsi4)
+#define r_remh  r15  
+#define r_reml  r14     /* remainder */
+#define r_arg1h r13
+#define r_arg1l r12     /* dividend, quotient */
+#define r_arg2h r11   
+#define r_arg2l r10     /* divisor */   
+#define r_cnt   r9      /* loop count */
+#define r_tmp   r8
+
+	.global	__divmodsi4
+	.func	__divmodsi4
+__divmodsi4:
+	clr	r_tmp			; clear reg is cheaper than clr 2 bits.
+	bit	#0x8000, r_arg1h		; save divident sign
+	jz	.L__divmodsi4arg1pos
+	inv	r_arg1h			; negate
+	inv	r_arg1l
+	inc	r_arg1l
+	adc	r_arg1h
+	bis	#4, r_tmp
+
+.L__divmodsi4arg1pos:
+	bit	#0x8000, r_arg2h		; check divisor sign
+	jz	.L__divmodsi4arg2pos
+	inv	r_arg2h			; negate
+	inv	r_arg2l
+	inc	r_arg2l
+	adc	r_arg2h
+	bis	#8, r_tmp		; save divisor sign
+
+.L__divmodsi4arg2pos:
+	
+	call	#__udivmodsi4		; do unsigned division
+	rrc	r_tmp			; restore carry and sign bits
+
+	bit	#4, r_tmp		; is divident < 0 ?
+	jz	.L__divmodsi4rem	; no. skip
+	inv	r_reml			; negate remainder
+	inv	r_remh
+	inc	r_reml
+	adc	r_remh
+
+;;	bit	#8, r_tmp
+;;	jc	.L__divmodsi4end
+	inv	r_arg1l			; negate quotient
+	inv	r_arg1h
+	inc	r_arg1l
+	adc	r_arg1h
+
+.L__divmodsi4rem:
+	bit	#8, r_tmp
+	jz	.L__divmodsi4end
+	inv	r_arg1l
+	inv	r_arg1h
+	inc	r_arg1l
+	adc	r_arg1h
+
+.L__divmodsi4end:
+	ret
+	.endfunc
+
+#undef r_remh  
+#undef r_reml  
+#undef r_arg1h 
+#undef r_arg1l
+#undef r_arg2h
+#undef r_arg2l
+
+#undef r_cnt
+#undef r_tmp
+
+#endif /* defined (L_divmodsi4) */
+
+/******* support functions *********/
+
+/********* PROLOGE / EPILOGUE aux routines ******************/
+#if defined (L__prologue_saver)
+	.global __prologue_saver
+	.func	__prologue_saver
+__prologue_saver:
+	mov	r4, 0(r1)
+	mov	r5, 2(r1)
+	mov	r6, 4(r1)
+	mov	r7, 6(r1)
+	mov	r8, 8(r1)
+	mov	r9, 10(r1)
+	mov	r10, 12(r1)
+	mov	r11, 14(r1)
+	br	r12	; now jump to the function body
+.endfunc
+
+#endif
+
+
+#if defined (L__epilogue_restorer)
+	.global __epilogue_restorer
+	.func	__epilogue_restorer
+__epilogue_restorer:
+	pop	r4
+	pop	r5
+	pop	r6
+	pop	r7
+	pop	r8
+	pop	r9
+	pop	r10
+	pop	r11
+	ret
+.endfunc
+
+#endif
+
+
+#if defined (L__epilogue_restorer_intr)
+	.global __epilogue_restorer_intr
+	.func	__epilogue_restorer_intr
+__epilogue_restorer_intr:
+	pop	r4
+	pop	r5
+	pop	r6
+	pop	r7
+	pop	r8
+	pop	r9
+	pop	r10
+	pop	r11
+	pop	r12
+	pop	r13
+	pop	r14
+	pop	r15
+	reti
+.endfunc
+
+#endif
+
+/******************************************
+ * quot/rem = 64/64
+ ******************************************/
+
+#if defined (L_udivmoddi3_parts) || defined (L_udivdi3) || defined (L_umoddi3) || defined (L_divdi3) || defined (L_moddi3)
+
+#define r_remhh  r11  	/* remainder */
+#define r_remhl  r10
+#define r_remlh	 r9
+#define r_remll	 r8
+
+#define r_arg1hh r15	/* dividend, quotient */
+#define r_arg1hl r14
+#define r_arg1lh r13
+#define r_arg1ll r12
+
+#define r_arg2hh r7	/* divisor */
+#define r_arg2hl r6
+#define r_arg2lh r5
+#define r_arg2ll r4
+
+#define r_cnt   2(r1)	/* loop count */
+#define r_tmp   0(r1)	/* we'll save carry and signs here */
+
+#endif
+
+
+#if defined (L_udivmoddi3_parts)
+
+	.global	__udivmoddi3_parts
+	.func	__udivmoddi3_parts
+__udivmoddi3_parts:
+	xor	r_remhh, r_remhh	; clear reminder and carry
+	xor	r_remhl, r_remhl 
+	xor	r_remlh, r_remlh
+	xor	r_remll, r_remll
+	
+	mov	#65, 2+r_cnt
+	jmp	.L__udivmoddi3_ep
+
+.L__udivmoddi3_loop:	
+	rrc	2+r_tmp			; restore carry bit
+	
+	rlc	r_remll			; shift carry in.
+	rlc	r_remlh
+	rlc	r_remhl
+	rlc	r_remhh
+	
+	cmp     r_arg2hh, r_remhh       ; is reminder < divisor ?
+	jlo     .L__udivmoddi3_ep       ; yes, skip correction
+	jne     .L_udmdcrt
+					; they equal. check LSBytes
+	cmp     r_arg2hl, r_remhl
+	jlo     .L__udivmoddi3_ep       ; is reminder still < divisor ?
+	jne     .L_udmdcrt
+
+	cmp     r_arg2lh, r_remlh
+	jlo     .L__udivmoddi3_ep
+	jne     .L_udmdcrt
+
+	cmp     r_arg2ll, r_remll
+	jlo     .L__udivmoddi3_ep
+	jne     .L_udmdcrt
+
+.L_udmdcrt:
+	sub	r_arg2ll, r_remll	; adjust reminder
+	subc	r_arg2lh, r_remlh
+	subc	r_arg2hl, r_remhl
+	subc	r_arg2hh, r_remhh
+	
+.L__udivmoddi3_ep:
+	rlc	r_arg1ll		; shift carry into arg1
+	rlc	r_arg1lh
+	rlc	r_arg1hl
+	rlc	r_arg1hh
+	
+	rlc	2+r_tmp			; save carry
+	dec	2+r_cnt			; this clobbers C bit.
+	jnz	.L__udivmoddi3_loop
+	
+	ret
+	.endfunc
+
+#endif /* defined (L_udivmoddi3_parts) */
+
+
+#if defined (L_udivdi3)
+
+;;  First arg will be in r15:r12 
+;;  next on stack
+;;	return in r15:r12
+;; rearrange them as:
+;;	r15:r12 	-> 	r_arg1hh:r_arg1ll
+;;	stack+8:stack+2 -> 	r_arg2hh:r_arg2ll
+
+	.global	__udivdi3
+	.func	__udivdi3
+__udivdi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	; 18 is a stack offset
+	mov	18+2(r1), r_arg2lh	; so move arg 2 in.
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+	
+	sub	#4, r1
+	call	#__udivmoddi3_parts
+	add	#4, r1
+	
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+#if defined (L_umoddi3)
+	.global	__umoddi3
+	.func	__umoddi3
+__umoddi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	
+	mov	18+2(r1), r_arg2lh
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+
+	sub	#4, r1
+	call    #__udivmoddi3_parts
+	add	#4, r1
+	
+	mov	r_remhh, r15	; move reminder to (reg:DI 12)
+	mov	r_remhl, r14
+	mov	r_remlh, r13
+	mov	r_remll, r12
+	
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+#if defined (L_divdi3)
+	.global	__divdi3
+	.func	__divdi3
+__divdi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	
+	mov	18+2(r1), r_arg2lh
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+	
+	sub	#4, r1
+	
+	clr	r_tmp
+	bit     #0x8000, r_arg1hh
+	jnc     .L__divdi3rempos
+	inv	r_arg1hh
+	inv     r_arg1hl
+	inv     r_arg1lh
+	inv     r_arg1ll
+	inc	r_arg1ll
+	adc     r_arg1lh
+	adc     r_arg1hl
+	adc     r_arg1hh
+	bis     #4, r_tmp
+	
+.L__divdi3rempos:
+	bit     #0x8000, r_arg2hh
+	jnc     .L__divdi3arg2pos	
+	inv	r_arg2hh
+	inv     r_arg2hl
+	inv     r_arg2lh
+	inv     r_arg2ll
+	inc	r_arg2ll
+	adc     r_arg2lh
+	adc     r_arg2hl
+	adc     r_arg2hh
+	xor     #4, r_tmp	; this is a trick - invert bit 4 =>
+				; do not perform double negation.
+.L__divdi3arg2pos:
+	call	#__udivmoddi3_parts
+	
+	rrc     r_tmp	; restore sign bits
+
+	bit     #4, r_tmp
+	jz      .L__divdi3end
+	inv     r_arg1hh
+	inv     r_arg1hl
+	inv     r_arg1lh
+	inv     r_arg1ll
+	inc	r_arg1ll
+	adc     r_arg1lh
+	adc     r_arg1hl
+	adc     r_arg1hh
+	
+.L__divdi3end:
+	add	#4, r1
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+#if defined (L_moddi3)
+	.global	__moddi3
+	.func	__moddi3
+__moddi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	
+	mov	18+2(r1), r_arg2lh
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+	
+	sub	#4, r1
+	
+	clr	r_tmp
+	bit     #0x8000, r_arg1hh
+	jnc     .L__moddi3rempos
+	inv	r_arg1hh
+	inv     r_arg1hl
+	inv     r_arg1lh
+	inv     r_arg1ll
+	inc	r_arg1ll
+	adc     r_arg1lh
+	adc     r_arg1hl
+	adc     r_arg1hh
+	bis     #4, r_tmp
+	
+.L__moddi3rempos:
+	bit     #0x8000, r_arg2hh
+	jnc     .L__moddi3arg2pos	
+	inv	r_arg2hh
+	inv     r_arg2hl
+	inv     r_arg2lh
+	inv     r_arg2ll
+	inc	r_arg2ll
+	adc     r_arg2lh
+	adc     r_arg2hl
+	adc     r_arg2hh
+
+.L__moddi3arg2pos:
+	call	#__udivmoddi3_parts
+	
+	rrc     r_tmp
+
+	bit     #4, r_tmp
+	jz      .L__moddi3rem
+	
+	inv	r_remhh
+	inv     r_remhl
+	inv     r_remlh
+	inv     r_remll
+	inc	r_remll
+	adc     r_remlh
+	adc     r_remhl
+	adc     r_remhh
+
+.L__moddi3rem:
+	mov	r_remhh, r15
+	mov	r_remhl, r14
+	mov	r_remlh, r13
+	mov	r_remll, r12
+
+	add	#4, r1
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+/**************************************************************
+ * Multiplication 64 = 64 x 64
+ **************************************************************/
+#if defined(L_muldi3)
+
+#define r_reshh  r15  	/* res = arg1 * arg2 */
+#define r_reshl  r14
+#define r_reslh	 r13
+#define r_resll	 r12
+
+#define r_arg1hh r11	/* arg1 */
+#define r_arg1hl r10
+#define r_arg1lh r9
+#define r_arg1ll r8
+
+#define r_arg2hh r7	/* arg2 */
+#define r_arg2hl r6
+#define r_arg2lh r5
+#define r_arg2ll r4
+
+	.global	__muldi3
+	.func	__muldi3
+__muldi3:
+	clr	r_reshh
+	clr	r_reshl
+	clr	r_reslh
+	clr	r_resll
+	
+#if !defined(MSP430_HAS_HWMUL)
+.L_muldi3_loop:
+	clrc
+	rrc	r_arg2hh		; arg2 >>= 1 (shift LSB into carry)
+	rrc	r_arg2hl
+	rrc	r_arg2lh
+	rrc	r_arg2ll
+	
+	jnc	1f			; check if bit is set
+					; yes, it is.
+	add	r_arg1ll, r_resll	; res += arg1
+	addc	r_arg1lh, r_reslh
+	addc	r_arg1hl, r_reshl
+	addc	r_arg1hh, r_reshh
+	
+1:	rla	r_arg1ll		; arg1 <<= 1
+	rlc	r_arg1lh
+	rlc	r_arg1hl
+	rlc	r_arg1hh
+	
+	tst	r_arg2ll		; arg2 !=0 ?  loop again , exit otherwise.
+	jne	.L_muldi3_loop
+	tst	r_arg2lh
+	jne	.L_muldi3_loop
+	tst	r_arg2hl
+	jne	.L_muldi3_loop
+	tst	r_arg2hh
+	jne	.L_muldi3_loop
+#else
+        mov     r_arg1ll,&__MPY
+        mov     r_arg2ll,&__OP2           ;;                      LL1xLL2
+        mov     &__RESLO,r_resll
+        mov     &__RESHI,&__RESLO
+        mov     &__SUMEXT,&__RESHI
+
+        mov     r_arg1ll,&__MAC
+        mov     r_arg2lh,&__OP2           ;;                  LL1xLH2
+        mov     r_arg1lh,&__MAC
+        mov     r_arg2ll,&__OP2           ;;                  LH1xLL2
+        mov     &__RESLO,r_reslh
+        mov     &__RESHI,&__RESLO
+        mov     &__SUMEXT,&__RESHI
+
+        mov     r_arg2lh,&__OP2           ;;              LH1xLH2
+        mov     r_arg1ll,&__MAC
+        mov     r_arg2hl,&__OP2           ;;              LL1xHL2
+        mov     r_arg1hl,&__MAC
+        mov     r_arg2ll,&__OP2           ;;              HL1xLL2
+        mov     &__RESLO,r_reshl
+        mov     &__RESHI,&__RESLO
+
+        mov     r_arg2lh,&__OP2           ;;          HL1xLH2
+        mov     r_arg1ll,&__MAC
+        mov     r_arg2hh,&__OP2           ;;          LL1xHH2
+        mov     r_arg1lh,&__MAC
+        mov     r_arg2hl,&__OP2           ;;          LH1xHL2
+        mov     r_arg1hh,&__MAC
+        mov     r_arg2ll,&__OP2           ;;          HH1xLL2
+        mov     &__RESLO,r_reshh
+	
+#endif
+	; move result to proper location
+	mov	r_resll, r12
+	mov	r_reslh, r13
+	mov	r_reshl, r14
+	mov	r_reshh, r15
+
+	ret
+.endfunc
+#endif
+
+#if defined (L_mulsidi3)
+	.global	__mulsidi3
+	.func	__mulsidi3
+__mulsidi3:
+	clr	r6
+	tst	r5
+	jge	1f
+	mov	#-1, r6
+1:	mov	r6, r7
+	clr	r10
+	tst	r9
+	jge	2f
+	mov	#-1, r10
+2:	mov	r10, r11
+	br	#__muldi3
+	.endfunc
+#endif /* defined (L_mulhisi3) */
+
+#if defined(L_umulsidi3)
+	.global	__umulsidi3
+	.func	__umulsidi3
+__umulsidi3:
+	clr	r6
+	clr	r7
+	clr	r10
+	clr	r11
+	br	#__muldi3
+	.endfunc
+#endif /* defined (L_umulsidi3) */
+	
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430-builtins.c gcc-4.5.3/gcc/config/msp430/msp430-builtins.c
new file mode 100644
index 0000000..e26afc4
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430-builtins.c
@@ -0,0 +1,261 @@
+/* This work is partially financed by the European Commission under the
+* Framework 6 Information Society Technologies Project
+* "Wirelessly Accessible Sensor Populations (WASP)".
+*/
+
+/*
+GCC 4.x port by Ivan Shcherbakov <mspgcc@sysprogs.org>
+*/
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "tree.h"
+#include "output.h"
+#include "expr.h"
+#include "toplev.h"
+#include "obstack.h"
+#include "function.h"
+#include "recog.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "insn-codes.h"
+#include "ggc.h"
+#include "langhooks.h"
+
+/* The following functions are defined in this file and used by msp430.c */
+void msp430_init_builtins (void);
+rtx msp430_expand_builtin (tree, rtx, rtx, enum machine_mode, int);
+
+enum msp430_builtins
+{
+  MSP430_BUILTIN_NOP,
+  MSP430_BUILTIN_DINT,
+  MSP430_BUILTIN_EINT,
+  MSP430_BUILTIN_READ_STATUS_REGISTER,
+  MSP430_BUILTIN_WRITE_STATUS_REGISTER,
+  MSP430_BUILTIN_BIC_STATUS_REGISTER,
+  MSP430_BUILTIN_BIS_STATUS_REGISTER,
+  MSP430_BUILTIN_BIC_SR_IRQ,
+  MSP430_BUILTIN_BIS_SR_IRQ,
+  MSP430_BUILTIN_READ_STACK_POINTER,
+  MSP430_BUILTIN_WRITE_STACK_POINTER,
+  MSP430_BUILTIN_DELAY_CYCLES,
+  MSP430_BUILTIN_last_enum
+};
+
+void
+msp430_init_builtins (void)
+{
+  add_builtin_function ("__nop",
+			build_function_type_list (void_type_node, NULL_TREE),
+			MSP430_BUILTIN_NOP, BUILT_IN_MD, NULL, NULL_TREE);
+  add_builtin_function ("__dint",
+			build_function_type_list (void_type_node, NULL_TREE),
+			MSP430_BUILTIN_DINT, BUILT_IN_MD, NULL, NULL_TREE);
+  add_builtin_function ("__eint",
+			build_function_type_list (void_type_node, NULL_TREE),
+			MSP430_BUILTIN_EINT, BUILT_IN_MD, NULL, NULL_TREE);
+  add_builtin_function ("__read_status_register",
+			build_function_type_list (unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_READ_STATUS_REGISTER, BUILT_IN_MD,
+			NULL, NULL_TREE);
+  add_builtin_function ("__write_status_register",
+			build_function_type_list (void_type_node,
+						  unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_WRITE_STATUS_REGISTER, BUILT_IN_MD,
+			NULL, NULL_TREE);
+  add_builtin_function ("__bic_status_register",
+			build_function_type_list (void_type_node,
+						  unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_BIC_STATUS_REGISTER, BUILT_IN_MD, NULL,
+			NULL_TREE);
+  add_builtin_function ("__bis_status_register",
+			build_function_type_list (void_type_node,
+						  unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_BIS_STATUS_REGISTER, BUILT_IN_MD, NULL,
+			NULL_TREE);
+  add_builtin_function ("__bic_status_register_on_exit",
+			build_function_type_list (void_type_node,
+						  unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_BIC_SR_IRQ, BUILT_IN_MD, NULL,
+			NULL_TREE);
+  add_builtin_function ("__bis_status_register_on_exit",
+			build_function_type_list (void_type_node,
+						  unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_BIS_SR_IRQ, BUILT_IN_MD, NULL,
+			NULL_TREE);
+  add_builtin_function ("__read_stack_pointer",
+			build_function_type_list (ptr_type_node, NULL_TREE),
+			MSP430_BUILTIN_READ_STACK_POINTER, BUILT_IN_MD, NULL,
+			NULL_TREE);
+  add_builtin_function ("__write_stack_pointer",
+			build_function_type_list (void_type_node,
+						  ptr_type_node, NULL_TREE),
+			MSP430_BUILTIN_WRITE_STACK_POINTER, BUILT_IN_MD, NULL,
+			NULL_TREE);
+  add_builtin_function ("__delay_cycles",
+			build_function_type_list (void_type_node,
+						  long_unsigned_type_node,
+						  NULL_TREE),
+			MSP430_BUILTIN_DELAY_CYCLES, BUILT_IN_MD, NULL,
+			NULL_TREE);
+}
+
+rtx
+msp430_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,
+		       rtx subtarget ATTRIBUTE_UNUSED,
+		       enum machine_mode mode ATTRIBUTE_UNUSED,
+		       int ignore ATTRIBUTE_UNUSED)
+{
+  rtx arg = 0;
+  rtx retval = 0;
+  rtx deref_stack_sr = 0;
+  rtx insn = 0;
+  bool need_insn = true;
+  tree fndecl;
+  enum msp430_builtins builtin_code;
+  struct machine_function *mfp = cfun->machine;
+
+  fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);
+  builtin_code = (enum msp430_builtins) DECL_FUNCTION_CODE (fndecl);
+
+  if (builtin_code == MSP430_BUILTIN_BIC_SR_IRQ
+      || builtin_code == MSP430_BUILTIN_BIS_SR_IRQ)
+    {
+      if (mfp->interrupt == NULL_TREE)
+	error
+	  ("__bi%c_status_register_on_exit invalid outside of function with interrupt attribute",
+	   (builtin_code == MSP430_BUILTIN_BIC_SR_IRQ) ? 'c' : 's');
+      /* If we used hard_frame_pointer_rtx here, which would be right,
+         we'd end up setting frame_pointer_required even if it isn't.
+         So use arg_pointer_rtx offset by the two words pushed by the
+         interrupt. */
+      deref_stack_sr =
+	gen_rtx_MEM (Pmode,
+		     plus_constant (arg_pointer_rtx, -2 * UNITS_PER_WORD));
+    }
+
+  switch (builtin_code)
+    {
+    default:
+      break;
+    case MSP430_BUILTIN_NOP:
+      insn = gen_nop ();
+      break;
+    case MSP430_BUILTIN_DINT:
+      emit_insn (gen_dint ());
+      insn = gen_nop ();
+      break;
+    case MSP430_BUILTIN_EINT:
+      insn = gen_eint ();
+      break;
+    case MSP430_BUILTIN_READ_STATUS_REGISTER:
+      retval = gen_reg_rtx (HImode);
+      insn = gen_read_status_register (retval);
+      break;
+    case MSP430_BUILTIN_WRITE_STATUS_REGISTER:
+      arg = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, VOIDmode, 0);
+      insn = gen_write_status_register (arg);
+      break;
+    case MSP430_BUILTIN_BIC_STATUS_REGISTER:
+      arg = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, VOIDmode, 0);
+      insn = gen_bic_status_register (arg);
+      break;
+    case MSP430_BUILTIN_BIS_STATUS_REGISTER:
+      arg = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, VOIDmode, 0);
+      insn = gen_bis_status_register (arg);
+      break;
+    case MSP430_BUILTIN_BIC_SR_IRQ:
+      arg = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, VOIDmode, 0);
+      insn = gen_bic_status_register_on_exit (deref_stack_sr, arg);
+      break;
+    case MSP430_BUILTIN_BIS_SR_IRQ:
+      arg = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, VOIDmode, 0);
+      insn = gen_bis_status_register_on_exit (deref_stack_sr, arg);
+      break;
+    case MSP430_BUILTIN_READ_STACK_POINTER:
+      retval = gen_reg_rtx (HImode);
+      insn = gen_read_stack_pointer (retval);
+      break;
+    case MSP430_BUILTIN_WRITE_STACK_POINTER:
+      arg = expand_expr (CALL_EXPR_ARG (exp, 0), NULL_RTX, VOIDmode, 0);
+      insn = gen_write_stack_pointer (arg);
+      break;
+    case MSP430_BUILTIN_DELAY_CYCLES:
+      {
+	tree cycles_arg = CALL_EXPR_ARG (exp, 0);
+	const int cycles_per_jump = 2;
+	const int cycles_per_iter = 1 + cycles_per_jump;
+	HOST_WIDE_INT cycles = 0;
+	HOST_WIDE_INT iters;
+	int cycles_in_prefix = 2;
+	rtx loop_register;
+
+	if (!cst_and_fits_in_hwi (cycles_arg)
+	    || (0 > ((cycles = int_cst_value (cycles_arg)))))
+	  {
+	    error
+	      ("__delay_cycles argument must be non-negative integer constant");
+	    need_insn = false;
+	    break;
+	  }
+
+	iters = (cycles - cycles_in_prefix) / cycles_per_iter;
+	if ((0 >= iters) || (1 == iters) || (2 == iters) || (4 == iters)
+	    || (8 == iters))
+	  {
+	    int alt_iters;
+	    cycles_in_prefix = 1;
+	    alt_iters = (cycles - cycles_in_prefix) / cycles_per_iter;
+	    if ((1 == alt_iters) || (2 == alt_iters) || (4 == alt_iters)
+		|| (8 == alt_iters))
+	      iters = alt_iters;
+	  }
+	if (0 >= iters)
+	  need_insn = false;
+	else if (iters > 65535)
+	  {
+	    error ("__delay_cycles argument too large");
+	    need_insn = false;
+	    break;
+	  }
+	else
+	  {
+	    cycles -= cycles_in_prefix;
+	    loop_register = gen_reg_rtx (HImode);
+	    insn =
+	      gen_delay_cycles (loop_register, gen_int_mode (iters, HImode));
+	    cycles -= iters * cycles_per_iter;
+	  }
+	while (cycles--)
+	  emit_insn (gen_nop ());
+	break;
+      }
+    }
+
+  if (insn)
+    emit_insn (insn);
+  else if (need_insn)
+    error ("Unhandled built-in function `%s'",
+	   IDENTIFIER_POINTER (DECL_NAME (fndecl)));
+
+  return retval;
+}
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430-cbranch.c gcc-4.5.3/gcc/config/msp430/msp430-cbranch.c
new file mode 100644
index 0000000..f2bcbb8
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430-cbranch.c
@@ -0,0 +1,723 @@
+/* This work is partially financed by the European Commission under the
+* Framework 6 Information Society Technologies Project
+* "Wirelessly Accessible Sensor Populations (WASP)".
+*/
+
+/*
+GCC 4.x port by Ivan Shcherbakov <mspgcc@sysprogs.org>
+*/
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "tree.h"
+#include "output.h"
+#include "expr.h"
+#include "toplev.h"
+#include "obstack.h"
+#include "function.h"
+#include "recog.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "insn-codes.h"
+#include "ggc.h"
+#include "langhooks.h"
+
+static const char *msp430_emit_beq (rtx operands[], int len);
+static const char *msp430_emit_bne (rtx operands[], int len);
+static const char *msp430_emit_bgt (rtx operands[], int len);
+static const char *msp430_emit_bgtu (rtx operands[], int len);
+static const char *msp430_emit_blt (rtx operands[], int len);
+static const char *msp430_emit_bltnoovfl (rtx operands[], int len);
+static const char *msp430_emit_bltu (rtx operands[], int len);
+static const char *msp430_emit_bge (rtx operands[], int len);
+static const char *msp430_emit_bgeu (rtx operands[], int len);
+static const char *msp430_emit_ble (rtx operands[], int len);
+static const char *msp430_emit_bleu (rtx operands[], int len);
+
+static void
+emit_himode_cbranch (enum rtx_code code, rtx op0, rtx op1, rtx loc)
+{
+  rtx operands[4];
+
+  operands[0] = gen_rtx_fmt_ee (code, HImode, op0, op1);
+  operands[1] = op0;
+  operands[2] = op1;
+  operands[3] = loc;
+  msp430_emit_cbranch (operands);
+}
+
+void
+msp430_emit_cbranch (rtx operands[])
+{
+  enum rtx_code code = GET_CODE (operands[0]);
+  rtx op0 = operands[1];
+  rtx op1 = operands[2];
+  rtx loc = operands[3];
+  rtx cmp, loc_ref, branch;
+  enum machine_mode mode;
+
+  gcc_assert (rtx_equal_p (XEXP (operands[0], 0), op0));
+  gcc_assert (rtx_equal_p (XEXP (operands[0], 1), op1));
+
+  if (CONSTANT_P (op0) && !CONSTANT_P (op1))
+    {
+      rtx tmp = op0;
+      op0 = op1;
+      op1 = tmp;
+      code = swap_condition (code);
+    }
+  if (!CONSTANT_P (op1)
+      && (GT == code || GTU == code || LE == code || LEU == code))
+    {
+      rtx tmp = op0;
+      op0 = op1;
+      op1 = tmp;
+      code = swap_condition (code);
+    }
+
+  mode = GET_MODE (op0);
+
+#if 0
+  fprintf (stderr, "emit_cbranch %s %s ", mode_name[mode], rtx_name[code]);
+  debug_rtx (op0);
+  debug_rtx (op1);
+  debug_rtx (loc);
+#endif
+
+  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT);
+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)
+    {
+      rtx insn = get_last_insn ();
+      enum rtx_code rcode = reverse_condition (code);
+      rtx fail = gen_label_rtx ();
+      rtx parts0[4];
+      rtx parts1[4];
+      int words;
+      int w;
+
+      words = msp430_extract_multiword_operand (mode, op0, parts0);
+#if 0
+      if ((op1 == const0_rtx) && (CODE == EQ || CODE == NE))
+	{
+	  rtx tmp = gen_reg_rtx (HImode);
+	  emit_move_insn (tmp, parts0[0]);
+	  for (w = 1; w < words; ++w)
+	    emit_insn (gen_iorhi3 (tmp, parts0[w]));
+	  cmp = gen_rtx_fmt_ee (code, HImode, tmp, const0_rtx);
+	  msp430_emit_cbranch (cmp, tmp, const0_rtx, loc);
+	  return;
+	}
+#endif
+      msp430_extract_multiword_operand (mode, op1, parts1);
+      switch (code)
+	{
+	case EQ:
+	  for (w = 0; w < words - 1; ++w)
+	    emit_himode_cbranch (rcode, parts0[w], parts1[w], fail);
+	  emit_himode_cbranch (code, parts0[w], parts1[w], loc);
+	  emit_label (fail);
+	  break;
+	case NE:
+	  for (w = 0; w < words; ++w)
+	    emit_himode_cbranch (code, parts0[w], parts1[w], loc);
+	  break;
+	case LT:
+	case LTU:
+	case GT:
+	case GTU:
+	  for (w = words - 1; w > 0; --w)
+	    {
+	      emit_himode_cbranch (code, parts0[w], parts1[w], loc);
+	      emit_himode_cbranch (NE, parts0[w], parts1[w], fail);
+	      code = unsigned_condition (code);
+	    }
+	  emit_himode_cbranch (code, parts0[0], parts1[0], loc);
+	  emit_label (fail);
+	  break;
+	case LE:
+	case LEU:
+	case GE:
+	case GEU:
+	  for (w = words - 1; w > 0; --w)
+	    {
+	      emit_himode_cbranch (rcode, parts0[w], parts1[w], fail);
+	      emit_himode_cbranch (rcode, parts1[w], parts0[w], loc);
+	      rcode = unsigned_condition (rcode);
+	    }
+	  emit_himode_cbranch (unsigned_condition (code), parts0[0],
+			       parts1[0], loc);
+	  emit_label (fail);
+	  break;
+
+	default:
+	  gcc_unreachable ();
+	}
+#if 0
+      {
+	fprintf (stderr, "Completed expansion:\n");
+	insn = get_last_insn ();
+	while (insn)
+	  {
+	    debug_rtx (insn);
+	    insn = PREV_INSN (insn);
+	  }
+      }
+#endif
+      return;
+    }
+  cmp = gen_rtx_fmt_ee (code, mode, op0, op1);
+  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);
+  branch = gen_rtx_SET (VOIDmode, pc_rtx,
+			gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,
+					      loc_ref, pc_rtx));
+  emit_jump_insn (branch);
+}
+
+/* r14:HI and r14:SI are not rtx_equal_p, because the latter
+ * represents r14:HI and r15:HI in one.  They are equal in the sense
+ * that writing to the former destroys the latter, invalidating
+ * condition codes.  Check for overlap in this case. */
+static int
+rtx_matches_ (const_rtx x, const_rtx y)
+{
+  if (x && y && REG_P (x) && REG_P (y))
+    {
+      int x0 = GET_MODE_SIZE (HImode) * REGNO (x);
+      int x1 = x0 + GET_MODE_SIZE (GET_MODE (x));
+      int y0 = GET_MODE_SIZE (HImode) * REGNO (y);
+      int y1 = y0 + GET_MODE_SIZE (GET_MODE (y));
+      /* Does (x0, x1) overlap (y0, y1)? */
+      if (x1 >= y0 && x0 <= y1)
+	return 1;
+    }
+  return rtx_equal_p (x, y);
+}
+
+/*  x - dst
+y - src */
+static int
+msp430_cc_source (rtx insn, enum rtx_code code ATTRIBUTE_UNUSED, rtx x, rtx y)
+{
+  rtx prev = insn;
+  enum attr_cc cc;
+  rtx set;
+  rtx src, dst;
+  rtx x1 = 0;
+
+  if (GET_CODE (x) == MEM)
+    {
+      x1 = XEXP (x, 0);
+      if (GET_CODE (x1) == PLUS)
+	{
+	  x1 = XEXP (x1, 0);
+	}
+
+      if (!REG_P (x1))
+	x1 = 0;
+    }
+
+  while (0 != (prev = PREV_INSN (prev)))
+    {
+      if (GET_CODE (prev) == CODE_LABEL
+	  || GET_CODE (prev) == BARRIER || GET_CODE (prev) == CALL_INSN)
+	return 0;
+
+      if (GET_CODE (prev) == INSN)
+	{
+	  set = single_set (prev);
+
+	  if (!set)
+	    return 0;
+
+	  cc = get_attr_cc (prev);
+
+	  if (cc == CC_NONE)	/* does not change CC */
+	    {
+	      /*The one spot by Nick C. */
+	      dst = SET_DEST (set);
+	      if ((dst && rtx_matches_ (x, dst)) ||
+		  (x1 && dst && rtx_matches_ (x1, dst)))
+		return 0;
+	      continue;
+	    }
+
+	  if (cc == CC_CLOBBER)	/* clobber */
+	    return 0;
+
+	  if (cc == CC_OPER)	/* post-incremental stuff */
+	    {
+	      src = SET_SRC (set);
+	      if (GET_CODE (set) == IOR)	/* does not change CC */
+		{
+		  dst = SET_DEST (set);
+		  if (dst && rtx_matches_ (x, dst))
+		    return 0;
+		  continue;
+		}
+	    }
+
+	  /* all other attributes are bit messy.
+	     So, we'll record destination and check if 
+	     this matches 'x' and compare is against zero */
+	  dst = SET_DEST (set);
+	  if (rtx_equal_p (x, dst) && rtx_equal_p (y, const0_rtx))
+	    return 1;
+	  else
+	    return 0;
+	}
+      else if (GET_CODE (prev) == JUMP_INSN)
+	{
+	  /* if 2 consequent jump insns were issued, this means
+	     that operands (more likely src) are different.
+	     however, some jumps optimization can equalize these operands
+	     and everything will be bad. Therefore, assume that
+	     any jump insn clobbers condition codes. */
+	  return 0;
+	}
+    }
+  return 0;
+}
+
+const char *
+msp430_cbranch (rtx insn, rtx operands[])
+{
+  rtx ops[3];
+  enum rtx_code code;
+  rtx locs[3];
+  int dummy = 0;
+  enum machine_mode mode;
+  int quater = 0;
+  rtx loc = operands[0];
+  int distance = msp430_jump_dist (loc, insn);
+  int predist = 0;
+  int nooverflow = 0;
+
+  locs[0] = operands[0];
+  ops[0] = operands[2];
+  ops[1] = operands[3];
+
+  if (ops[1] && ops[0])
+    {
+      mode = GET_MODE (operands[2]);
+      code = GET_CODE (operands[1]);
+      quater = (mode == QImode);
+    }
+  else
+    {
+      mode = HImode;
+      code = GET_CODE (operands[1]);
+    }
+  gcc_assert (mode == QImode || mode == HImode);
+
+  /* here check wiered conditions */
+  if (ops[1] && GET_CODE (ops[1]) == CONST_INT
+      && (code == GT || code == LE || code == GTU || code == LEU))
+    {
+      int x = INTVAL (ops[1]);
+      switch (code)
+	{
+	case GT:
+	  ops[1] = GEN_INT (x + 1);
+	  code = GE;
+	  break;
+	case LE:
+	  ops[1] = GEN_INT (x + 1);
+	  code = LT;
+	  break;
+	case GTU:
+	  ops[1] = GEN_INT (x + 1);
+	  code = GEU;
+	  break;
+	case LEU:
+	  ops[1] = GEN_INT (x + 1);
+	  code = LTU;
+	  break;
+	default:
+	  break;
+	}
+    }
+  else if (ops[1] && CONSTANT_P (ops[1]) && GET_MODE (ops[1]) == HImode
+	   && (code == GT || code == LE || code == GTU || code == LEU))
+    {
+      /* Handle pointers here */
+      ops[1] =
+	gen_rtx_CONST (HImode, gen_rtx_PLUS (HImode, ops[1], GEN_INT (1)));
+
+      switch (code)
+	{
+	case GT:
+	  code = GE;
+	  break;
+	case LE:
+	  code = LT;
+	  break;
+	case GTU:
+	  code = GEU;
+	  break;
+	case LEU:
+	  code = LTU;
+	  break;
+	default:
+	  break;
+	}
+    }
+
+  if (ops[0] != cc0_rtx && ops[1] && ops[0])
+    {
+      if (code == NE || code == EQ)
+	{
+	  /* check if op0 is zero shited - win 1 byte */
+	  if (msp430_indirect_register_operand (ops[0])
+	      && !CONSTANT_P (ops[1]))
+	    {
+	      rtx x = ops[0];
+	      ops[0] = ops[1];
+	      ops[1] = x;
+	    }
+	}
+
+      /* check if compares were not issued */
+      if (msp430_cc_source (insn, code, ops[0], ops[1]))
+	{
+	  /* check if overflow can be usefull here. */
+	  if (ops[1] == const0_rtx
+	      || (GET_CODE (ops[1]) == CONST_INT && INTVAL (ops[1]) == 0))
+	    {
+	      if (code == LT || code == GE)
+		nooverflow = 1;
+	    }
+	}
+      else
+	{
+	  /* check if previous insns did not set CC correctly */
+	  if (quater)
+	    output_asm_insn ("cmp.b\t%1, %0", ops);
+	  else
+	    output_asm_insn ("cmp\t%1, %0", ops);
+	  dummy += 3;
+	  if (REG_P (ops[0]))
+	    dummy--;
+	  if (REG_P (ops[1]))
+	    dummy--;
+	  if (msp430_indirect_register_operand (ops[1]))
+	    dummy--;
+	  if (GET_CODE (ops[1]) == CONST_INT)
+	    {
+	      int x = INTVAL (ops[1]) & 0xffff;
+	      if (x == 0 || x == -1 || x == 1 || x == 2 || x == 4 || x == 8)
+		dummy--;
+	    }
+	}
+
+      /* adjust distance */
+      distance -= dummy;
+    }
+
+  distance -= dummy;
+
+  if (distance > 500 || distance < -500)
+    predist = 3;
+  else
+    predist = 1;
+
+  /* out assembler commands if required */
+  switch (code)
+    {
+    case EQ:
+      msp430_emit_beq (locs, predist + 0);
+      break;
+    case NE:
+      msp430_emit_bne (locs, predist + 0);
+      break;
+    case LT:
+      if (nooverflow)
+	msp430_emit_bltnoovfl (locs, predist + 0);
+      else
+	msp430_emit_blt (locs, predist + 0);
+      break;
+    case GE:
+      if (nooverflow)
+	{
+	  if (mode == QImode)
+	    output_asm_insn ("bit.b\t#0x80, %0", ops);
+	  else
+	    output_asm_insn ("bit\t#0x8000, %0", ops);
+	}
+      msp430_emit_bge (locs, predist + 0);
+      break;
+    case LTU:
+      msp430_emit_bltu (locs, predist + 0);
+      break;
+    case GEU:
+      msp430_emit_bgeu (locs, predist + 0);
+      break;
+      /* hopfully the following will not occure */
+    case LEU:
+      msp430_emit_bleu (locs, predist + 1);
+      break;
+    case GT:
+      msp430_emit_bgt (locs, predist + 1);
+      break;
+    case GTU:
+      msp430_emit_bgtu (locs, predist + 1);
+      break;
+    case LE:
+      msp430_emit_ble (locs, predist + 1);
+      break;
+
+    default:
+      break;
+    }
+
+  return "";
+}
+
+
+static const char *
+msp430_emit_beq (rtx operands[], int len)
+{
+
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jeq\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jne\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bne (rtx operands[], int len)
+{
+
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jne\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jeq\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bgt (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jge\t%0", operands);
+
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+6", operands);
+      output_asm_insn ("jl\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bgtu (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jhs\t%0", operands);
+
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+6", operands);
+      output_asm_insn ("jlo\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_blt (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jl\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jge\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+
+static const char *
+msp430_emit_bltnoovfl (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jn\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jn\t+2", operands);
+      output_asm_insn ("jmp\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bltu (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jlo\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jhs\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bge (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jge\t%l0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jl\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bgeu (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jhs\t%l0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jlo\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_ble (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t%0", operands);
+      output_asm_insn ("jl\t%0", operands);
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jge\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+static const char *
+msp430_emit_bleu (rtx operands[], int len)
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t%0", operands);
+      output_asm_insn ("jlo\t%0", operands);
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jhs\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430-function.c gcc-4.5.3/gcc/config/msp430/msp430-function.c
new file mode 100644
index 0000000..00d9a6d
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430-function.c
@@ -0,0 +1,643 @@
+/* This work is partially financed by the European Commission under the
+* Framework 6 Information Society Technologies Project
+* "Wirelessly Accessible Sensor Populations (WASP)".
+*/
+
+/*
+GCC 4.x port by Ivan Shcherbakov <mspgcc@sysprogs.org>
+*/
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "tree.h"
+#include "output.h"
+#include "expr.h"
+#include "toplev.h"
+#include "obstack.h"
+#include "function.h"
+#include "recog.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "insn-codes.h"
+#include "ggc.h"
+#include "langhooks.h"
+#include "df.h"
+#include "intl.h"
+
+#define STACK_ALIGN_SIZE(_v) (~1 & ((_v)+1))
+
+/* registers used for incoming funct arguments */
+static char arg_register_used[16];
+
+#define FIRST_CUM_REG 16
+static CUMULATIVE_ARGS *cum_incoming = 0;
+
+static int msp430_num_arg_regs (enum machine_mode mode, tree type);
+
+static const char *S_signal = "signal";
+static const char *S_interrupt = "interrupt";
+static const char *S_naked = "naked";
+static const char *S_task = "task";
+static const char *S_wakeup = "wakeup";
+static const char *S_critical = "critical";
+static const char *S_reentrant = "reentrant";
+static const char *S_saveprologue = "saveprologue";
+static const char *S_noint_hwmul = "noint_hwmul";
+static const char *S_hosted = "hosted";
+
+void msp430_function_end_prologue (FILE * file);
+void msp430_function_begin_epilogue (FILE * file);
+
+static inline void
+warn_attribute_requires (tree decl, const char *a1, const char *a2)
+{
+  warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,
+	      _("%qs attribute ignored (requires %qs)"), a1, a2);
+}
+
+static inline void
+warn_attribute_incompatible (tree decl, const char *a1, const char *a2)
+{
+  warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,
+	      _("%qs attribute ignored (incompatible with %qs)"), a1, a2);
+}
+
+void
+msp430_set_current_function (tree decl)
+{
+  struct machine_function *mfp;
+  tree attributes;
+  tree naked;
+  tree interrupt;
+  tree task;
+  tree saveprologue;
+  tree noint_hwmul;
+  tree critical;
+  tree reentrant;
+  tree wakeup;
+  tree signal;
+  tree hosted;
+
+  if ((decl == NULL_TREE) || (!cfun) || (!cfun->machine)
+      || cfun->machine->initialized)
+    return;
+  gcc_assert ((cfun->decl == NULL_TREE) || (cfun->decl == decl));
+  attributes = DECL_ATTRIBUTES (decl);
+
+  mfp = cfun->machine;
+  signal = lookup_attribute (S_signal, attributes);
+  interrupt = lookup_attribute (S_interrupt, attributes);
+  naked = lookup_attribute (S_naked, attributes);
+  task = lookup_attribute (S_task, attributes);
+  wakeup = lookup_attribute (S_wakeup, attributes);
+  critical = lookup_attribute (S_critical, attributes);
+  reentrant = lookup_attribute (S_reentrant, attributes);
+  saveprologue = lookup_attribute (S_saveprologue, attributes);
+  noint_hwmul = lookup_attribute (S_noint_hwmul, attributes);
+  hosted = lookup_attribute (S_hosted, attributes);
+
+  /* Validate attribute parameters */
+  if (interrupt)
+    {
+      tree ia_args = TREE_VALUE (interrupt);
+      int vector_offset = -1;
+
+      /* New style no argument means unvectored ISR.  Old-style used
+       * 255 as the vector offset for this. */
+      if (NULL_TREE != ia_args)
+	{
+	  vector_offset = TREE_INT_CST_LOW (TREE_VALUE (ia_args));
+	  if (255 == vector_offset)
+	    vector_offset = -1;
+	  else if ((0 > vector_offset) || (vector_offset & 1))
+	    {
+	      error_at (DECL_SOURCE_LOCATION (decl),
+			_
+			("interrupt vector offset %d must be even and non-negative"),
+			vector_offset);
+	      vector_offset = 0;
+	    }
+	}
+      mfp->vector_offset = vector_offset;
+    }
+
+
+  /* check attribute compatibility */
+#define REJECT_INCOMPATIBLE(_a1,_a2) do {			\
+    if ((_a1) && (_a2))						\
+      {								\
+	warn_attribute_incompatible (decl, S_##_a1, S_##_a2);	\
+	_a1 = NULL_TREE;					\
+      }								\
+  } while (0)
+#define REJECT_REQUIRES(_a1,_a2) do {				\
+    if ((_a1) && !(_a2))					\
+      {								\
+	warn_attribute_requires (decl, S_##_a1, S_##_a2);	\
+	_a1 = NULL_TREE;					\
+      }								\
+  } while (0)
+
+  /* incompatible hosted && noreturn */
+  if (hosted && TREE_THIS_VOLATILE (decl))
+    {
+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,
+		  _("%qs ignored on noreturn function"), S_hosted);
+      hosted = NULL_TREE;
+    }
+
+  /* interrupt > critical > reentrant */
+  REJECT_INCOMPATIBLE (reentrant, critical);
+  REJECT_INCOMPATIBLE (reentrant, interrupt);
+  REJECT_INCOMPATIBLE (critical, interrupt);
+
+  /* Ignore signal/wakeup on non-interrupt */
+  REJECT_REQUIRES (signal, interrupt);
+  REJECT_REQUIRES (wakeup, interrupt);
+
+  /* task > naked > saveprologue (or its successor) */
+  if (saveprologue)
+    {
+      warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wattributes,
+		  _("saveprologue no longer supported"));
+      saveprologue = NULL_TREE;
+    }
+  REJECT_INCOMPATIBLE (saveprologue, naked);
+  REJECT_INCOMPATIBLE (saveprologue, task);
+  REJECT_INCOMPATIBLE (naked, task);
+
+  /* Legacy ignore reentrant/critical on naked (but we allow them on
+   * task) */
+  REJECT_INCOMPATIBLE (reentrant, naked);
+  REJECT_INCOMPATIBLE (critical, naked);
+
+#undef REJECT_REQUIRES
+#undef REJECT_INCOMPATIBLE
+
+  /* Update declaration based on validated attributes */
+  if (interrupt)
+    {
+      /* Ensure code is not eliminated due to it (apparently) not
+       * being called. */
+      TREE_USED (decl) = 1;
+      DECL_PRESERVE_P (decl) = 1;
+    }
+
+  /* Set frame flags.  NB: allocate_frame will be cleared in the
+   * prologue if the frame size is zero. */
+  mfp->frame_flags |= MSP430_FF_preserve_registers | MSP430_FF_allocate_frame;
+  if (critical)
+    mfp->frame_flags |=
+      MSP430_FF_prologue_push_sr | MSP430_FF_epilogue_pop_sr;
+  if (interrupt)
+    mfp->frame_flags |= MSP430_FF_use_reti;
+  if (signal)
+    mfp->frame_flags |= MSP430_FF_prologue_eint;
+  if (critical || reentrant)
+    mfp->frame_flags |= MSP430_FF_prologue_dint;
+  if (reentrant)
+    mfp->frame_flags |= MSP430_FF_epilogue_eint;
+  if (wakeup)
+    mfp->frame_flags |= MSP430_FF_epilogue_exit_lpm;
+  if (TREE_THIS_VOLATILE (decl))
+    mfp->frame_flags |= MSP430_FF_inhibit_return;
+  if (MAIN_NAME_P (DECL_NAME (decl)) && !hosted)
+    {
+      static const char S_init9[] = ".init9";
+
+      mfp->frame_flags |= MSP430_FF_treat_as_main;
+      if (DECL_SECTION_NAME (decl) == NULL_TREE)
+	DECL_SECTION_NAME (decl) = build_string (sizeof (S_init9), S_init9);
+    }
+  if (naked || task || (MSP430_FF_treat_as_main & mfp->frame_flags))
+    {
+      mfp->frame_flags &= ~MSP430_FF_preserve_registers;
+      if (naked)
+	mfp->frame_flags &= ~MSP430_FF_allocate_frame;
+      mfp->frame_flags |= MSP430_FF_inhibit_return;
+    }
+  if (hosted)
+    mfp->frame_flags &= ~MSP430_FF_inhibit_return;
+
+  mfp->signal = signal;
+  mfp->interrupt = interrupt;
+  mfp->naked = naked;
+  mfp->task = task;
+  mfp->wakeup = wakeup;
+  mfp->critical = critical;
+  mfp->reentrant = reentrant;
+  mfp->saveprologue = saveprologue;
+  mfp->noint_hwmul = noint_hwmul;
+  mfp->initialized = true;
+}
+
+int
+msp430_epilogue_uses (int regno ATTRIBUTE_UNUSED)
+{
+  if (reload_completed
+      && cfun->machine && (cfun->machine->interrupt || cfun->machine->signal))
+    return 1;
+  return 0;
+}
+
+static rtx
+return_addr_pointer (void)
+{
+  int adjustment = 0;
+
+  if (cfun->machine->interrupt)
+    adjustment += UNITS_PER_WORD;
+  cfun->machine->frame_pointer_required = true;
+  return plus_constant (hard_frame_pointer_rtx, adjustment);
+}
+
+rtx
+msp430_return_addr_rtx (int count, rtx frameaddr ATTRIBUTE_UNUSED)
+{
+  if (0 == count)
+    return gen_rtx_MEM (Pmode, return_addr_pointer ());
+  return NULL_RTX;
+}
+
+/* Determine which registers need to be saved on the frame so they're
+ * restored for the caller.  Returns the number of such registers;
+ * optionally sets a mask identifying the registers.
+ *
+ * A register must be preserved for the caller if it is not a
+ * call-used register or if this is an interrupt routine.  The current
+ * function must perform such preservation if that register is live in
+ * this function.
+ *
+ * Non-leaf interrupt routines must save registers that they are
+ * allowed to use but don't. */
+static int
+compute_savable_registers (unsigned int *maskp)
+{
+  int mask;
+  int count = 0;
+  int reg;
+  bool is_isr = cfun->machine->interrupt != NULL_TREE;
+
+  mask = 0;
+  for (reg = 4; reg < 16; ++reg)
+    if ((df_regs_ever_live_p (reg) && (!call_used_regs[reg] || is_isr))
+	|| (is_isr && !current_function_is_leaf && call_used_regs[reg]))
+      {
+	mask |= (1 << reg);
+	++count;
+      }
+  if (maskp)
+    *maskp = mask;
+  return count;
+}
+
+/* Determine whether a particular register was saved in the frame */
+#define is_savable_register(REGNO) (cfun->machine->saved_regs_mask & (1 << REGNO))
+
+/* Generate and return an instruction that adjusts the register by a
+ * constant value. */
+static rtx
+gen_adjust_register (rtx reg_rtx, int offset)
+{
+  gcc_assert (0 != offset);
+  if (MSP430_CG_INT_P (-offset) && !MSP430_CG_INT_P (offset))
+    return gen_subhi3 (reg_rtx, reg_rtx, gen_int_mode (-offset, HImode));
+  return gen_addhi3 (reg_rtx, reg_rtx, gen_int_mode (offset, HImode));
+}
+
+void
+expand_prologue (void)
+{
+  int i;
+  struct machine_function *mfp = cfun->machine;
+  rtx insn;			/* Last generated instruction */
+  rtx need_nop_insn = NULL_RTX;
+
+  mfp->saved_regs_count = compute_savable_registers (&mfp->saved_regs_mask);
+  if (0 == mfp->saved_regs_count)
+    mfp->frame_flags &= ~MSP430_FF_preserve_registers;
+  mfp->frame_size = STACK_ALIGN_SIZE (get_frame_size ());
+
+  /* Warn if we need a frame but have been told not to provide one. */
+  if ((0 < mfp->frame_size) && !(mfp->frame_flags & MSP430_FF_allocate_frame))
+    {
+      warning_at (DECL_SOURCE_LOCATION (cfun->decl), OPT_Wattributes,
+		  _
+		  ("function requires %u bytes for stack storage but frame allocation inhibited by %qs"),
+		  mfp->frame_size, S_naked);
+      mfp->frame_size = 0;
+    }
+  if (0 == mfp->frame_size)
+    mfp->frame_flags &= ~MSP430_FF_allocate_frame;
+
+  if (MSP430_FF_prologue_push_sr & mfp->frame_flags)
+    {
+      insn =
+	emit_insn (gen_pushhi1
+		   (gen_rtx_REG (HImode, STATUS_REGISTER_REGNUM)));
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+
+  if (MSP430_FF_prologue_dint & mfp->frame_flags)
+    {
+      need_nop_insn = insn = emit_insn (gen_dint ());
+    }
+
+  if (MSP430_FF_preserve_registers & mfp->frame_flags)
+    {
+      for (i = 15; i >= 4; i--)
+	if (is_savable_register (i))
+	  {
+	    insn = emit_insn (gen_pushhi1 (gen_rtx_REG (HImode, i)));
+	    RTX_FRAME_RELATED_P (insn) = 1;
+	  }
+    }
+
+  if (frame_pointer_needed)
+    {
+      int fp_hfp_offset;
+
+      fp_hfp_offset =
+	msp430_initial_elimination_offset (FRAME_POINTER_REGNUM,
+					   HARD_FRAME_POINTER_REGNUM);
+      fp_hfp_offset += mfp->frame_size;
+
+      insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);
+      RTX_FRAME_RELATED_P (insn) = 1;
+      if (0 != fp_hfp_offset)
+	{
+	  insn =
+	    emit_insn (gen_adjust_register
+		       (hard_frame_pointer_rtx, -fp_hfp_offset));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+    }
+
+  if (MSP430_FF_allocate_frame & mfp->frame_flags)
+    {
+      insn =
+	emit_insn (gen_adjust_register (stack_pointer_rtx, -mfp->frame_size));
+      RTX_FRAME_RELATED_P (insn) = 1;
+    }
+
+  if (MSP430_FF_prologue_eint & mfp->frame_flags)
+    {
+      insn = emit_insn (gen_eint ());
+    }
+
+  /* Ensure dint is followed by something before we hit the
+   * uninterruptible code */
+  if (need_nop_insn != NULL_RTX && need_nop_insn == get_last_insn ())
+    {
+      insn = emit_insn (gen_nop ());
+    }
+
+  /* If the epilogue will reduce to a single instruction, we can
+   * enable the return pattern now so gen_return at the end of basic
+   * blocks avoids a jump. */
+  if (!(mfp->frame_flags & (MSP430_FF_inhibit_return
+			    | MSP430_FF_epilogue_dint
+			    | MSP430_FF_allocate_frame
+			    | MSP430_FF_preserve_registers
+			    | MSP430_FF_epilogue_pop_sr
+			    | MSP430_FF_epilogue_exit_lpm
+			    | MSP430_FF_epilogue_eint)))
+    mfp->frame_flags |= MSP430_FF_ready_for_return;
+}
+
+
+/* Output function epilogue */
+
+void
+expand_epilogue (void)
+{
+  int i;
+  struct machine_function *mfp = cfun->machine;
+  rtx insn;
+  rtx need_nop_insn = NULL_RTX;
+
+  /* Obey noreturn.  Can't just exit */
+  if (TREE_THIS_VOLATILE (current_function_decl))
+    goto epilogue_done;
+
+  if (MSP430_FF_epilogue_dint & mfp->frame_flags)
+    need_nop_insn = insn = emit_insn (gen_dint ());
+
+  if (MSP430_FF_allocate_frame & mfp->frame_flags)
+    insn =
+      emit_insn (gen_adjust_register (stack_pointer_rtx, mfp->frame_size));
+
+  if (MSP430_FF_preserve_registers & mfp->frame_flags)
+    {
+      for (i = 4; i < 16; i++)
+	if (is_savable_register (i))
+	  insn = emit_insn (gen_pophi1 (gen_rtx_REG (HImode, i)));
+    }
+
+  if (MSP430_FF_epilogue_pop_sr & mfp->frame_flags)
+    insn =
+      emit_insn (gen_pophi1 (gen_rtx_REG (HImode, STATUS_REGISTER_REGNUM)));
+
+  if (MSP430_FF_epilogue_exit_lpm & mfp->frame_flags)
+    insn =
+      emit_insn (gen_bic_status_register_on_exit
+		 (gen_rtx_MEM (Pmode, stack_pointer_rtx),
+		  gen_int_mode (0xf0, HImode)));
+
+  if (MSP430_FF_epilogue_eint & mfp->frame_flags)
+    insn = emit_insn (gen_eint ());
+
+epilogue_done:
+
+  /* NB: if naked, this does not emit any code, but we have to invoke
+   * gen_return() at least once or sanity checks in the shared code
+   * fail. */
+  mfp->frame_flags |= MSP430_FF_ready_for_return;
+  emit_jump_insn (gen_return ());
+
+  /* Ensure dint is followed by something before we hit the
+   * uninterruptible code.  (Test will only pass if
+   * inhibit_return.)  */
+  if (need_nop_insn != NULL_RTX && need_nop_insn == get_last_insn ())
+    insn = emit_insn (gen_nop ());
+}
+
+void
+msp430_output_addr_vec_elt (FILE * stream, int value)
+{
+  fprintf (stream, "\t.word	.L%d\n", value);
+}
+
+/* Controls whether a function argument is passed
+in a register, and which register. */
+rtx
+msp430_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode, tree type,
+		     int named ATTRIBUTE_UNUSED)
+{
+  int regs = msp430_num_arg_regs (mode, type);
+
+  if (cum->nregs && regs <= cum->nregs)
+    {
+      int regnum = cum->regno - regs;
+
+      if (cum == cum_incoming)
+	{
+	  arg_register_used[regnum] = 1;
+	  if (regs >= 2)
+	    arg_register_used[regnum + 1] = 1;
+	  if (regs >= 3)
+	    arg_register_used[regnum + 2] = 1;
+	  if (regs >= 4)
+	    arg_register_used[regnum + 3] = 1;
+	}
+
+      return gen_rtx_REG (mode, regnum);
+    }
+  return NULL_RTX;
+}
+
+/* the same in scope of the cum.args., buf usefull for a
+function call */
+void
+msp430_init_cumulative_incoming_args (CUMULATIVE_ARGS * cum, tree fntype,
+				      rtx libname)
+{
+  int i;
+  cum->nregs = 4;
+  cum->regno = FIRST_CUM_REG;
+  if (!libname)
+    {
+      int stdarg = (TYPE_ARG_TYPES (fntype) != 0
+		    && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+			!= void_type_node));
+      if (stdarg)
+	cum->nregs = 0;
+    }
+
+  for (i = 0; i < 16; i++)
+    arg_register_used[i] = 0;
+
+  cum_incoming = cum;
+}
+
+/* Initializing the variable cum for the state at the beginning
+of the argument list.  */
+void
+msp430_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype, rtx libname,
+			     tree fndecl ATTRIBUTE_UNUSED)
+{
+  cum->nregs = 4;
+  cum->regno = FIRST_CUM_REG;
+  if (!libname)
+    {
+      int stdarg = (TYPE_ARG_TYPES (fntype) != 0
+		    && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+			!= void_type_node));
+      if (stdarg)
+	cum->nregs = 0;
+    }
+}
+
+
+/* Update the summarizer variable CUM to advance past an argument
+in the argument list.  */
+void
+msp430_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,
+			     tree type, int named ATTRIBUTE_UNUSED)
+{
+  int regs = msp430_num_arg_regs (mode, type);
+
+  cum->nregs -= regs;
+  cum->regno -= regs;
+
+  if (cum->nregs <= 0)
+    {
+      cum->nregs = 0;
+      cum->regno = FIRST_CUM_REG;
+    }
+}
+
+/* Returns the number of registers to allocate for a function argument.  */
+static int
+msp430_num_arg_regs (enum machine_mode mode, tree type)
+{
+  int size;
+
+  if (mode == BLKmode)
+    size = int_size_in_bytes (type);
+  else
+    size = GET_MODE_SIZE (mode);
+
+  if (size < UNITS_PER_WORD)
+    size = UNITS_PER_WORD;
+
+  /* we do not care if argument is passed in odd register
+     so, do not align the size ...
+     BUT!!! even char argument passed in 16 bit register
+     so, align the size */
+  return STACK_ALIGN_SIZE (size) / UNITS_PER_WORD;
+}
+
+int
+msp430_initial_elimination_offset (int from, int to)
+{
+  const struct machine_function *mfp = cfun->machine;
+  int offset_words = 0;
+  int offset_bytes = 0;
+
+  switch (from)
+    {
+    case ARG_POINTER_REGNUM:
+      if (mfp->interrupt)
+	offset_words += 2;
+      else
+	offset_bytes += GET_MODE_SIZE (Pmode);
+      switch (to)
+	{
+	case HARD_FRAME_POINTER_REGNUM:
+	  break;
+	case STACK_POINTER_REGNUM:
+	  if (MSP430_FF_prologue_push_sr & mfp->frame_flags)
+	    ++offset_words;
+	  offset_words += compute_savable_registers (0);
+	  offset_bytes += get_frame_size ();
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+      break;
+    case FRAME_POINTER_REGNUM:
+      switch (to)
+	{
+	case STACK_POINTER_REGNUM:
+	  break;
+	case HARD_FRAME_POINTER_REGNUM:
+	  if (MSP430_FF_prologue_push_sr & mfp->frame_flags)
+	    ++offset_words;
+	  offset_words += compute_savable_registers (0);
+	  offset_bytes += get_frame_size ();
+	  offset_words = -offset_words;
+	  offset_bytes = -offset_bytes;
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  offset_bytes += UNITS_PER_WORD * offset_words;
+  return STACK_ALIGN_SIZE (offset_bytes);
+}
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430-gcc.c gcc-4.5.3/gcc/config/msp430/msp430-gcc.c
new file mode 100644
index 0000000..ffcec89
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430-gcc.c
@@ -0,0 +1,71 @@
+#include "config.h"
+#include "system.h"
+#include "prefix.h"
+#include "defaults.h"
+
+extern const char *msp430_mcucpp (int argc, const char **argv);
+
+extern const char *msp430_mculdscriptpath (int argc, const char **argv);
+
+
+const char *
+msp430_mcucpp (int argc, const char **argv)
+{
+  static const char prefix[] = "-D__";
+  static const char suffix[] = "__";
+  size_t len;
+  char *result;
+  char *ep;
+  const char *cp;
+
+#if 0
+  fprintf (stderr, "%d args: ", argc);
+  for (len = 0; len < argc; ++len)
+    fprintf (stderr, "'%s' ", argv[len]);
+  fprintf (stderr, "\n");
+#endif
+
+  if (0 == argc)
+    return NULL;
+  /* Take the last one.  Normalization seems to leave the legacy variant
+   * present. */
+  cp = argv[argc - 1];
+  len = (sizeof (prefix) - 1) + strlen (cp) + sizeof (suffix);
+  result = XNEWVAR (char, len);
+  ep = result;
+  strcpy (ep, prefix);
+  ep += sizeof (prefix) - 1;
+  while (*cp)
+    {
+      *ep++ = TOUPPER (*cp);
+      ++cp;
+    }
+  *ep = 0;
+  strcat (result, suffix);
+  return result;
+}
+
+#ifndef DIR_UP
+#define DIR_UP ".."
+#endif /* DIR_UP */
+
+const char *
+msp430_mculdscriptpath (int argc, const char **argv)
+{
+  static const char dir_sep[] = { DIR_SEPARATOR, 0 };
+  const char *gcc_exec_prefix;
+
+  if (0 == argc)
+    return 0;
+
+  GET_ENVIRONMENT (gcc_exec_prefix, "GCC_EXEC_PREFIX");
+  if (!gcc_exec_prefix)
+    gcc_exec_prefix = STANDARD_EXEC_PREFIX;
+
+  return
+    update_path (concat
+		 (gcc_exec_prefix, DIR_UP, dir_sep, DIR_UP, dir_sep,
+		  DEFAULT_TARGET_MACHINE, dir_sep, "lib", dir_sep,
+		  "ldscripts", dir_sep, argv[argc - 1], dir_sep, NULL),
+		 "BINUTILS");
+}
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430-protos.h gcc-4.5.3/gcc/config/msp430/msp430-protos.h
new file mode 100644
index 0000000..856da5f
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430-protos.h
@@ -0,0 +1,180 @@
+/* Prototypes for exported functions defined in msp430.c
+   
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Contributed by Dmitry Diky <diwil@mail.ru>
+
+   This file is part of GNU CC.
+
+   GNU CC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GNU CC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GNU CC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+
+extern void bootloader_section (void);
+extern void infomem_section (void);
+
+extern void asm_file_start (FILE * file);
+extern void asm_file_end (FILE * file);
+extern void msp430_override_options (void);
+/*extern void   function_prologue         (FILE *file, int size);
+extern void   function_epilogue         (FILE *file, int size);*/
+extern void gas_output_limited_string (FILE * file, const char *str);
+extern void gas_output_ascii (FILE * file, const char *str, size_t length);
+extern void order_regs_for_local_alloc (void);
+
+int msp430_regno_ok_for_base_p (int reg, int strict);
+
+int msp430_adjust_insn_length (rtx insn, int length);
+
+#ifdef HAVE_MACHINE_MODES
+extern int msp430_hard_regno_mode_ok (int regno, enum machine_mode mode);
+#endif
+
+extern int msp430_initial_elimination_offset (int, int);
+
+#ifdef TREE_CODE
+void msp430_asm_declare_function_name (FILE *, const char *, tree);
+unsigned int msp430_section_type_flags (tree DECL, const char *NAME,
+					int RELOC);
+
+#ifdef RTX_CODE			/* inside TREE_CODE */
+extern rtx msp430_function_arg (CUMULATIVE_ARGS * cum,
+				enum machine_mode mode, tree type, int named);
+extern void msp430_init_cumulative_args (CUMULATIVE_ARGS * cum,
+					 tree fntype, rtx libname,
+					 tree fndecl);
+extern void msp430_init_cumulative_incoming_args (CUMULATIVE_ARGS * cum,
+						  tree fntype, rtx libname);
+extern rtx msp430_function_incoming_arg (CUMULATIVE_ARGS * cum,
+					 enum machine_mode mode, tree type,
+					 int named);
+
+
+
+#endif /* RTX_CODE inside TREE_CODE */
+
+#ifdef HAVE_MACHINE_MODES	/* inside TREE_CODE */
+extern void msp430_function_arg_advance (CUMULATIVE_ARGS * cum,
+					 enum machine_mode mode, tree type,
+					 int named);
+#endif /* HAVE_MACHINE_MODES inside TREE_CODE */
+#endif /* TREE_CODE */
+
+#ifdef RTX_CODE
+
+int msp430_extract_multiword_operand (enum machine_mode innermode, rtx op,
+				      rtx * parts);
+
+extern void msp430_emit_cbranch (rtx operands[]);
+
+extern int dead_or_set_in_peep (int, rtx, rtx);
+
+const char *msp430_output_template (enum machine_mode mode,
+				    int src_operand,
+				    const char *init_op, const char *next_op);
+const char *msp430_mov_noclobber (rtx operands[]);
+
+enum reg_class msp430_regno_reg_class (int);
+
+extern RTX_CODE followed_compare_condition (rtx);
+
+extern const char *msp430_addsi_code (rtx insn, rtx operands[]);
+extern const char *msp430_subsi_code (rtx insn, rtx operands[]);
+extern const char *msp430_andsi_code (rtx insn, rtx operands[]);
+extern const char *msp430_iorsi_code (rtx insn, rtx operands[]);
+extern const char *msp430_xorsi_code (rtx insn, rtx operands[]);
+extern const char *msp430_adddi_code (rtx insn, rtx operands[]);
+extern const char *msp430_subdi_code (rtx insn, rtx operands[]);
+extern const char *msp430_anddi_code (rtx insn, rtx operands[]);
+extern const char *msp430_iordi_code (rtx insn, rtx operands[]);
+extern const char *msp430_xordi_code (rtx insn, rtx operands[]);
+
+
+extern int zero_shifted (rtx);
+
+extern int msp430_vwa_general_operand (rtx, enum machine_mode);
+extern int msp430_vwa_nonimmediate_operand (rtx, enum machine_mode);
+extern int msp430_vwa_memory_operand (rtx, enum machine_mode);
+extern int halfnibble_constant (rtx, enum machine_mode);
+extern int halfnibble_integer (rtx, enum machine_mode);
+extern int which_nibble (int);
+
+extern const char *msp430_emit_abssi (rtx insn, rtx operands[]);
+extern const char *msp430_emit_absdi (rtx insn, rtx operands[]);
+
+extern const char *msp430_movstrhi_insn (rtx insn, rtx operands[]);
+extern const char *msp430_clrstrhi_insn (rtx insn, rtx operands[]);
+
+extern void msp430_expand_mov_intptr (rtx dest, rtx src);
+
+extern int is_shift_better_in_reg (rtx operands[]);
+extern const char *msp430_emit_ashlqi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashlhi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashlsi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashldi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashrqi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashrhi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashrsi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_ashrdi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_lshrqi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_lshrhi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_lshrsi3 (rtx insn, rtx operands[]);
+extern const char *msp430_emit_lshrdi3 (rtx insn, rtx operands[]);
+
+int msp430_extend_matches (const_rtx, const_rtx);
+void msp430_expand_signextend (rtx operands[]);
+void msp430_expand_zeroextend (rtx operands[]);
+
+extern const char *msp430_emit_call (rtx operands[]);
+
+const char *msp430_cbranch (rtx insn, rtx operands[]);
+
+extern void msp430_notice_update_cc (rtx body, rtx insn);
+extern int msp430_peep2_scratch_safe (rtx reg_rtx);
+extern int test_hard_reg_class (enum reg_class rclass, rtx x);
+extern void machine_dependent_reorg (rtx first_insn);
+extern void msp430_output_addr_vec_elt (FILE * stream, int value);
+
+extern int msp430_address_cost (rtx x);
+extern int msp430_extra_constraint (rtx x, int c);
+extern int default_rtx_costs (rtx X, RTX_CODE code, RTX_CODE outer_code,
+			      bool);
+
+extern void msp430_print_operand (FILE * file, rtx x, int code);
+extern void msp430_print_operand_address (FILE * file, rtx addr);
+extern int reg_unused_after (rtx insn, rtx reg);
+extern int msp430_jump_dist (rtx x, rtx insn);
+extern int call_insn_operand (rtx op, enum machine_mode mode);
+extern int msp430_branch_mode (rtx x, rtx insn);
+
+extern int msp430_expand_mul (rtx[], int);
+extern int msp430_ashlhi3 (rtx[]);
+extern int msp430_ashlsi3 (rtx[]);
+extern int msp430_ashrhi3 (rtx[]);
+extern int msp430_ashrsi3 (rtx[]);
+extern int msp430_lshrhi3 (rtx[]);
+extern int msp430_lshrsi3 (rtx[]);
+
+extern void expand_prologue (void);
+extern void expand_epilogue (void);
+extern void msp430_set_current_function (tree);
+extern int msp430_epilogue_uses (int regno);
+
+#endif /* RTX_CODE */
+
+#ifdef HAVE_MACHINE_MODES
+extern int class_max_nregs (enum reg_class rclass, enum machine_mode mode);
+#endif /* HAVE_MACHINE_MODES */
+
+extern rtx msp430_return_addr_rtx (int, rtx);
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430.c gcc-4.5.3/gcc/config/msp430/msp430.c
new file mode 100644
index 0000000..5f696d6
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430.c
@@ -0,0 +1,4670 @@
+/* TODO
+ * cost speed attribute
+ */
+/* This work is partially financed by the European Commission under the
+* Framework 6 Information Society Technologies Project
+* "Wirelessly Accessible Sensor Populations (WASP)".
+*/
+
+/*
+	GCC 4.x port by Ivan Shcherbakov <mspgcc@sysprogs.org>
+*/
+
+/* Subroutines for insn-output.c for Texas Instruments MSP430 MCU
+Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+Contributed by Dmitry Diky <diwil@mail.ru>
+
+This file is part of GNU CC. 
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "tree.h"
+#include "output.h"
+#include "expr.h"
+#include "toplev.h"
+#include "obstack.h"
+#include "function.h"
+#include "recog.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+#include "insn-codes.h"
+#include "ggc.h"
+#include "langhooks.h"
+#include "df.h"
+#include "intl.h"
+#include "diagnostic.h"
+
+#define TARGET_REORDER 0
+
+/* Number of consecutive registers available for returning values from
+ * a function.  These start with RETURN_REGISTER_BASE and grow
+ * "down". */
+#define RETURN_REGISTERS_AVAILABLE 4
+
+msp430_cpu_e msp430_cpu = MSP430_CPU_MSP430;
+msp430_mpy_e msp430_mpy = MSP430_MPY_NONE;
+int msp430_ivcnt = 16;
+
+int msp430_case_values_threshold = 30000;
+int msp430_has_hwmul = 0;
+
+/* Defined in msp430-builtins.c */
+void msp430_init_builtins (void);
+rtx msp430_expand_builtin (tree, rtx, rtx, enum machine_mode, int);
+
+static struct machine_function *
+msp430_init_machine_status (void)
+{
+  return ((struct machine_function *)
+	  ggc_alloc_cleared (sizeof (struct machine_function)));
+}
+
+static rtx mpy_b_rtx;
+static rtx mpys_b_rtx;
+static rtx op2_b_rtx;
+static rtx reslo_b_rtx;
+static rtx mpy_rtx;
+static rtx mpys_rtx;
+static rtx op2_rtx;
+static rtx reslo_rtx;
+static rtx reshi_rtx;
+static rtx mpy32l_rtx;
+static rtx mpy32h_rtx;
+static rtx mpys32l_rtx;
+static rtx mpys32h_rtx;
+static rtx op2l_rtx;
+static rtx op2h_rtx;
+static rtx res0_rtx;
+static rtx res1_rtx;
+static rtx res2_rtx;
+static rtx res3_rtx;
+
+static rtx
+gen_rtx_HWREG (enum machine_mode mode, const char *name)
+{
+  rtx ret = gen_rtx_MEM (mode, gen_rtx_SYMBOL_REF (mode, name));
+  MEM_VOLATILE_P (ret) = 1;
+  return ret;
+}
+
+static void
+msp430_init_once (void)
+{
+  init_machine_status = msp430_init_machine_status;
+
+  if (msp430_mpy & MSP430_MPY_TYPE_16)
+    {
+      mpy_b_rtx = gen_rtx_HWREG (QImode, "__MPY");
+      mpys_b_rtx = gen_rtx_HWREG (QImode, "__MPYS");
+      op2_b_rtx = gen_rtx_HWREG (QImode, "__OP2");
+      reslo_b_rtx = gen_rtx_HWREG (QImode, "__RESLO");
+      mpy_rtx = gen_rtx_HWREG (HImode, "__MPY");
+      mpys_rtx = gen_rtx_HWREG (HImode, "__MPYS");
+      op2_rtx = gen_rtx_HWREG (HImode, "__OP2");
+      reslo_rtx = gen_rtx_HWREG (HImode, "__RESLO");
+      reshi_rtx = gen_rtx_HWREG (HImode, "__RESHI");
+    }
+  if (msp430_mpy & MSP430_MPY_TYPE_32)
+    {
+      mpy32l_rtx = gen_rtx_HWREG (HImode, "__MPY32L");
+      mpy32h_rtx = gen_rtx_HWREG (HImode, "__MPY32H");
+      mpys32l_rtx = gen_rtx_HWREG (HImode, "__MPYS32L");
+      mpys32h_rtx = gen_rtx_HWREG (HImode, "__MPYS32H");
+      op2l_rtx = gen_rtx_HWREG (HImode, "__OP2L");
+      op2h_rtx = gen_rtx_HWREG (HImode, "__OP2H");
+      res0_rtx = gen_rtx_HWREG (HImode, "__RES0");
+      res1_rtx = gen_rtx_HWREG (HImode, "__RES1");
+      res2_rtx = gen_rtx_HWREG (HImode, "__RES2");
+      res3_rtx = gen_rtx_HWREG (HImode, "__RES3");
+    }
+  
+  return;
+}
+
+/****** ATTRIBUTES *************************************/
+
+/* Handle an attribute requiring a FUNCTION_DECL; arguments as in
+struct attribute_spec.handler.  */
+static tree
+handle_fndecl_attribute (tree * pnode, tree name,
+			 tree args ATTRIBUTE_UNUSED,
+			 int flags ATTRIBUTE_UNUSED, bool * no_add_attrs)
+{
+  if (TREE_CODE (*pnode) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
+
+const struct attribute_spec msp430_attribute_table[] = {
+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
+  {"signal", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"interrupt", 0, 1, true, false, false, handle_fndecl_attribute},
+  {"naked", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"task", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"wakeup", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"critical", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"reentrant", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"saveprologue", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"noint_hwmul", 0, 0, true, false, false, handle_fndecl_attribute},
+  {"hosted", 0, 0, true, false, false, handle_fndecl_attribute},
+  {NULL, 0, 0, false, false, false, NULL}
+};
+
+int
+msp430_current_function_noint_hwmul_function_p (void)
+{
+  return TARGET_NOINT_HWMUL || (cfun && cfun->machine
+				&& cfun->machine->initialized
+				&& cfun->machine->noint_hwmul != NULL_TREE);
+}
+
+unsigned int
+msp430_section_type_flags (tree decl, const char *name, int reloc)
+{
+  unsigned int flags = 0;
+
+  if (!strcmp (name, ".infomemnobits") || !strcmp (name, ".noinit"))
+    flags = SECTION_BSS;
+
+  flags |= default_section_type_flags (decl, name, reloc);
+  return flags;
+}
+
+struct tag_value_pair_t
+{
+  const char *tag;
+  unsigned long value;
+};
+
+static const struct tag_value_pair_t cpu_tag_value_map[] = {
+  {"430", MSP430_CPU_MSP430},
+  {"430x", MSP430_CPU_MSP430X},
+  {"430xv2", MSP430_CPU_MSP430XV2},
+  {0, 0}
+};
+
+static const struct tag_value_pair_t mpy_tag_value_map[] = {
+  {"none", MSP430_MPY_NONE},
+  {"16", MSP430_MPY_16},
+  {"16se", MSP430_MPY_16SE},
+  {"32", MSP430_MPY_32},
+  {"32dw", MSP430_MPY_32DW},
+  {0, 0}
+};
+
+static const struct tag_value_pair_t *
+find_pair_by_tag (const char *tag, const struct tag_value_pair_t *map)
+{
+  while (map->tag)
+    {
+      if (0 == strcmp (tag, map->tag))
+	return map;
+      ++map;
+    }
+  return 0;
+}
+
+static const struct tag_value_pair_t *
+find_pair_by_value (unsigned long value, const struct tag_value_pair_t *map)
+{
+  while (map->tag)
+    {
+      if (map->value == value)
+	return map;
+      ++map;
+    }
+  return 0;
+}
+
+void
+msp430_override_options (void)
+{
+  const struct tag_value_pair_t *mp;
+
+  if (flag_pic)
+    error ("PIC not supported on msp430");
+
+  if (msp430_opt_cpu)
+    {
+      mp = find_pair_by_tag (msp430_opt_cpu, cpu_tag_value_map);
+      if (!mp)
+	{
+	  error (_("mcpu %s not recognized"), msp430_opt_cpu);
+	  return;
+	}
+      msp430_cpu = mp->value;
+    }
+
+  if (msp430_opt_mpy)
+    {
+      mp = find_pair_by_tag (msp430_opt_mpy, mpy_tag_value_map);
+      if (!mp)
+	{
+	  error (_("mmpy %s not recognized"), msp430_opt_mpy);
+	  return;
+	}
+      msp430_mpy = mp->value;
+    }
+
+  if (msp430_opt_ivcnt)
+    {
+      char *ep;
+      msp430_ivcnt = strtol (msp430_opt_ivcnt, &ep, 0);
+      if (*msp430_opt_ivcnt && *ep)
+	{
+	  error (_("ivcnt %s must be integer"), msp430_opt_ivcnt);
+	  gcc_unreachable ();
+	  return;
+	}
+      if ((16 != msp430_ivcnt) && (32 != msp430_ivcnt)
+	  && (64 != msp430_ivcnt))
+	{
+	  error (_("ivcnt %s must be 16, 32, or 64"), msp430_opt_ivcnt);
+	  gcc_unreachable ();
+	  return;
+	}
+    }
+
+  if (TARGET_NO_HWMUL)
+    {
+      warning (OPT_Wdeprecated, "-mdisable-hwmul deprecated, use -mmpy=none");
+      msp430_mpy = MSP430_MPY_NONE;
+    }
+  msp430_has_hwmul = !!(msp430_mpy & MSP430_MPY_TYPE_ANY);
+
+  msp430_case_values_threshold = 8;	/* ? or there is a better value ? */
+
+  flag_defer_pop = 0;
+
+  msp430_init_once ();
+}
+
+/* Return in memory unless size is determined to be no greater than
+ * eight bytes. */
+static bool
+msp430_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  if (TYPE_MODE (type) == BLKmode)
+    {
+      HOST_WIDE_INT size = int_size_in_bytes (type);
+      return (size == -1
+	      || size > (RETURN_REGISTERS_AVAILABLE * UNITS_PER_WORD));
+    }
+  return false;
+}
+
+static int reg_class_tab[FIRST_VIRTUAL_REGISTER] = {
+  PC_REG, SP_REG, SR_REG, CG2_REG,	/* fixed registers */
+  FP_REG,			/* maybe fixed reg */
+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,	/* unassigned registers r5 - r15 */
+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+  SOFT_ARGP_REG, SOFT_FP_REG,	/* fixed pseudo registers */
+};
+
+int
+msp430_regno_ok_for_base_p (int reg, int strict)
+{
+  if (strict && reg >= FIRST_PSEUDO_REGISTER && reg_renumber)
+    reg = reg_renumber[reg];
+  if (reg < 0)
+    return 0;
+  if (!strict && reg > MSP430_MAX_GENERAL_REGNUM)
+    return 1;
+  return reg == STACK_POINTER_REGNUM || MSP430_GENERAL_REGISTER_NUM_P (reg);
+}
+
+enum reg_class
+msp430_regno_reg_class (int r)
+{
+  if (r < (int) (sizeof (reg_class_tab) / sizeof (reg_class_tab[0])))
+    return reg_class_tab[r];
+
+  return NO_REGS;
+}
+
+void
+msp430_asm_declare_function_name (FILE * file, const char *name, tree decl)
+{
+  struct machine_function *mfp = cfun->machine;
+  bool is_isr = NULL_TREE != mfp->interrupt;
+  int vector = -1;
+
+  if (is_isr && (0 <= mfp->vector_offset))
+    {
+      vector = mfp->vector_offset / 2;
+      if (0 < msp430_ivcnt && (vector >= msp430_ivcnt))
+	{
+	  error_at (DECL_SOURCE_LOCATION (decl),
+		    _
+		    ("interrupt vector %d is beyond end of MCU vector table"),
+		    vector);
+	  vector = -1;
+	  is_isr = false;
+	}
+    }
+
+  fprintf (file, "%s", TYPE_ASM_OP);
+  assemble_name (file, name);
+  putc (',', file);
+  fprintf (file, TYPE_OPERAND_FMT, "function");
+  putc ('\n', file);
+  fprintf (file, "/***********************\n");
+  if (!is_isr)
+    fprintf (file, " * Function `");
+  else if (0 > vector)
+    fprintf (file, " * Interrupt Sub-Routine `");
+  else
+    fprintf (file, " * Interrupt Vector %d Service Routine `", vector);
+  assemble_name (file, name);
+  fprintf (file, "' %s\n ***********************/\n",
+	   (cfun->machine->critical != NULL_TREE)
+	   ? "(OS critical)"
+	   : (cfun->machine->reentrant != NULL_TREE) ? "(reentrant)" : "");
+  ASM_OUTPUT_LABEL (file, name);
+  if (0 <= vector)
+    {
+      char isrname[32];
+      snprintf (isrname, sizeof (isrname), "__isr_%u", vector);
+      fprintf (file, ".global\t%s\n", isrname);
+      fprintf (file, "%s:\n", isrname);
+    }
+
+}
+
+static bool
+msp430_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,
+			     rtx x, bool strict)
+{
+  switch (GET_CODE (x))
+    {
+    case REG:
+      return msp430_regno_ok_for_base_p (REGNO (x), strict);
+    case PLUS:
+      return REG_P (XEXP (x, 0))
+	&& msp430_legitimate_address_p (mode, XEXP (x, 0), strict)
+	&& CONSTANT_P (XEXP (x, 1));
+    default:
+      return CONSTANT_P (x);
+    }
+  gcc_unreachable ();
+}
+
+void
+msp430_print_operand_address (FILE * file, rtx addr)
+{
+  /* hopefully will be never entered. */
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      fprintf (file, "r%d", REGNO (addr));
+      return;
+    case POST_INC:
+      fprintf (file, "@r%d+", REGNO (XEXP (addr, 0)));
+      return;
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST:
+      fprintf (file, "#");
+      break;
+    case CODE_LABEL:
+      break;
+    default:
+      gcc_unreachable ();
+      fprintf (file, "&");
+    }
+  output_addr_const (file, addr);
+}
+
+static const char *trim_array[] = { "llo", "lhi", "hlo", "hhi" };
+
+static void
+print_sub_operand (FILE * file, rtx x, int code)
+{
+
+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)
+    {
+      output_addr_const (file, x);
+      return;
+    }
+  else if (GET_CODE (x) == CONST)
+    {
+      print_sub_operand (file, XEXP (x, 0), code);
+      return;
+    }
+  else if (GET_CODE (x) == PLUS)
+    {
+      print_sub_operand (file, XEXP (x, 0), code);
+      fprintf (file, "+");
+      print_sub_operand (file, XEXP (x, 1), code);
+      return;
+    }
+  else if (GET_CODE (x) == CONST_INT)
+    {
+      fprintf (file, "%ld", INTVAL (x));
+      return;
+    }
+  else
+    gcc_unreachable ();
+}
+
+void
+msp430_print_operand (FILE * file, rtx x, int code)
+{
+  int shift = 0;
+  int ml = GET_MODE_SIZE (x->mode);
+  int source_reg = 0;
+
+  /* Used: ABCDEIJLN */
+  if (ml > 1)
+    ml = 2;
+
+  if (code >= 'A' && code <= 'D')
+    shift = code - 'A';
+
+  if (code >= 'E' && code <= 'H')
+    {
+      shift = code - 'E';
+      source_reg = 1;
+    }
+
+  if (code >= 'I' && code <= 'L')
+    {
+      ml = 1;
+      shift = code - 'I';
+    }
+
+  if (GET_CODE (x) == PLUS)
+    {
+      fprintf (file, "add%s", shift ? "c" : "");
+    }
+  else if (GET_CODE (x) == MINUS)
+    {
+      fprintf (file, "sub%s", shift ? "c" : "");
+    }
+  else if (GET_CODE (x) == AND)
+    {
+      fprintf (file, "and");
+    }
+  else if (GET_CODE (x) == IOR)
+    {
+      fprintf (file, "bis");
+    }
+  else if (GET_CODE (x) == XOR)
+    {
+      fprintf (file, "xor");
+    }
+  else if (REG_P (x))
+    {
+      fprintf (file, reg_names[true_regnum (x) + shift]);
+    }
+  else if (GET_CODE (x) == CONST_INT)
+    {
+      if (code != 'F')
+	{
+	  HOST_WIDE_INT intval = INTVAL (x);
+	  if (!shift && !(intval & ~0xFFFF))	/* For improved ASM readability, omit #llo(const) for small constants */
+	    fprintf (file, "#%d", (int) intval);
+	  else
+	    fprintf (file, "#%s(%ld)", trim_array[shift], intval);
+	}
+      else
+	fprintf (file, "%ld", INTVAL (x));
+    }
+  else if (GET_CODE (x) == MEM)
+    {
+      rtx addr = XEXP (x, 0);
+
+      if (GET_CODE (addr) == POST_INC)
+	{
+	  fprintf (file, "@r%d+", REGNO (XEXP (addr, 0)));
+	}
+      else if (GET_CODE (addr) == REG)
+	{			/* for X(Rn) */
+	  int regno = REGNO (addr);
+	  if (code == 'S' && regno == STACK_POINTER_REGNUM)
+	    fprintf (file, "%d(r%d)", UNITS_PER_WORD, REGNO (addr));
+	  else if (shift || !source_reg)
+	    {
+	      if (shift)
+		fprintf (file, "%d(r%d)", shift * ml, REGNO (addr));
+	      else
+		fprintf (file, "@r%d", REGNO (addr));
+	    }
+	  else if (source_reg)
+	    {
+	      fprintf (file, "r%d", REGNO (addr) + shift);
+	    }
+	  else
+	    {
+	      fprintf (file, "@r%d", REGNO (addr));
+	    }
+	}
+      else if (GET_CODE (addr) == SYMBOL_REF)
+	{
+	  fprintf (file, "&");
+	  output_addr_const (file, addr);
+	  if (shift)
+	    fprintf (file, "+%d", shift * ml);
+	}
+      else if (GET_CODE (addr) == CONST || GET_CODE (addr) == CONST_INT)
+	{
+	  fputc ('&', file);
+	  output_addr_const (file, addr);
+	  if (shift)
+	    fprintf (file, "+%d", shift * ml);
+	}
+      else if (GET_CODE (addr) == PLUS)
+	{
+	  rtx base = XEXP (addr, 0);
+	  rtx offset = XEXP (addr, 1);
+	  int regno = -1;
+
+	  gcc_assert (REG_P (base));
+	  regno = REGNO (base);
+
+	  print_sub_operand (file, offset, code);
+	  if (code == 'S' && regno == STACK_POINTER_REGNUM)
+	    fprintf (file, "+%d(%s)", UNITS_PER_WORD,
+		     reg_names[STACK_POINTER_REGNUM]);
+	  else
+	    {
+	      if (shift)
+		fprintf (file, "+%d", shift * ml);
+
+	      fprintf (file, "(r%d)", REGNO (XEXP (addr, 0)));
+	    }
+	}
+      else if (GET_CODE (addr) == MEM)
+	{
+	  fprintf (file, "@(Invalid addressing mode)");
+	  msp430_print_operand (file, addr, code);
+	}
+      else
+	{
+	  fprintf (file, "Unknown operand. Please check.");
+	}
+    }
+  else if (GET_CODE (x) == SYMBOL_REF)
+    {
+      fprintf (file, "#");
+      output_addr_const (file, x);
+      if (shift)
+	fprintf (file, "+%d", shift * ml);
+    }
+  else if (GET_CODE (x) == CONST_DOUBLE)
+    {
+      if (GET_MODE (x) == VOIDmode)	/* FIXME: may be long long?? */
+	{
+	  if (shift < 2)
+	    fprintf (file, "#%s(%ld)", trim_array[shift],
+		     CONST_DOUBLE_LOW (x));
+	  else
+	    fprintf (file, "#%s(%ld)", trim_array[shift - 2],
+		     CONST_DOUBLE_HIGH (x));
+	}
+      else if (GET_MODE (x) == SFmode || GET_MODE (x) == SImode)
+	{
+	  long val;
+	  REAL_VALUE_TYPE rv;
+	  REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+	  REAL_VALUE_TO_TARGET_SINGLE (rv, val);
+	  asm_fprintf (file, "#%s(0x%lx)", trim_array[shift], val);
+	}
+      else
+	{
+	  fatal_insn ("Internal compiler bug. Unknown mode:", x);
+	}
+    }
+  else
+    msp430_print_operand_address (file, x);
+}
+
+/* Convert an operand that requires multiple words into a sequence of
+   word-sized operands comprising its elements, from least significant
+   to most significant.  Returns the number of word elements
+   extracted. */
+int
+msp430_extract_multiword_operand (enum machine_mode innermode, rtx op,
+				  rtx * parts)
+{
+#if 0
+  result = simplify_gen_subreg (mode, x, GET_MODE (x),
+				subreg_highpart_offset (mode, GET_MODE (x)));
+  gcc_assert (result);
+
+  if (MEM_P (result))
+    {
+      result = validize_mem (result);
+      gcc_assert (result);
+    }
+#endif
+  int words = GET_MODE_SIZE (innermode) / UNITS_PER_WORD;
+  rtx last_insn = get_last_insn ();
+  rtx insn;
+  int i;
+
+  for (i = 0; i < words; ++i)
+    {
+      parts[i] =
+	simplify_gen_subreg (HImode, op, innermode, i * UNITS_PER_WORD);
+      gcc_assert (parts[i]);
+      if (MEM_P (parts[i]))
+	{
+	  parts[i] = validize_mem (parts[i]);
+	  gcc_assert (parts[i]);
+	}
+    }
+  gcc_assert (last_insn == get_last_insn ());
+  return words;
+}
+
+
+/* Generate the appropriate template for a read-modify-write operation
+ * in MODE, using the SRC_OPERAND as the operand index for a binary
+ * pattern, with the least significant word generated using INIT_OP
+ * and any higher words are generated using NEXT_OP (which defaults to
+ * INIT_OP if NULL).  If SRC_OPERAND is 0, a unary pattern is used. */
+const char *
+msp430_output_template (enum machine_mode mode,
+			int src_operand,
+			const char *init_op, const char *next_op)
+{
+  char buffer[1024];
+  int offset = 0;
+
+  if (!next_op)
+    next_op = init_op;
+  buffer[offset] = 0;
+  switch (mode)
+    {
+    case QImode:
+      if (0 < src_operand)
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s.b\t%%%d, %%0", init_op, src_operand);
+      else
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s.b\t%%0", init_op);
+      break;
+    case HImode:
+      if (0 < src_operand)
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s\t%%%d, %%0", init_op, src_operand);
+      else
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s\t%%0", init_op);
+      break;
+    case SImode:
+    case SFmode:
+      if (0 < src_operand)
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s\t%%A%d, %%A0\n\t"
+			    "%s\t%%B%d, %%B0",
+			    init_op, src_operand, next_op, src_operand);
+      else
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s\t%%A0\n\t" "%s\t%%B0", init_op, next_op);
+      break;
+    case DImode:
+      if (0 < src_operand)
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s\t%%A%d, %%A0\n\t"
+			    "%s\t%%B%d, %%B0\n\t"
+			    "%s\t%%C%d, %%C0\n\t"
+			    "%s\t%%D%d, %%D0",
+			    init_op, src_operand,
+			    next_op, src_operand,
+			    next_op, src_operand, next_op, src_operand);
+      else
+	offset += snprintf (buffer, sizeof (buffer) - offset,
+			    "%s\t%%A0\n\t"
+			    "%s\t%%B0\n\t"
+			    "%s\t%%C0\n\t"
+			    "%s\t%%D0", init_op, next_op, next_op, next_op);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  return ggc_strdup (buffer);
+}
+
+/* Return an instruction template that performs the move without
+   clobbering registers used in the input. */
+const char *
+msp430_mov_noclobber (rtx operands[])
+{
+  static const char si_fwdtempl[] = "mov\t%A1, %A0\n\tmov\t%B1, %B0";
+  static const char si_revtempl[] = "mov\t%B1, %B0\n\tmov\t%A1, %A0";
+  static const char di_fwdtempl[] =
+    "mov\t%A1, %A0\n\tmov\t%B1, %B0\n\tmov\t%C1, %C0\n\tmov\t%D1, %D0";
+  static const char di_revtempl[] =
+    "mov\t%D1, %D0\n\tmov\t%C1, %C0\n\tmov\t%B1, %B0\n\tmov\t%A1, %A0";
+  static const char di_xBtempl[] =
+    "mov\t%A1, %A0\n\tmov\t%C1, %C0\n\tmov\t%D1, %D0\n\tmov\t%B1, %B0";
+  static const char di_xCtempl[] =
+    "mov\t%A1, %A0\n\tmov\t%B1, %B0\n\tmov\t%D1, %D0\n\tmov\t%C1, %C0";
+
+  const char *fwdtempl;
+  const char *revtempl;
+  int dst_regno;
+  int dst_end_regno;
+  int index_reg;
+
+  switch (GET_MODE (operands[0]))
+    {
+    case SFmode:
+    case SImode:
+      fwdtempl = si_fwdtempl;
+      revtempl = si_revtempl;
+      break;
+    case DImode:
+      fwdtempl = di_fwdtempl;
+      revtempl = di_revtempl;
+      break;
+    default:
+      debug_rtx (operands[0]);
+      gcc_unreachable ();
+    }
+
+  if (!REG_P (operands[0])
+      || safe_from_earlyclobber (operands[1], operands[0]))
+    return fwdtempl;
+
+  if (REG_P (operands[1]))
+    return REGNO (operands[0]) > REGNO (operands[1]) ? revtempl : fwdtempl;
+
+  gcc_assert (MEM_P (operands[1]));
+  dst_regno = REGNO (operands[0]);
+  dst_end_regno = END_REGNO (operands[0]);
+  for (index_reg = dst_regno; index_reg < dst_end_regno; ++index_reg)
+    if (reg_mentioned_p (gen_rtx_REG (VOIDmode, index_reg), operands[1]))
+      break;
+  if (index_reg == dst_regno)
+    return revtempl;
+  if (index_reg + 1 == dst_end_regno)
+    return fwdtempl;
+  if (index_reg == dst_regno + 1)
+    return di_xBtempl;
+  if (index_reg == dst_regno + 2)
+    return di_xCtempl;
+
+  gcc_unreachable ();
+}
+
+/* mode for branch instruction */
+int
+msp430_jump_dist (rtx x, rtx insn)
+{
+  if (insn_addresses_)
+    {
+      int dest_addr = INSN_ADDRESSES (INSN_UID (GET_CODE (x) == LABEL_REF
+						? XEXP (x, 0) : x));
+      int cur_addr = INSN_ADDRESSES (INSN_UID (insn));
+      int jump_distance = dest_addr - cur_addr;
+
+      return jump_distance;
+    }
+  else
+    return 1024;
+}
+
+
+static rtx
+msp430_libcall_value (enum machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)
+{
+  int words;
+
+  words = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+  if (words > RETURN_REGISTERS_AVAILABLE)
+    internal_error ("Too many words (%d) for libcall register return", words);
+  return gen_rtx_REG (mode, (RETURN_REGISTER_BASE + 1 - words));
+}
+
+static rtx
+msp430_function_value (const_tree type,
+		       const_tree fn_decl_or_type ATTRIBUTE_UNUSED,
+		       bool outgoing ATTRIBUTE_UNUSED)
+{
+  unsigned HOST_WIDE_INT bytes;
+  int words;
+  enum machine_mode tmpmode;
+
+  if (TYPE_MODE (type) != BLKmode)
+    return msp430_libcall_value (TYPE_MODE (type), 0);
+
+  /* Although we return reg:BLK, explow.c:hard_function_value will
+     override this to be an integral mode, and we have to round the
+     size up so the return register is compatible. */
+  bytes = int_size_in_bytes (type);
+  tmpmode = GET_CLASS_NARROWEST_MODE (MODE_INT);
+  while ((tmpmode != VOIDmode) && (GET_MODE_SIZE (tmpmode) < bytes))
+    tmpmode = GET_MODE_WIDER_MODE (tmpmode);
+  gcc_assert (tmpmode != VOIDmode);
+  words = (GET_MODE_SIZE (tmpmode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+  if (words > RETURN_REGISTERS_AVAILABLE)
+    internal_error ("Too many words (%d) for block register return", words);
+
+  return gen_rtx_REG (BLKmode, (RETURN_REGISTER_BASE + 1 - words));
+}
+
+int
+halfnibble_integer (rtx op, enum machine_mode mode)
+{
+  int hi, lo;
+  int val;
+
+  if (!const_int_operand (op, mode))
+    return 0;
+
+  /* this integer is the one of form:
+     0xXXXX0000 or 0x0000XXXX,
+     where XXXX not one of -1,1,2,4,8 
+   */
+  val = INTVAL (op);
+  hi = ((val & 0xffff0000ul) >> 16) & 0xffff;
+  lo = (val & 0xffff);
+
+  if (hi && lo)
+    return 0;
+
+  if (hi && hi != 0xffff && hi != 1 && hi != 2 && hi != 4 && hi != 8)
+    return 1;
+  if (lo && lo != 0xffff && lo != 1 && lo != 2 && lo != 4 && lo != 8)
+    return 1;
+
+  return 0;
+}
+
+
+int
+halfnibble_constant (rtx op, enum machine_mode mode)
+{
+  int hi, lo;
+  int val;
+
+  if (!const_int_operand (op, mode))
+    return 0;
+
+  /* this integer is the one of form:
+     0xXXXX0000 or 0x0000XXXX,
+     where XXXX one of -1,1,2,4,8 
+   */
+  val = INTVAL (op);
+  hi = ((val & 0xffff0000ul) >> 16) & 0x0000ffff;
+  lo = (val & 0x0000ffff);
+
+  if ((hi && lo) || (!hi && !lo))
+    return 0;
+
+  if (hi == 0xffff || hi == 1 || hi == 2 || hi == 4 || hi == 8)
+    return 1;
+  if (lo == 0xffff || lo == 1 || lo == 2 || lo == 4 || lo == 8)
+    return 1;
+
+  if (!(hi && lo))
+    return 1;
+
+  return 0;
+}
+
+int
+which_nibble (int val)
+{
+  if (val & 0xffff0000ul)
+    return 1;
+  return 0;
+}
+
+
+/* 1 if REGNO is a general register or the stack pointer */
+int
+msp430_general_or_stack_reg (int regno)
+{
+  return MSP430_GENERAL_REGISTER_NUM_P (regno)
+    || STACK_POINTER_REGNUM == regno;
+}
+
+/* 1 if X is a memory reference through a register suitable for
+   indirect referencing: @rN. */
+int
+msp430_indirect_register_operand (rtx x)
+{
+  if (!MEM_P (x))
+    return 0;
+  x = XEXP (x, 0);
+  if (!REG_P (x))
+    return 0;
+  return msp430_general_or_stack_reg (REGNO (x));
+}
+
+/* 1 if X is a indexed memory reference: X(rN). */
+int
+msp430_indexed_register_operand (rtx x)
+{
+  if (!MEM_P (x))
+    return 0;
+  x = XEXP (x, 0);
+  if (GET_CODE (x) != PLUS)
+    return 0;
+  /* Left addend (Rn) must be an indexing register, but assume that
+     the assembler will be able to create a constant out of whatever
+     the right addend (X) is. */
+  return msp430_general_or_stack_reg (REGNO (XEXP (x, 0)));
+}
+
+int
+zero_shifted (rtx x)
+{
+  int r = 0;
+
+  if (GET_CODE (x) == MEM &&
+      GET_CODE (XEXP (x, 0)) == REG
+      && REGNO (XEXP (x, 0)) != STACK_POINTER_REGNUM
+      && REGNO (XEXP (x, 0)) != HARD_FRAME_POINTER_REGNUM
+      /* the following is Ok, cause we do not corrupt r4 within ISR */
+      /*&& REGNO(XEXP (x,0)) != ARG_POINTER_REGNUM */ )
+    {
+      r = 1;
+    }
+  return r;
+}
+
+
+
+void
+order_regs_for_local_alloc (void)
+{
+  unsigned int i;
+
+  if (TARGET_REORDER)
+    {
+      reg_alloc_order[0] = 12;
+      reg_alloc_order[1] = 13;
+      reg_alloc_order[2] = 14;
+      reg_alloc_order[3] = 15;
+      for (i = 4; i < 16; i++)
+	reg_alloc_order[i] = 15 - i;
+    }
+  else
+    {
+      for (i = 0; i < 16; i++)
+	reg_alloc_order[i] = 15 - i;
+    }
+
+  return;
+}
+
+/* The routine used to output NUL terminated strings.  We use a special
+version of this for most svr4 targets because doing so makes the
+generated assembly code more compact (and thus faster to assemble)
+as well as more readable, especially for targets like the i386
+(where the only alternative is to output character sequences as
+comma separated lists of numbers).   */
+
+#define ESCAPES \
+"\1\1\1\1\1\1\1\1btn\1fr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\0\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0\
+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1"
+/* A table of bytes codes used by the ASM_OUTPUT_ASCII and
+   ASM_OUTPUT_LIMITED_STRING macros.  Each byte in the table
+   corresponds to a particular byte value [0..255].  For any
+   given byte value, if the value in the corresponding table
+   position is zero, the given character can be output directly.
+   If the table value is 1, the byte must be output as a \ooo
+   octal escape.  If the tables value is anything else, then the
+   byte value should be output as a \ followed by the value
+   in the table.  Note that we can use standard UN*X escape
+   sequences for many control characters, but we don't use
+   \a to represent BEL because some svr4 assemblers (e.g. on
+   the i386) don't know about that.  Also, we don't use \v
+   since some versions of gas, such as 2.2 did not accept it.  */
+
+void
+gas_output_limited_string (FILE * file, const char *str)
+{
+  const unsigned char *_limited_str = (const unsigned char *) str;
+  unsigned ch;
+  fputs ("\t.string\t\"", file);
+  for (; (ch = *_limited_str); _limited_str++)
+    {
+      int escape;
+      switch (escape = ESCAPES[ch])
+	{
+	case 0:
+	  putc (ch, file);
+	  break;
+	case 1:
+	  fprintf (file, "\\%03o", ch);
+	  break;
+	default:
+	  putc ('\\', file);
+	  putc (escape, file);
+	  break;
+	}
+    }
+  fprintf (file, "\"\n");
+}
+
+/* The routine used to output sequences of byte values.  We use a special
+version of this for most svr4 targets because doing so makes the
+generated assembly code more compact (and thus faster to assemble)
+as well as more readable.  Note that if we find subparts of the
+character sequence which end with NUL (and which are shorter than
+STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */
+
+#define STRING_LIMIT	((unsigned) 64)
+
+void
+gas_output_ascii (FILE * file, const char *str, size_t length)
+{
+  const unsigned char *_ascii_bytes = (const unsigned char *) str;
+  const unsigned char *limit = _ascii_bytes + length;
+  unsigned bytes_in_chunk = 0;
+  for (; _ascii_bytes < limit; _ascii_bytes++)
+    {
+      const unsigned char *p;
+      if (bytes_in_chunk >= 60)
+	{
+	  fprintf (file, "\"\n");
+	  bytes_in_chunk = 0;
+	}
+      for (p = _ascii_bytes; p < limit && *p != '\0'; p++)
+	continue;
+      if (p < limit && (p - _ascii_bytes) <= (signed) STRING_LIMIT)
+	{
+	  if (bytes_in_chunk > 0)
+	    {
+	      fprintf (file, "\"\n");
+	      bytes_in_chunk = 0;
+	    }
+	  gas_output_limited_string (file, (const char *) _ascii_bytes);
+	  _ascii_bytes = p;
+	}
+      else
+	{
+	  int escape;
+	  unsigned ch;
+	  if (bytes_in_chunk == 0)
+	    fprintf (file, "\t.ascii\t\"");
+	  switch (escape = ESCAPES[ch = *_ascii_bytes])
+	    {
+	    case 0:
+	      putc (ch, file);
+	      bytes_in_chunk++;
+	      break;
+	    case 1:
+	      fprintf (file, "\\%03o", ch);
+	      bytes_in_chunk += 4;
+	      break;
+	    default:
+	      putc ('\\', file);
+	      putc (escape, file);
+	      bytes_in_chunk += 2;
+	      break;
+	    }
+	}
+    }
+  if (bytes_in_chunk > 0)
+    fprintf (file, "\"\n");
+}
+
+
+
+/* Outputs to the stdio stream FILE some
+appropriate text to go at the start of an assembler file.  */
+
+static void
+msp430_file_start (void)
+{
+  FILE *file = asm_out_file;
+  const struct tag_value_pair_t *mp;
+
+  output_file_directive (file, main_input_filename);
+  if (msp430_mcu_name)
+    fprintf (file, "\t.arch %s\n", msp430_mcu_name);
+  mp = find_pair_by_value (msp430_cpu, cpu_tag_value_map);
+  if (mp)
+    fprintf (file, "\t.cpu %s\n", mp->tag);
+  mp = find_pair_by_value (msp430_mpy, mpy_tag_value_map);
+  if (mp)
+    fprintf (file, "\t.mpy %s\n", mp->tag);
+  fprintf (file, "\n");
+}
+
+int
+msp430_hard_regno_mode_ok (int regno ATTRIBUTE_UNUSED,
+			   enum machine_mode mode ATTRIBUTE_UNUSED)
+{
+  return 1;
+}
+
+static bool
+msp430_frame_pointer_required (void)
+{
+  return cfun->machine->frame_pointer_required;
+}
+
+static bool
+msp430_can_eliminate (const int from_reg ATTRIBUTE_UNUSED, const int to_reg)
+{
+  if (frame_pointer_needed)
+    return to_reg == HARD_FRAME_POINTER_REGNUM;
+  return true;
+}
+
+/*********************************************************************/
+
+/*
+Next two return non zero for rtx as
+(set (reg:xx)
+(mem:xx (reg:xx))
+
+*/
+
+static bool
+regsi_ok_safe (rtx operands[])
+{
+  rtx dest = operands[0];
+  rtx areg;
+  int src_reg;
+  int dst_reg;
+
+  if (operands[2])
+    areg = XEXP (operands[2], 0);
+  else
+    areg = XEXP (operands[1], 0);
+
+  if (GET_CODE (dest) == MEM)
+    {
+      dest = XEXP (operands[0], 0);
+      if (GET_CODE (dest) == PLUS && GET_CODE (XEXP (dest, 0)) == REG)
+	{
+	  dest = XEXP (dest, 0);
+	}
+      else if (GET_CODE (dest) == REG)
+	{
+	  ;			/* register */
+	}
+      else
+	return true;
+    }
+
+  if (REGNO (dest) >= FIRST_PSEUDO_REGISTER
+      || REGNO (areg) >= FIRST_PSEUDO_REGISTER)
+    return true;
+
+  dst_reg = true_regnum (dest);
+  src_reg = true_regnum (areg);
+  if (dst_reg > src_reg || dst_reg + 1 < src_reg)
+    {
+      return true;
+    }
+  return false;
+}
+
+static bool
+regsi_ok_clobber (rtx operands[])
+{
+  rtx dest = operands[0];
+  rtx areg = XEXP (operands[2], 0);
+  int src_reg;
+  int dst_reg;
+  int regno = REGNO (dest);
+
+
+  if (GET_CODE (dest) == MEM)
+    {
+      dest = XEXP (operands[0], 0);
+      if (GET_CODE (dest) == PLUS && GET_CODE (XEXP (dest, 0)) == REG)
+	{
+	  dest = XEXP (dest, 0);
+	}
+      else if (GET_CODE (dest) == REG)
+	{
+	  ;			/* register */
+	}
+      else
+	return true;
+    }
+
+  if (regno >= FIRST_PSEUDO_REGISTER || REGNO (areg) >= FIRST_PSEUDO_REGISTER)
+    return true;
+
+  dst_reg = true_regnum (dest);
+  src_reg = true_regnum (areg);
+  if (dst_reg + 1 == src_reg)
+    return true;
+  return false;
+}
+
+/* Adjustment to overall insn length if the given integer value is the
+   source for an operation in the given value.  Assumption is that the
+   operation consists of a single MSP430 instruction repeated once for
+   each word in mode. */
+static int
+length_adjustment_for_int (HOST_WIDE_INT ival, enum machine_mode mode)
+{
+  HOST_WIDE_INT i;
+  int adjustment = 0;
+
+  switch (mode)
+    {
+    case DImode:
+#if HOST_BITS_PER_WIDE_INT > 32
+      i = trunc_int_for_mode (0xFFFF & (ival >> 48), HImode);
+      if (MSP430_CG_INT_P (i))
+	adjustment -= UNITS_PER_WORD;
+      i = trunc_int_for_mode (0xFFFF & (ival >> 32), HImode);
+      if (MSP430_CG_INT_P (i))
+	adjustment -= UNITS_PER_WORD;
+#endif /* HOST_BITS_PER_WIDE_INT */
+      /* FALLTHRU */
+    case SImode:
+    case SFmode:
+      i = trunc_int_for_mode (0xFFFF & (ival >> 16), HImode);
+      if (MSP430_CG_INT_P (i))
+	adjustment -= UNITS_PER_WORD;
+      /* FALLTHRU */
+    case HImode:
+    case QImode:
+      i = trunc_int_for_mode (0xFFFF & (ival >> 0), HImode);
+      if (MSP430_CG_INT_P (i))
+	adjustment -= UNITS_PER_WORD;
+      break;
+    default:
+      break;
+    }
+  return adjustment;
+}
+
+/* Adjustment to instruction length if the given op is an immediate
+   value source for an operation in the given mode. */
+static int
+length_adjustment_for_immediate (rtx op, enum machine_mode mode)
+{
+  int adjustment = 0;
+  HOST_WIDE_INT ival;
+
+  switch (GET_CODE (op))
+    {
+    case CONST_INT:
+      ival = INTVAL (op);
+#if HOST_BITS_PER_WIDE_INT <= 32
+      if (DImode == mode)
+	adjustment -= 2 * UNITS_PER_WORD;
+#endif /* HOST_BITS_PER_WIDE_INT */
+      break;
+    case CONST_DOUBLE:
+#if HOST_BITS_PER_WIDE_INT <= 32
+      if (4 < GET_MODE_SIZE (mode))
+	adjustment +=
+	  length_adjustment_for_int (CONST_DOUBLE_HIGH (op), mode);
+#endif /* HOST_BITS_PER_WIDE_INT */
+      ival = CONST_DOUBLE_LOW (op);
+      break;
+    case CONST:
+#if 0
+      fprintf (stderr, "unhandled immediate CONST ");
+      debug_rtx (op);
+#endif
+      break;
+    case SYMBOL_REF:
+    case LABEL_REF:
+    default:
+#if 0
+      fprintf (stderr, "Unhandled immediate code %s\n",
+	       rtx_name[GET_CODE (op)]);
+#endif
+      return 0;
+    }
+  adjustment += length_adjustment_for_int (ival, mode);
+#if 0
+  fprintf (stderr, "adjustment %d for %smode ", adjustment, mode_name[mode]);
+  debug_rtx (op);
+#endif
+  return adjustment;
+}
+
+/* Return the length adjusted for the effects of pattern in the
+   context of insn. */
+static int
+adjust_pattern_length (rtx insn, rtx pattern, int len)
+{
+  int ilen = len;
+  enum attr_instr_format format = INSTR_FORMAT_UNDEF;
+
+  switch (GET_CODE (pattern))
+    {
+    case SET:
+      {
+	int unspecv = UNSPECV_UNDEFINED;
+	enum rtx_code src_code;
+	rtx src = SET_SRC (pattern);
+	rtx dst = SET_DEST (pattern);
+	enum machine_mode mode = GET_MODE (dst);
+
+	format = get_attr_instr_format (insn);
+	if (INSTR_FORMAT_UNDEF == format)
+	  break;
+
+	src_code = GET_CODE (src);
+	switch (src_code)
+	  {
+	  case UNSPEC_VOLATILE:
+	    unspecv = XINT (src, 1);
+	    src = XVECEXP (src, 0, 0);
+	    break;
+	  case NOT:
+	  case SIGN_EXTEND:
+	  case ZERO_EXTEND:
+	  case BSWAP:
+	    src = XEXP (src, 0);
+	    break;
+	  case AND:		/* includes NAND */
+	  case IOR:
+	  case XOR:
+	  case PLUS:
+	  case MINUS:
+	    if (rtx_equal_p (dst, XEXP (src, 0)))
+	      src = XEXP (src, 1);
+	    else
+	      {
+		gcc_assert (rtx_equal_p (dst, XEXP (src, 1)));
+		src = XEXP (src, 0);
+	      }
+	    if (src_code == AND && GET_CODE (src) == NOT)
+	      src = XEXP (src, 0);
+	    break;
+	  default:
+#if CHECK_INSN_LENGTH
+	    fprintf (stderr, "Unrecognized source code %d (%s) in pattern ",
+		     src_code, rtx_name[src_code]);
+	    debug_rtx (pattern);
+#endif /* CHECK_INSN_LENGTH */
+	    break;
+	  }
+
+	if (immediate_operand (src, VOIDmode))
+	  len += length_adjustment_for_immediate (src, mode);
+	else if (register_operand (src, VOIDmode))
+	  len -= UNITS_PER_WORD * get_attr_instr_mult (insn);
+	else if (format == INSTR_FORMAT_FMT1 || format == INSTR_FORMAT_FMT2S)
+	  {
+	    if (pop_operand (src, VOIDmode))	/* or other auto-increment indirect */
+	      len -= UNITS_PER_WORD * get_attr_instr_mult (insn);
+	    else if (msp430_indirect_register_operand (src))
+	      {
+		if (!(format == INSTR_FORMAT_FMT2S
+		      && push_operand (dst, mode)
+		      && REGNO (XEXP (src, 0)) == STACK_POINTER_REGNUM))
+		  len -= UNITS_PER_WORD;
+	      }
+	  }
+	else
+	  {
+	    /* indexed and symbolic accounted for in default length. */
+#if CHECK_INSN_LENGTH
+	    fprintf (stderr, "Unhandled src ");
+	    debug_rtx (src);
+#endif /* CHECK_INSN_LENGTH */
+	  }
+	switch (format)
+	  {
+	  case INSTR_FORMAT_FMT1:
+	    if (register_operand (dst, mode) || PC == GET_CODE (dst))
+	      len -= UNITS_PER_WORD * get_attr_instr_mult (insn);
+	    break;
+	  default:
+	    break;
+	  }
+	break;
+      }
+    case PARALLEL:
+    case SEQUENCE:
+      {
+	int i;
+	for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)
+	  len = adjust_pattern_length (insn, XVECEXP (pattern, 0, i), len);
+	break;
+      }
+    case CALL:
+    case RETURN:
+    case USE:
+    case UNSPEC_VOLATILE:
+    case CLOBBER:
+    case ASM_INPUT:
+    case ASM_OPERANDS:
+    case ADDR_VEC:
+    default:
+#if CHECK_INSN_LENGTH
+      fprintf (stderr, "Unhandled insn code %d %s\n", GET_CODE (pattern),
+	       rtx_name[GET_CODE (pattern)]);
+#endif /* CHECK_INSN_LENGTH */
+      break;
+    }
+#if TRACE_INSN_LENGTH
+  fprintf (stderr, "insn len %d to %d format %d ", ilen, len, format);
+  debug_rtx (insn);
+#endif /* TRACE_INSN_LENGTH */
+  return len;
+}
+
+int
+msp430_adjust_insn_length (rtx insn, int len)
+{
+  return adjust_pattern_length (insn, PATTERN (insn), len);
+}
+
+void
+machine_dependent_reorg (rtx first_insn ATTRIBUTE_UNUSED)
+{
+  /* nothing to be done here this time */
+  return;
+}
+
+
+int
+test_hard_reg_class (enum reg_class rclass, rtx x)
+{
+  int regno = true_regnum (x);
+  if (regno < 0)
+    return 0;
+  return TEST_HARD_REG_BIT (reg_class_contents[(int) rclass], regno);
+}
+
+
+/* Returns 1 if SCRATCH are safe to be allocated as a scratch
+registers (for a define_peephole2) in the current function.  */
+/* UNUSED ... yet... */
+int
+msp430_peep2_scratch_safe (rtx scratch)
+{
+  if ((cfun->machine->interrupt != NULL_TREE
+       || cfun->machine->signal != NULL_TREE) && current_function_is_leaf)
+    {
+      int first_reg = true_regnum (scratch);
+      int last_reg;
+      int size = GET_MODE_SIZE (GET_MODE (scratch));
+      int reg;
+
+      size >>= 1;
+      if (!size)
+	size = 1;
+
+      last_reg = first_reg + size - 1;
+
+      for (reg = first_reg; reg <= last_reg; reg++)
+	{
+	  if (!df_regs_ever_live_p (reg))
+	    return 0;
+	}
+    }
+
+  return 1;
+}
+
+
+/* Update the condition code in the INSN.
+now mostly unused */
+
+void
+msp430_notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn ATTRIBUTE_UNUSED)
+{
+  CC_STATUS_INIT;
+}
+
+
+
+
+/***************** ARITHMETIC *******************/
+
+static int
+emit_indexed_arith (rtx insn,
+		    rtx operands[], int m, const char *cmd, int iscarry)
+{
+  char insn_template[256];
+  register int i = 0;
+  char *p;
+  rtx reg = NULL;
+  int len = m * 2;
+  rtx x = operands[0];
+  int havestop = 0;
+  rtx pattern;
+  rtx next = next_real_insn (insn);
+
+  pattern = PATTERN (next);
+
+  if (pattern && GET_CODE (pattern) == PARALLEL)
+    {
+      pattern = XVECEXP (pattern, 0, 0);
+    }
+
+  if (followed_compare_condition (insn) != UNKNOWN
+      || GET_CODE (insn) == JUMP_INSN
+      || (pattern
+	  && GET_CODE (pattern) == SET
+	  && SET_DEST (pattern) == cc0_rtx)
+      || (pattern && GET_CODE (pattern) == SET
+	  && SET_DEST (pattern) == pc_rtx))
+    {
+      /* very exotic case */
+
+      snprintf (insn_template, 255, "%s\t" "%%A%d, %%A0", cmd,
+		operands[2] ? 2 : 1);
+      output_asm_insn (insn_template, operands);
+      snprintf (insn_template, 255, "%s%s\t" "%%B%d, %%B0", cmd,
+		iscarry ? "c" : "", operands[2] ? 2 : 1);
+      output_asm_insn (insn_template, operands);
+
+      if (m == 2)
+	return len;
+
+      snprintf (insn_template, 255, "%s%s\t" "%%C%d, %%C0", cmd,
+		iscarry ? "c" : "", operands[2] ? 2 : 1);
+      output_asm_insn (insn_template, operands);
+      snprintf (insn_template, 255, "%s%s\t" "%%D%d, %%D0", cmd,
+		iscarry ? "c" : "", operands[2] ? 2 : 1);
+      output_asm_insn (insn_template, operands);
+
+      return len;
+    }
+
+  if (operands[2])
+    reg = XEXP (operands[2], 0);
+  else
+    reg = XEXP (operands[1], 0);
+
+  if (GET_CODE (x) == REG)
+    {
+      int src;
+      int dst = REGNO (x);
+
+      if (!reg)
+	{
+	  reg = XEXP (operands[1], 0);
+	}
+
+      src = REGNO (reg);
+
+      /* check if registers overlap */
+      if (dst > src || (dst + m - 1) < src)
+	{
+	  ;			/* fine ! */
+	}
+      else if ((dst + m - 1) == src)
+	{
+	  havestop = 1;		/* worse */
+	}
+      else
+	{
+	  /* cannot do reverse assigment */
+	  while (i < m)
+	    {
+	      p = (char *) (insn_template + strlen (cmd));
+	      p += (i && iscarry) ? 3 : 2;
+	      strcpy (insn_template, cmd);
+	      strcat (insn_template, (i && iscarry) ? "c\t%" : "\t%");
+	      *p = 'A' + i;
+	      p++;
+	      *p = 0;
+	      strcat (insn_template, "0, %");
+	      p += 2;
+	      *p = 'A' + i;
+	      p++;
+	      *p = 0;
+	      strcat (insn_template, operands[2] ? "2" : "1");
+	      output_asm_insn (insn_template, operands);
+	      i++;
+	    }
+	  return m * 3;
+	}
+    }
+
+  while (i < (m - havestop))
+    {
+      p = insn_template + strlen (cmd);
+
+      strcpy (insn_template, cmd);
+
+      if (i && iscarry)
+	{
+	  strcat (insn_template, "c\t");
+	  p += 2;
+	}
+      else
+	{
+	  strcat (insn_template, "\t");
+	  p += 1;
+	}
+      strcat (insn_template, operands[2] ? "@%E2+, %" : "@%E1+, %");
+      p += 8;
+      *p = 'A' + i;
+      p++;
+      *p = 0;
+      strcat (insn_template, "0");
+      p++;
+      output_asm_insn (insn_template, operands);
+      i++;
+    }
+
+  if (havestop)
+    {
+      len++;
+      p = insn_template + strlen (cmd);
+      strcpy (insn_template, cmd);
+      if (i && iscarry)
+	{
+	  strcat (insn_template, "c\t");
+	  p += 2;
+	}
+      else
+	{
+	  strcat (insn_template, "\t");
+	  p += 1;
+	}
+      strcat (insn_template, operands[2] ? "@%E2, %" : "@%E1, %");
+      p += 8;
+      *p = 'A' + i;
+      p++;
+      *p = 0;
+      strcat (insn_template, "0	;	register won't die");
+      p += 1;
+      output_asm_insn (insn_template, operands);
+    }
+
+  if (!dead_or_set_p (insn, reg) && !havestop)
+    {
+      len++;
+      p = insn_template + 3;
+      strcpy (insn_template, "sub");
+      strcat (insn_template, "\t#");
+      p += 2;
+      *p = '0' + m * 2;
+      p++;
+      *p = 0;
+
+      if (operands[2])
+	strcat (insn_template, ",    %E2	;	restore %E2");
+      else
+	strcat (insn_template, ",    %E1	;	restore %E1");
+      output_asm_insn (insn_template, operands);
+    }
+
+  return len;
+}
+
+/************** MOV CODE *********************************/
+
+const char *
+msp430_movstrhi_insn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])
+{
+
+  /* operands 0 and 1 are registers !!! */
+  /* operand 2 is a cnt and not zero */
+  output_asm_insn ("\n.Lmsn%=:", operands);
+  output_asm_insn ("mov.b\t@%1+,0(%0)", operands);
+  output_asm_insn ("inc\t%0", operands);
+  output_asm_insn ("dec\t%2", operands);
+  output_asm_insn ("jnz\t.Lmsn%=", operands);
+  return "";
+}
+
+const char *
+msp430_clrstrhi_insn (rtx insn ATTRIBUTE_UNUSED, rtx operands[])
+{
+
+  /* operand 0 is a register !!! */
+  /* operand 1 is a cnt and not zero */
+  output_asm_insn ("\n.Lcsn%=:", operands);
+  output_asm_insn ("clr.b\t0(%0)", operands);
+  output_asm_insn ("inc\t%0", operands);
+  output_asm_insn ("dec\t%1", operands);
+  output_asm_insn ("jnz\t.Lcsn%=", operands);
+  return "";
+}
+
+
+
+/**************	SUB CODE *********************************/
+
+const char *
+msp430_subsi_code (rtx insn, rtx operands[])
+{
+  rtx op2 = operands[2];
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_safe (operands))
+    {
+      emit_indexed_arith (insn, operands, 2, "sub", 1);
+      return "";
+    }
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_clobber (operands))
+    {
+      output_asm_insn ("sub\t@%E2+, %A0", operands);
+      output_asm_insn ("subc\t@%E2+, %B0", operands);
+      return "";
+    }
+
+  output_asm_insn ("sub\t%A2, %A0", operands);
+  output_asm_insn ("subc\t%B2, %B0", operands);
+
+  return "";
+}
+
+/* Return 1 if X and Y are the same for a sign or zero extension,
+   i.e. register or memory reference match except in mode. */
+int
+msp430_extend_matches (const_rtx x, const_rtx y)
+{
+  int rc = rtx_equal_p (x, y);
+  if (rc)
+    return rc;
+  if (GET_CODE (x) == REG && GET_CODE (y) == SUBREG && SUBREG_BYTE (y) == 0)
+    return rtx_equal_p (x, SUBREG_REG (y));
+  if (GET_CODE (x) != GET_CODE (y))
+    return 0;
+  if (GET_CODE (x) == REG)
+    return REGNO (x) == REGNO (y);
+  if (GET_CODE (x) == MEM)
+    return (mpys_rtx == x && mpys_b_rtx == y)
+      || (op2_rtx == x && op2_b_rtx == y)
+      || rtx_equal_p (XEXP (x, 0), XEXP (y, 0));
+  if (GET_CODE (x) == SUBREG)
+    return SUBREG_BYTE (x) == SUBREG_BYTE (y)
+      && rtx_equal_p (SUBREG_REG (x), SUBREG_REG (y));
+  return 0;
+}
+
+/* x is the destination of an extend operation where the source is of
+   the given mode.  Obtain a compatible reference to the low part of
+   the destination so we can copy the source into it. */
+static rtx
+msp430_extend_force_to_mode (rtx x, enum machine_mode mode)
+{
+  switch (GET_CODE (x))
+    {
+    case REG:
+      return gen_lowpart (mode, x);
+    case MEM:
+      return adjust_address (x, mode, 0);
+      break;
+    case SUBREG:
+      return simplify_rtx (gen_lowpart_SUBREG (mode, x));
+    default:
+      break;
+    }
+  gcc_unreachable ();
+}
+
+/* Expand all {,zero_}extendmn2 instructions. */
+static void
+msp430_expand_extend (rtx operands[], bool signed_p)
+{
+  rtx dst_lo = NULL_RTX;	/* hi, or lowpart (hi, si) */
+  rtx dst_hi = NULL_RTX;	/* highpart (hi, si) or highpart (hi, lowpart (si, di)) */
+  rtx dst_llo = NULL_RTX;	/* lowpart (hi, lowpart (si, di)) */
+  rtx dst_lhi = NULL_RTX;	/* highpart (hi, lowpart (si, di)) */
+  rtx dst_hlo = NULL_RTX;	/* lowpart (hi, highpart (si, di)) */
+  rtx dst_hhi = NULL_RTX;	/* highpart (hi, highpart (si, di)) */
+  rtx extended_value;
+  bool need_copy;
+
+  switch (GET_MODE (operands[0]))
+    {
+    case HImode:
+      dst_lo = operands[0];
+      break;
+    case SImode:
+      dst_lo = gen_lowpart (HImode, operands[0]);
+      dst_hi = gen_highpart (HImode, operands[0]);
+      break;
+    case DImode:
+      if (REG_P (operands[0]))
+	{
+	  dst_llo = gen_rtx_SUBREG (HImode, operands[0], 0);
+	  dst_lhi = gen_rtx_SUBREG (HImode, operands[0], UNITS_PER_WORD);
+	  dst_hlo = gen_rtx_SUBREG (HImode, operands[0], 2 * UNITS_PER_WORD);
+	  dst_hhi = gen_rtx_SUBREG (HImode, operands[0], 3 * UNITS_PER_WORD);
+	}
+      else if (MEM_P (operands[0]))
+	{
+	  dst_llo = adjust_address (operands[0], HImode, 0);
+	  dst_lhi = adjust_address (dst_llo, HImode, UNITS_PER_WORD);
+	  dst_hlo = adjust_address (dst_lhi, HImode, UNITS_PER_WORD);
+	  dst_hhi = adjust_address (dst_hlo, HImode, UNITS_PER_WORD);
+	}
+      else
+	{
+	  debug_rtx (operands[0]);
+	  gcc_unreachable ();
+	}
+      dst_lo = dst_llo;
+      dst_hi = dst_lhi;
+      break;
+    default:
+      gcc_unreachable ();
+    }
+  extended_value = signed_p ? NULL_RTX : GEN_INT (0);
+  need_copy = !msp430_extend_matches (operands[0], operands[1]);
+  if (QImode == GET_MODE (operands[1]))
+    {
+      rtx dst_qi = msp430_extend_force_to_mode (dst_lo, QImode);
+
+      if (!signed_p && GET_MODE (operands[0]) == HImode
+	  && operands[0] == op2_rtx)
+	{
+	  emit_insn (gen_andhi3 (dst_lo, dst_lo, GEN_INT (0xff00)));
+	  return;
+	}
+      if (need_copy)
+	{
+	  if (!signed_p && register_operand (dst_lo, HImode))
+	    emit_insn (gen_movqi_zero_extend (dst_lo, operands[1]));
+	  else
+	    emit_move_insn (dst_qi, operands[1]);
+	}
+      if (signed_p)
+	{
+	  emit_insn (gen_extendqi1 (dst_lo));
+	  if (dst_hi)
+	    {
+	      extended_value = copy_to_reg (dst_lo);
+	      emit_insn (gen_bswaphi1 (extended_value));
+	      emit_insn (gen_extendqi1 (extended_value));
+	    }
+	}
+      else
+	{
+	  if (memory_operand (operands[0], GET_MODE (operands[0])))
+	    emit_move_insn (gen_highpart (QImode, dst_lo), extended_value);
+	  else if (!need_copy)
+	    emit_insn (gen_andhi3 (dst_lo, dst_lo, GEN_INT (0xff)));
+	}
+    }
+  else if (HImode == GET_MODE (operands[1]))
+    {
+      if (need_copy)
+	emit_move_insn (dst_lo, operands[1]);
+      if (signed_p)
+	{
+	  extended_value = gen_reg_rtx (HImode);
+	  emit_move_insn (extended_value,
+			  gen_rtx_ASHIFTRT (HImode, dst_lo,
+					    GEN_INT (GET_MODE_BITSIZE (HImode)
+						     - 1)));
+	}
+    }
+  else if (SImode == GET_MODE (operands[1]))
+    {
+      if (need_copy)
+	emit_move_insn (gen_lowpart (SImode, operands[0]), operands[1]);
+      if (signed_p)
+	{
+	  extended_value = gen_reg_rtx (HImode);
+	  emit_move_insn (extended_value,
+			  gen_rtx_ASHIFTRT (HImode, dst_hi,
+					    GEN_INT (GET_MODE_BITSIZE (HImode)
+						     - 1)));
+	}
+      dst_hi = NULL_RTX;
+    }
+  else
+    gcc_unreachable ();
+  if (dst_hi)
+    emit_move_insn (dst_hi, extended_value);
+  if (dst_hlo)
+    {
+      emit_move_insn (dst_hlo, extended_value);
+      emit_move_insn (dst_hhi, extended_value);
+    }
+}
+
+/***** SIGN EXTEND *********/
+
+/* Expand all (signed) extendmn2 instructions.  Return 1 if all
+   necessary instructions have been emited; returns 0 to fall through
+   and generate extendqihi2_match. */
+void
+msp430_expand_signextend (rtx operands[])
+{
+  msp430_expand_extend (operands, true);
+}
+
+/**** ZERO EXTEND *****/
+
+/* Expand all zero_extendmn2 instructions. */
+void
+msp430_expand_zeroextend (rtx operands[])
+{
+  msp430_expand_extend (operands, false);
+}
+
+/******************* TESTS AND JUMPS *********************/
+
+
+/*****************  AUXES FOR TESTS *********************/
+
+RTX_CODE
+followed_compare_condition (rtx insn)
+{
+  rtx next = next_real_insn (insn);
+  RTX_CODE cond = UNKNOWN;
+
+  if (next && GET_CODE (next) == JUMP_INSN)
+    {
+      rtx pat = PATTERN (next);
+      rtx src, t;
+
+      if (pat && GET_CODE (pat) == PARALLEL)
+	pat = XVECEXP (pat, 0, 0);
+
+      if (!pat || GET_CODE (pat) != SET)
+	return UNKNOWN;
+
+      src = SET_SRC (pat);
+      t = XEXP (src, 0);
+      cond = GET_CODE (t);
+    }
+  else if (next && GET_CODE (next) == INSN)
+    {
+      /* here, two possible : sgeu ans sltu */
+
+      rtx pat = PATTERN (next);
+      rtx src;
+
+      if (!pat || GET_CODE (pat) != SET)
+	return UNKNOWN;
+
+      src = SET_SRC (pat);
+      cond = GET_CODE (src);	/* this must be IF_THEN_ELSE */
+      if (cond != IF_THEN_ELSE)
+	return UNKNOWN;
+    }
+  return cond;
+}
+
+
+/* SHIFT GUARDS */
+int
+msp430_ashlhi3 (rtx operands[])
+{
+  int x;
+  rtx set, shift;
+  rtx dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (HImode, operands[0]);
+      op1 = force_reg (HImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashlhi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x > 15 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x < 3)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+      while (x--)
+	emit_insn (set);
+      return 1;
+    }
+
+  if (x == 15)
+    {
+      shift = gen_rtx_ASHIFT (HImode, operands[1], GEN_INT (15));
+      set = gen_rtx_SET (HImode, operands[0], shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (HImode, operands[1]);
+  else
+    dst = operands[1];
+  if (x > 7)
+    {
+      emit_insn (gen_andhi3 (dst, dst, GEN_INT (0xff)));
+      emit_insn (gen_bswaphi1 (dst));
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFT (HImode, dst, const1_rtx);
+  set = gen_rtx_SET (HImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+int
+msp430_ashlsi3 (rtx operands[])
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (SImode, operands[0]);
+      op1 = force_reg (SImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashlsi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x >= 32 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x == 1)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFT (SImode, dst, operands[2]);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (SImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x == 31)
+    {
+      shift = gen_rtx_ASHIFT (SImode, operands[1], GEN_INT (31));
+      set = gen_rtx_SET (SImode, operands[0], shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x >= 16)
+    {
+      rtx dhi = gen_highpart (HImode, operands[0]);
+      rtx dlo = gen_lowpart (HImode, operands[0]);
+#if 0				/* CHECK unused?? */
+      rtx shi = gen_highpart (HImode, operands[1]);
+#endif /* CHECK */
+      rtx slo = gen_lowpart (HImode, operands[1]);
+
+      emit_move_insn (dhi, slo);
+      emit_move_insn (dlo, const0_rtx);
+      x -= 16;
+      if (x)
+	{
+	  rtx ops[3];
+	  ops[0] = dhi;
+	  ops[1] = dhi;
+	  ops[2] = GEN_INT (x);
+	  msp430_ashlhi3 (ops);
+	}
+      return 1;
+    }
+
+  if (x >= 8)
+    {
+      shift = gen_rtx_ASHIFT (SImode, dst, GEN_INT (8));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFT (SImode, dst, GEN_INT (1));
+  set = gen_rtx_SET (SImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+/* arithmetic right */
+int
+msp430_ashrhi3 (rtx operands[])
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (HImode, operands[0]);
+      op1 = force_reg (HImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashrhi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+  if (x >= 15 || x < 0)
+    {
+      dst = gen_lowpart (QImode, operands[0]);
+      emit_move_insn (operands[0], operands[1]);
+      emit_insn (gen_bswaphi1 (operands[0]));
+      emit_insn (gen_extendqi1 (operands[0]));
+      emit_insn (gen_bswaphi1 (operands[0]));
+      emit_insn (gen_extendqi1 (operands[0]));
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x < 3)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+
+      while (x--)
+	emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (HImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 8)
+    {
+      emit_insn (gen_bswaphi1 (dst));
+      emit_insn (gen_extendqi1 (dst));
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+  set = gen_rtx_SET (HImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+
+  emit_move_insn (operands[0], dst);
+
+  return 1;
+}
+
+int
+msp430_ashrsi3 (rtx operands[])
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (SImode, operands[0]);
+      op1 = force_reg (SImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashrsi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (SImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 31 || x < 0)
+    {
+
+      shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (31));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+
+      if (dst != operands[0])
+	emit_move_insn (operands[0], dst);
+      return 1;
+    }
+
+  if (x == 1)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFTRT (SImode, dst, operands[2]);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x >= 16)
+    {
+      rtx dlo = gen_lowpart (HImode, operands[0]);
+
+      emit_insn (gen_extendhisi2 (operands[0], gen_highpart (HImode, dst)));
+      x -= 16;
+      if (x)
+	{
+	  rtx ops[3];
+	  ops[0] = dlo;
+	  ops[1] = dlo;
+	  ops[2] = GEN_INT (x);
+	  msp430_ashrhi3 (ops);
+	}
+      return 1;
+    }
+
+  if (x >= 8)
+    {
+      shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (8));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (1));
+  set = gen_rtx_SET (SImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+/* logical right */
+int
+msp430_lshrhi3 (rtx operands[])
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (HImode, operands[0]);
+      op1 = force_reg (HImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_lshrhi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+  if (x > 15 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x < 3)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_LSHIFTRT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+      emit_insn (set);
+      x--;
+
+      if (x)
+	{
+	  shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+	  set = gen_rtx_SET (HImode, dst, shift);
+	  emit_insn (set);
+	}
+      return 1;
+    }
+
+  if (x == 15)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_LSHIFTRT (HImode, dst, GEN_INT (15));
+      set = gen_rtx_SET (HImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (HImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 8)
+    {
+      rtx dlo;
+      emit_insn (gen_bswaphi1 (dst));
+      dlo = gen_lowpart (QImode, dst);
+      emit_insn (gen_zero_extendqihi2 (dst, dlo));
+      x -= 8;
+    }
+
+  if (x)
+    {
+      shift = gen_rtx_LSHIFTRT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+      x--;
+      emit_insn (set);
+    }
+  shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+  set = gen_rtx_SET (HImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+
+  return 1;
+}
+
+int
+msp430_lshrsi3 (rtx operands[])
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (SImode, operands[0]);
+      op1 = force_reg (SImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_lshrsi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x == 1)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_LSHIFTRT (SImode, dst, operands[2]);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x > 31 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (SImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 16)
+    {
+      rtx dlo = gen_lowpart (HImode, operands[0]);
+
+      emit_insn (gen_zero_extendhisi2
+		 (operands[0], gen_highpart (HImode, dst)));
+      x -= 16;
+      if (x)
+	{
+	  rtx ops[3];
+	  ops[0] = dlo;
+	  ops[1] = dlo;
+	  ops[2] = GEN_INT (x);
+	  msp430_lshrhi3 (ops);
+	}
+      return 1;
+    }
+
+  if (x >= 8)
+    {
+      shift = gen_rtx_LSHIFTRT (SImode, dst, GEN_INT (8));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x -= 8;
+    }
+
+  if (x)
+    {
+      shift = gen_rtx_LSHIFTRT (SImode, dst, const1_rtx);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x--;
+    }
+
+  shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (1));
+  set = gen_rtx_SET (SImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+/******* COMMON SHIFT CODE ***************/
+int
+is_shift_better_in_reg (rtx operands[])
+{
+  rtx x = operands[0];
+  rtx cnt = operands[2];
+  int size = GET_MODE_SIZE (x->mode);
+  int icnt = -1;
+  int r = 0;
+
+  if (!optimize)
+    return 0;
+
+  if (GET_CODE (cnt) == CONST_INT)
+    icnt = INTVAL (cnt);
+  else
+    return 1;
+
+  switch (size)
+    {
+    case 1:
+      if (icnt != 1 && icnt != 2 && icnt != 7)
+	r = 1;
+      break;
+    case 2:
+      if (icnt != 1 && icnt != 2 && icnt != 8 && icnt != 15)
+	r = 2;
+      break;
+    case 4:
+      if (icnt != 1
+	  && icnt != 2 && icnt != 8 && icnt != 16 && icnt != 24 && icnt != 31)
+	r = 4;
+      break;
+    case 8:
+      if (icnt != 1
+	  && icnt != 2 && icnt != 16 && icnt != 32 && icnt != 48
+	  && icnt != 63)
+	r = 8;
+      break;
+    }
+
+  return r;
+}
+
+
+#define INST_THRESHOLD  16
+
+static int
+msp430_emit_shift_cnt (const char *pattern,
+		       rtx insn ATTRIBUTE_UNUSED, rtx operands[])
+{
+  output_asm_insn ("tst\t%2", operands);
+  output_asm_insn ("jz\t.Lsend%=\n.Lsst%=:", operands);
+  output_asm_insn (pattern, operands);
+  output_asm_insn ("dec\t%2", operands);
+  output_asm_insn ("jnz\t.Lsst%=\n.Lsend%=:", operands);
+  return 0;
+}
+
+
+/* <<<<<<<<<<<<< SHIFT LEFT CODE <<<<<<<<<<<<<<<<<     */
+
+const char *
+msp430_emit_ashlqi3 (rtx insn, rtx operands[])
+{
+  int zs = zero_shifted (operands[0])
+    || msp430_indirect_register_operand (operands[0]);
+  const char *pattern;
+  int shiftpos;
+
+  if (zs)
+    pattern = "rla.b\t@%E0";
+  else
+    pattern = "rla.b\t%A0";
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    default:
+      if (zs)
+	output_asm_insn ("clr.b\t@%E0", operands);
+      else
+	output_asm_insn ("clr.b\t%A0", operands);
+      break;
+
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 7:
+      output_asm_insn ("rra.b\t%0", operands);
+      output_asm_insn ("clr.b\t%0", operands);
+      output_asm_insn ("rrc.b\t%0", operands);
+      break;
+    }
+
+  return "";
+}
+
+
+const char *
+msp430_emit_ashlhi3 (rtx insn, rtx operands[])
+{
+  int zs;
+  const char *pattern;
+  int shiftpos;
+
+  zs = zero_shifted (operands[0])
+    || msp430_indirect_register_operand (operands[0]);
+
+  if (zs)
+    pattern = "rla\t@%E0";
+  else
+    pattern = "rla\t%A0";
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+      if (zs)
+	{
+	  output_asm_insn ("and.b\t#0xffff, %A0", operands);
+	  output_asm_insn ("swpb\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("and.b\t#0xffff, %A0", operands);
+	  output_asm_insn ("swpb\t%A0", operands);
+	}
+
+
+      shiftpos -= 8;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 15:
+      output_asm_insn ("rra\t%0", operands);
+      output_asm_insn ("clr\t%0", operands);
+      output_asm_insn ("rrc\t%0", operands);
+      break;
+
+    default:
+      output_asm_insn ("clr\t%A0", operands);
+      break;
+    }
+
+  return "";
+}
+
+
+const char *
+msp430_emit_ashlsi3 (rtx insn, rtx operands[])
+{
+
+  int zs;
+  const char *pattern;
+  int shiftpos;
+
+  zs = zero_shifted (operands[0]);
+
+  if (zs)
+    pattern = "add\t@%E0+, -2(%E0)\n\taddc\t@%E0+, -2(%E0)\n\tsub\t#4, %E0";
+  else
+    pattern = "rla\t%A0\n\trlc\t%B0";
+
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+
+      if (zs || msp430_indirect_register_operand (operands[0]))
+	{
+	  output_asm_insn ("xor.b\t@%E0, %B0", operands);
+	  output_asm_insn ("xor\t@%E0, %B0", operands);
+	  output_asm_insn ("swpb\t%B0", operands);
+	  output_asm_insn ("and.b\t#-1, %A0", operands);
+	  output_asm_insn ("swpb\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("xor.b\t%A0, %B0", operands);
+	  output_asm_insn ("xor\t%A0, %B0", operands);
+	  output_asm_insn ("swpb\t%B0", operands);
+	  output_asm_insn ("and.b\t#-1, %A0", operands);
+	  output_asm_insn ("swpb\t%A0", operands);
+	}
+
+      shiftpos -= 8;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+
+      if (zs || msp430_indirect_register_operand (operands[0]))
+	{
+	  output_asm_insn ("mov\t@%E0, %B0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov\t%A0, %B0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	}
+
+      shiftpos -= 16;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+      if (zs || msp430_indirect_register_operand (operands[0]))
+	{
+	  output_asm_insn ("mov.b\t@%E0,%B0", operands);
+	  output_asm_insn ("swpb\t%B0", operands);
+	  output_asm_insn ("clr\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov.b\t%A0,%B0", operands);
+	  output_asm_insn ("swpb\t%B0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	}
+
+      shiftpos -= 24;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 31:
+      if (zs || msp430_indirect_register_operand (operands[0]))
+	{
+	  output_asm_insn ("rra\t@%E0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	  output_asm_insn ("rrc\t%B0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("rra\t%A0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	  output_asm_insn ("rrc\t%B0", operands);
+	}
+
+      break;
+
+    default:
+      output_asm_insn ("clr\t%A0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      break;
+    }				/* switch */
+
+  return "";
+}
+
+const char *
+msp430_emit_ashldi3 (rtx insn, rtx operands[])
+{
+
+  int zs;
+  const char *pattern;
+  int shiftpos;
+
+  zs = zero_shifted (operands[0]);
+
+  if (zs)
+    pattern =
+      "add\t@%E0+,-2(%E0)\n\taddc\t@%E0+,-2(%E0)\n\taddc\t@%E0+,-2(%E0)\n\taddc\t@%E0+,-2(%E0)\n\tsub\t#8,%E0";
+  else
+    pattern = "rla\t%A0\n\trlc\t%B0\n\trlc\t%C0\n\trlc\t%D0";
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+    case 31:
+      if (zs || msp430_indirect_register_operand (operands[0]))
+	{
+	  output_asm_insn ("mov\t%C0, %D0", operands);
+	  output_asm_insn ("mov\t%B0, %C0", operands);
+	  output_asm_insn ("mov\t@%E0, %B0", operands);
+	  output_asm_insn ("clr\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov\t%C0, %D0", operands);
+	  output_asm_insn ("mov\t%B0, %C0", operands);
+	  output_asm_insn ("mov\t%A0, %B0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+
+	}
+      shiftpos -= 16;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 32:
+    case 33:
+    case 34:
+    case 35:
+    case 36:
+    case 37:
+    case 38:
+    case 39:
+    case 40:
+    case 41:
+    case 42:
+    case 43:
+    case 44:
+    case 45:
+    case 46:
+    case 47:
+      if (zs)
+	{
+	  output_asm_insn ("mov\t@%E0+, %C0", operands);
+	  output_asm_insn ("mov\t@%E0+, %D0", operands);
+	  output_asm_insn ("sub\t#4, %E0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov\t%A0, %C0", operands);
+	  output_asm_insn ("mov\t%B0, %D0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	}
+      shiftpos -= 32;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 48:
+    case 49:
+    case 50:
+    case 51:
+    case 52:
+    case 53:
+    case 54:
+    case 55:
+    case 56:
+    case 57:
+    case 58:
+    case 59:
+    case 60:
+    case 61:
+    case 62:
+      if (zs)
+	{
+	  output_asm_insn ("mov\t@%E0, %D0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	  output_asm_insn ("clr\t%C0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov\t%A0, %D0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	  output_asm_insn ("clr\t%C0", operands);
+	}
+
+      shiftpos -= 48;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 63:
+      if (zs || msp430_indirect_register_operand (operands[0]))
+	{
+	  output_asm_insn ("rra\t@%E0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	  output_asm_insn ("clr\t%C0", operands);
+	  output_asm_insn ("clr\t%D0", operands);
+	  output_asm_insn ("rrc\t%D0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("rra\t%A0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("clr\t%B0", operands);
+	  output_asm_insn ("clr\t%C0", operands);
+	  output_asm_insn ("clr\t%D0", operands);
+	  output_asm_insn ("rrc\t%D0", operands);
+	}
+
+      break;			/* make compiler happy */
+
+    default:
+      output_asm_insn ("clr\t%A0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      output_asm_insn ("clr\t%C0", operands);
+      output_asm_insn ("clr\t%D0", operands);
+    }				/* switch */
+
+  return "";
+}
+
+/********* SHIFT RIGHT CODE ***************************************/
+const char *
+msp430_emit_ashrqi3 (rtx insn, rtx operands[])
+{
+  int zs = zero_shifted (operands[0])
+    || msp430_indirect_register_operand (operands[0]);
+  const char *pattern;
+  int shiftpos;
+
+  if (zs)
+    pattern = "rra.b\t@%E0";
+  else
+    pattern = "rra.b\t%A0";
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 7:
+      if (zs)
+	{
+	  output_asm_insn ("sxt\t@%E0", operands);
+	  output_asm_insn ("swpb\t@%E0", operands);
+	  output_asm_insn ("and.b\t#-1, %A0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("sxt\t%A0", operands);
+	  output_asm_insn ("swpb\t%A0", operands);
+	  output_asm_insn ("and.b\t#-1, %A0", operands);
+	}
+
+      break;
+
+    default:
+      output_asm_insn ("clr.b\t%A0", operands);
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_ashrhi3 (rtx insn, rtx operands[])
+{
+  int zs = zero_shifted (operands[0])
+    || msp430_indirect_register_operand (operands[0]);
+  const char *pattern;
+  int shiftpos;
+
+  if (zs)
+    pattern = "rra\t@%E0";
+  else
+    pattern = "rra\t%A0";
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+      if (zs)
+	{
+	  output_asm_insn ("swpb\t@%E0", operands);
+	  output_asm_insn ("sxt\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("swpb\t%A0", operands);
+	  output_asm_insn ("sxt\t%A0", operands);
+	}
+      shiftpos -= 8;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+
+      break;
+
+    case 15:
+      if (zs)
+	{
+	  output_asm_insn ("swpb\t@%E0", operands);
+	  output_asm_insn ("sxt\t@%E0", operands);
+	  output_asm_insn ("swpb\t@%E0", operands);
+	  output_asm_insn ("swpb\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("swpb\t%A0", operands);
+	  output_asm_insn ("sxt\t%A0", operands);
+	  output_asm_insn ("swpb\t%A0", operands);
+	  output_asm_insn ("sxt\t%A0", operands);
+	}
+      break;
+
+    default:
+      output_asm_insn ("clr\t%A0", operands);
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_ashrsi3 (rtx insn, rtx operands[])
+{
+
+  const char *pattern = "rra\t%B0\n\trrc\t%A0";
+  int shiftpos;
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+      output_asm_insn ("swpb\t%A0", operands);
+      output_asm_insn ("swpb\t%B0", operands);
+      output_asm_insn ("xor.b\t%B0, %A0", operands);
+      output_asm_insn ("xor\t%B0, %A0", operands);
+      output_asm_insn ("sxt\t%B0", operands);
+
+      shiftpos -= 8;
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+      output_asm_insn ("mov\t%B0, %A0", operands);
+      output_asm_insn ("bit\t#0x8000, %B0", operands);
+      output_asm_insn ("jz\t.Lsrc%=", operands);
+      output_asm_insn ("bis\t#0xffff, %B0", operands);
+      output_asm_insn ("jmp\t.Lsre%=\n.Lsrc%=:", operands);
+      output_asm_insn ("clr\t%B0\n.Lsre%=:", operands);
+
+      shiftpos -= 16;
+      while (shiftpos--)
+	output_asm_insn ("rra\t%A0", operands);
+      break;
+
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+      output_asm_insn ("swpb\t%B0", operands);
+      output_asm_insn ("sxt\t%B0", operands);
+      output_asm_insn ("mov\t%B0, %A0", operands);
+      output_asm_insn ("swpb\t%B0", operands);
+      output_asm_insn ("sxt\t%B0", operands);
+
+      shiftpos -= 24;
+      while (shiftpos--)
+	output_asm_insn ("rra\t%A0", operands);
+      break;
+
+    case 31:
+      output_asm_insn ("tst\t%B0", operands);
+      output_asm_insn ("mov\t#-1,%B0", operands);
+      output_asm_insn ("mov\t#-1,%A0", operands);
+      if (GET_CODE (operands[0]) == REG)
+	output_asm_insn ("jn\t+4", operands);
+      else
+	output_asm_insn ("jn\t+8", operands);
+      output_asm_insn ("clr\t%A0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      break;
+
+    default:
+      break;
+    }				/* switch */
+
+  return "";
+}
+
+const char *
+msp430_emit_ashrdi3 (rtx insn, rtx operands[])
+{
+  const char *pattern = "rra\t%D0\n\trrc\t%C0\n\trrc\t%B0\n\trrc\t%A0";
+  int shiftpos;
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+      while (shiftpos--)
+	output_asm_insn (pattern, operands);
+      break;
+
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+    case 31:
+
+      output_asm_insn ("mov\t%B0, %A0", operands);
+      output_asm_insn ("mov\t%C0, %B0", operands);
+      output_asm_insn ("mov\t%D0, %C0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+
+      shiftpos -= 16;
+      while (shiftpos--)
+	output_asm_insn ("rra\t%C0\n\trrc\t%B0\n\trrc\t%A0", operands);
+
+      break;
+
+    case 32:
+    case 33:
+    case 34:
+    case 35:
+    case 36:
+    case 37:
+    case 38:
+    case 39:
+    case 40:
+    case 41:
+    case 42:
+    case 43:
+    case 44:
+    case 45:
+    case 46:
+    case 47:
+      output_asm_insn ("mov\t%C0, %A0", operands);
+      output_asm_insn ("mov\t%D0, %B0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("mov\t%D0, %C0", operands);
+      shiftpos -= 32;
+      while (shiftpos--)
+	output_asm_insn ("rra\t%B0\n\trrc\t%A0", operands);
+      break;
+
+    case 48:
+    case 49:
+    case 50:
+    case 51:
+    case 52:
+    case 53:
+    case 54:
+    case 55:
+    case 56:
+    case 57:
+    case 58:
+    case 59:
+    case 60:
+    case 61:
+    case 62:
+      output_asm_insn ("mov\t%D0, %A0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("mov\t%D0, %C0", operands);
+      output_asm_insn ("mov\t%D0, %B0", operands);
+      shiftpos -= 48;
+      while (shiftpos--)
+	output_asm_insn ("rra\t%A0", operands);
+      break;
+
+    case 63:
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("swpb\t%D0", operands);
+      output_asm_insn ("sxt\t%D0", operands);
+      output_asm_insn ("mov\t%D0, %C0", operands);
+      output_asm_insn ("mov\t%D0, %B0", operands);
+      output_asm_insn ("mov\t%D0, %A0", operands);
+      break;
+
+    default:
+      break;
+    }				/* case */
+
+  return "";
+}
+
+/********* LOGICAL SHIFT RIGHT CODE ***************************************/
+const char *
+msp430_emit_lshrqi3 (rtx insn, rtx operands[])
+{
+  int zs = zero_shifted (operands[0])
+    || msp430_indirect_register_operand (operands[0]);
+  const char *pattern;
+  const char *second_pat;
+  int shiftpos;
+
+  if (zs)
+    {
+      pattern = "clrc\n\trrc.b\t@%E0";
+      second_pat = "rra.b\t@%E0";
+    }
+  else
+    {
+      pattern = "clrc\n\trrc.b\t%A0";
+      second_pat = "rra.b\t%A0";
+    }
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  if (shiftpos != 7 && shiftpos)
+    {
+      output_asm_insn (pattern, operands);
+      shiftpos--;
+    }
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+      while (shiftpos--)
+	output_asm_insn (second_pat, operands);
+
+      break;
+
+    case 7:
+      if (zs)
+	{
+	  output_asm_insn ("rla.b\t@%E0", operands);
+	  output_asm_insn ("clr.b\t%A0", operands);
+	  output_asm_insn ("rlc.b\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("rla.b\t%A0", operands);
+	  output_asm_insn ("clr.b\t%A0", operands);
+	  output_asm_insn ("rlc.b\t%A0", operands);
+	}
+      break;
+
+    default:
+      output_asm_insn ("clr.b\t%A0", operands);
+      break;
+    }
+  return "";
+}
+
+const char *
+msp430_emit_lshrhi3 (rtx insn, rtx operands[])
+{
+  int zs = zero_shifted (operands[0])
+    || msp430_indirect_register_operand (operands[0]);
+  const char *pattern;
+  const char *second_pat;
+  int shiftpos;
+
+  if (zs)
+    {
+      pattern = "clrc\n\trrc\t@%E0";
+      second_pat = "rra\t@%E0";
+    }
+  else
+    {
+      pattern = "clrc\n\trrc\t%A0";
+      second_pat = "rra\t%A0";
+    }
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  if (shiftpos < 8 && shiftpos)
+    {
+      output_asm_insn (pattern, operands);
+      shiftpos--;
+    }
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      while (shiftpos--)
+	output_asm_insn (second_pat, operands);
+      break;
+
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+
+      if (zs)
+	{
+	  output_asm_insn ("swpb\t@%E0", operands);
+	  output_asm_insn ("and.b\t#-1, %A0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("swpb\t%A0", operands);
+	  output_asm_insn ("and.b\t#-1, %A0", operands);
+	}
+      shiftpos -= 8;
+      while (shiftpos--)
+	output_asm_insn (second_pat, operands);
+      break;
+
+    case 15:
+      if (zs)
+	{
+	  output_asm_insn ("rla\t@%E0", operands);
+	  output_asm_insn ("clr\t@%E0", operands);
+	  output_asm_insn ("rlc\t@%E0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("rla\t%A0", operands);
+	  output_asm_insn ("clr\t%A0", operands);
+	  output_asm_insn ("rlc\t%A0", operands);
+	}
+      break;
+
+    default:
+      output_asm_insn ("clr\t%A0", operands);
+      break;
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_lshrsi3 (rtx insn, rtx operands[])
+{
+  const char *pattern = "clrc\n\trrc\t%B0\n\trrc\t%A0";
+  const char *second_pat = "rra\t%B0\n\trrc\t%A0";
+  int shiftpos;
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  if (shiftpos < 8 && shiftpos)
+    {
+      output_asm_insn (pattern, operands);
+      shiftpos--;
+    }
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+      while (shiftpos--)
+	output_asm_insn (second_pat, operands);
+      break;
+
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+      output_asm_insn ("swpb\t%A0", operands);
+      output_asm_insn ("swpb\t%B0", operands);
+      output_asm_insn ("xor.b\t%B0, %A0", operands);
+      output_asm_insn ("xor\t%B0, %A0", operands);
+      output_asm_insn ("and.b\t#-1, %B0", operands);
+
+      shiftpos -= 8;
+      while (shiftpos--)
+	output_asm_insn (second_pat, operands);
+      break;
+
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+      output_asm_insn ("mov\t%B0, %A0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+
+      shiftpos -= 16;
+      if (shiftpos)
+	{
+	  output_asm_insn ("clrc\n\trrc\t%A0", operands);
+	  shiftpos--;
+	}
+
+      while (shiftpos--)
+	output_asm_insn ("rra\t%A0", operands);
+      break;
+
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+      output_asm_insn ("mov\t%B0, %A0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      output_asm_insn ("swpb\t%A0", operands);
+      output_asm_insn ("and.b\t#-1, %A0", operands);
+      shiftpos -= 24;
+
+      while (shiftpos--)
+	output_asm_insn ("rra\t%A0", operands);
+      break;
+
+    case 31:
+      output_asm_insn ("rla\r%B0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      output_asm_insn ("clr\t%A0", operands);
+      output_asm_insn ("rlc\t%A0", operands);
+      break;
+
+    default:
+      output_asm_insn ("clr\t%B0", operands);
+      output_asm_insn ("clr\t%A0", operands);
+      break;
+
+    }				/* switch */
+
+  return "";
+}
+
+const char *
+msp430_emit_lshrdi3 (rtx insn, rtx operands[])
+{
+  const char *pattern =
+    "clrc\n\trrc\t%D0\n\trrc\t%C0\n\trrc\t%B0\n\trrc\t%A0";
+  const char *secondary_pat = "rra\t%D0\n\trrc\t%C0\n\trrc\t%B0\n\trrc\t%A0";
+  int shiftpos;
+
+  if (GET_CODE (operands[2]) != CONST_INT)
+    {
+      msp430_emit_shift_cnt (pattern, insn, operands);
+      return "";
+    }
+
+  shiftpos = INTVAL (operands[2]);
+
+  if (shiftpos < 16 && shiftpos)
+    {
+      output_asm_insn (pattern, operands);
+      shiftpos--;
+    }
+
+  switch (shiftpos)
+    {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+      while (shiftpos--)
+	output_asm_insn (secondary_pat, operands);
+      break;
+
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+    case 31:
+      output_asm_insn ("mov\t%B0, %A0", operands);
+      output_asm_insn ("mov\t%C0, %B0", operands);
+      output_asm_insn ("mov\t%D0, %C0", operands);
+      output_asm_insn ("clr\t%D0", operands);
+      shiftpos -= 16;
+
+      if (shiftpos)
+	{
+	  output_asm_insn (secondary_pat, operands);
+	  shiftpos--;
+	}
+
+      while (shiftpos--)
+	output_asm_insn ("rra\t%C0\n\trrc\t%B0\n\trrc\t%A0", operands);
+
+      break;
+
+    case 32:
+    case 33:
+    case 34:
+    case 35:
+    case 36:
+    case 37:
+    case 38:
+    case 39:
+    case 40:
+    case 41:
+    case 42:
+    case 43:
+    case 44:
+    case 45:
+    case 46:
+    case 47:
+      output_asm_insn ("mov\t%C0, %A0", operands);
+      output_asm_insn ("mov\t%D0, %B0", operands);
+      output_asm_insn ("clr\t%C0", operands);
+      output_asm_insn ("clr\t%D0", operands);
+
+      shiftpos -= 32;
+
+      if (shiftpos)
+	{
+	  output_asm_insn ("clrc\n\trrc\t%B0\n\trrc\t%A0", operands);
+	  shiftpos--;
+	}
+
+      while (shiftpos--)
+	output_asm_insn ("rra\t%B0\n\trrc\t%A0", operands);
+
+      break;
+
+    case 48:
+    case 49:
+    case 50:
+    case 51:
+    case 52:
+    case 53:
+    case 54:
+    case 55:
+    case 56:
+    case 57:
+    case 58:
+    case 59:
+    case 60:
+    case 61:
+    case 62:
+      output_asm_insn ("mov\t%D0, %A0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      output_asm_insn ("clr\t%C0", operands);
+      output_asm_insn ("clr\t%D0", operands);
+      shiftpos -= 48;
+
+      if (shiftpos)
+	{
+	  output_asm_insn ("clrc\n\trrc\t%A0", operands);
+	  shiftpos--;
+	}
+
+      while (shiftpos--)
+	output_asm_insn ("rra\t%A0", operands);
+
+      break;
+
+    case 63:
+
+      output_asm_insn ("rla\t%D0", operands);
+      output_asm_insn ("clr\t%D0", operands);
+      output_asm_insn ("clr\t%C0", operands);
+      output_asm_insn ("clr\t%B0", operands);
+      output_asm_insn ("clr\t%A0", operands);
+      output_asm_insn ("rlc\t%A0", operands);
+      break;
+
+    default:
+      break;
+    }				/* case */
+  return "";
+}
+
+/*
+*	Multiplication helpers
+*	1. As shifts, 2. the rest 
+*/
+
+#define SOME_SHIFT_THRESHOLD_VAL 	10
+
+static int
+msp430_easy_mul (rtx operands[], int sext)
+{
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx insn;
+  int m = INTVAL (operands[2]);
+  int sign = (m < 0);
+  int val = (m > 0 ? m : -m);
+  int shift1 = 0, shift0 = 0;
+  int add1 = 0, sub1 = 0;
+  int t0, t1;
+  int ops = 0;
+
+  m = val;
+  /* 
+     we can do: 
+     const == single bit const +- N that (shift0 + add1/sub1 < 8 instructions) 
+   */
+  shift0 = 1;
+  shift1 = 0;
+
+  for (t0 = 2;
+       t0 <= val * 2 && shift0 < GET_MODE_SIZE (op0mode) * BITS_PER_UNIT;
+       t0 <<= 1)
+    {
+      if (t0 == val)
+	goto done;
+
+      for (t1 = 1;
+	   t1 < t0 && shift1 < GET_MODE_SIZE (op1mode) * BITS_PER_UNIT;
+	   t1 <<= 1)
+	{
+	  add1 = 0;
+	  sub1 = 0;
+	  if (t0 + t1 == m)
+	    {
+	      add1 = 1;
+	      goto done;
+	    }
+	  if (t0 - t1 == m)
+	    {
+	      sub1 = 1;
+	      goto done;
+	    }
+
+	  if (t0 + t1 * 3 == m)
+	    {
+	      add1 = 3;
+	      goto done;
+	    }
+
+	  if (t0 - t1 * 3 == m)
+	    {
+	      sub1 = 3;
+	      goto done;
+	    }
+
+	  add1 = 0;
+	  sub1 = 0;
+	  shift1++;
+
+	}
+      shift1 = 0;
+      shift0++;
+    }
+
+  return 0;
+done:
+
+  ops = shift0 * (op0mode == SImode ? 2 : 1);
+  ops += shift1 + add1 + sub1;
+  if (op0mode != op1mode)
+    ops += (op0mode == SImode ? 2 : 1) * ((add1 || sub1) ? 2 : 1);
+
+  if (ops > SOME_SHIFT_THRESHOLD_VAL)
+    return 0;
+
+  if (op0mode != op1mode)
+    {
+      rtx extend_ops[2];
+      rtx op1x = gen_reg_rtx (op0mode);
+      extend_ops[0] = op1x;
+      extend_ops[1] = op1;
+      msp430_expand_extend (extend_ops, sext);
+      op1 = op1x;
+      op1mode = GET_MODE (op1);
+    }
+  emit_move_insn (op0, op1);
+
+  /* shift0 */
+  switch (op0mode)
+    {
+    case QImode:
+      emit_insn (gen_ashlqi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    case HImode:
+      emit_insn (gen_ashlhi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    case SImode:
+      emit_insn (gen_ashlsi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    case DImode:
+      emit_insn (gen_ashldi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  if (add1 || sub1 || shift1)
+    {
+      rtx treg = gen_reg_rtx (op0mode);
+      emit_move_insn (treg, op1);
+      op1 = treg;
+    }
+
+  if (shift1 && (add1 || sub1))
+    {
+      switch (op1mode)
+	{
+	case QImode:
+	  emit_insn (gen_ashlqi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	case HImode:
+	  emit_insn (gen_ashlhi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	case SImode:
+	  emit_insn (gen_ashlsi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	case DImode:
+	  emit_insn (gen_ashldi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+    }
+  else if (shift1)
+    gcc_unreachable ();			/* paranoia */
+
+  while (add1--)
+    {
+      insn =
+	gen_rtx_SET (VOIDmode, op0, gen_rtx_PLUS (GET_MODE (op0), op0, op1));
+      emit_insn (insn);
+    }
+
+  while (sub1--)
+    {
+      insn =
+	gen_rtx_SET (VOIDmode, op0, gen_rtx_MINUS (GET_MODE (op0), op0, op1));
+      emit_insn (insn);
+    }
+
+  if (sign)
+    {
+      switch (op0mode)
+	{
+	case QImode:
+	  emit_insn (gen_negqi2 (op0, op0));
+	  break;
+	case HImode:
+	  emit_insn (gen_neghi2 (op0, op0));
+	  break;
+	case SImode:
+	  emit_insn (gen_negsi2 (op0, op0));
+	  break;
+	case DImode:
+	  emit_insn (gen_negdi2 (op0, op0));
+	  break;
+	default:
+	  gcc_unreachable ();
+	}
+    }
+
+  return 1;
+}
+
+int
+msp430_expand_mul (rtx operands[], int signed_mul)
+{
+  rtx m_mpy;
+  rtx m_op2;
+  rtx m_reslo;
+  int required_mpy;
+  bool widen;
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  enum machine_mode op2mode = GET_MODE (operands[2]);
+
+  gcc_assert ((op1mode == op2mode) || CONST_INT_P (operands[2]));
+  op2mode = op1mode;
+  widen = (op0mode == GET_MODE_WIDER_MODE (op1mode));
+  gcc_assert (widen || op0mode == op1mode);
+
+  if (CONST_INT_P (operands[2]) && msp430_easy_mul (operands, signed_mul))
+    return 1;
+
+  required_mpy = 0;
+  switch (op0mode)
+    {
+    case QImode:
+      required_mpy = MSP430_MPY_TYPE_16;
+      break;
+    case HImode:
+      required_mpy = MSP430_MPY_TYPE_16;
+      break;
+    case SImode:
+      required_mpy = widen ? MSP430_MPY_TYPE_16 : MSP430_MPY_TYPE_32;
+      break;
+    case DImode:
+      required_mpy = widen ? MSP430_MPY_TYPE_32 : MSP430_MPY_NONE;
+      break;
+    default:
+      required_mpy = MSP430_MPY_NONE;
+      break;
+    }
+  
+  if (!(msp430_mpy & required_mpy))
+    {
+      const char* libfn;
+      rtx r_op1 = gen_rtx_REG (op1mode, 10);
+      rtx r_op2 = gen_rtx_REG (op2mode, 12);
+      rtx r_res = gen_rtx_REG (op0mode, 14);
+
+      switch (op0mode)
+	{
+	case QImode:
+	  libfn = "__mulqi3";
+	  break;
+	case HImode:
+	  libfn = widen ? (signed_mul ? "__mulqihi3" : "__umulqihi3") : "__mulhi3";
+	  break;
+	case SImode:
+	  libfn = widen ? (signed_mul ? "__mulhisi3" : "__umulhisi3") : "__mulsi3";
+	  break;
+	case DImode:
+	  libfn = widen ? (signed_mul ? "__mulsidi3" : "__umulsidi3") : "__muldi3";
+	  r_op1 = gen_rtx_REG (op1mode, 8);
+	  r_op2 = gen_rtx_REG (op2mode, 4);
+	  r_res = gen_rtx_REG (op0mode, 12);
+	  break;
+	default:
+	  gcc_unreachable();
+	}
+
+      /* Widening operations are done in the library routine prologues */
+      emit_move_insn (r_op1, operands[1]);
+      emit_move_insn (r_op2, operands[2]);
+
+      emit_use (r_op1);
+      emit_use (r_op2);
+      emit_call_insn (gen_call (gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, libfn)), const0_rtx));
+
+      if (DImode == GET_MODE (operands[0]))
+	{
+	  int rn;
+	  for (rn = 4; rn < 12; ++rn)
+	    emit_clobber (gen_rtx_REG (HImode, rn));
+	}
+      else
+	{
+	  /* r12-r15 are call clobbered, but need to note that r10
+	   * (and r11 if r10 was widened) are also clobbered. */
+	  emit_clobber (r_op1);
+	  if (widen && QImode != op1mode)
+	    emit_clobber (gen_rtx_REG (op1mode, 1 + REGNO (r_op1)));
+	}
+      
+      emit_move_insn (operands[0], r_res);
+      return 1;
+    }
+
+  if (!MSP430_NOINT_HWMUL)
+    emit_insn (gen_mpy_inhibit_intr ());
+
+  if (MSP430_MPY_TYPE_16 == required_mpy)
+    {
+      m_mpy = signed_mul ? mpys_rtx : mpy_rtx;
+      m_op2 = op2_rtx;
+      m_reslo = reslo_rtx;
+      if (op0mode == QImode)
+	m_reslo = reslo_b_rtx;
+      if (op1mode == QImode)
+	m_mpy = signed_mul ? mpys_b_rtx : mpy_b_rtx;
+      if (op2mode == QImode)
+	m_op2 = op2_b_rtx;
+
+      emit_move_insn (m_mpy, operands[1]);
+      if (op1mode == QImode && signed_mul && !(msp430_mpy & MSP430_MPY_HAS_SE))
+	emit_insn (gen_extendqihi2 (signed_mul ? mpys_rtx : mpy_rtx, m_mpy));
+      emit_move_insn (m_op2, operands[2]);
+      if (op2mode == QImode && signed_mul && !(msp430_mpy & MSP430_MPY_HAS_SE))
+	emit_insn (gen_extendqihi2 (op2_rtx, m_op2));
+
+      switch (op0mode)
+	{
+	case QImode:
+	case HImode:
+	  emit_move_insn (operands[0], m_reslo);
+	  break;
+	case SImode:
+	  emit_move_insn (gen_lowpart (HImode, operands[0]), reslo_rtx);
+	  emit_move_insn (gen_highpart (HImode, operands[0]), reshi_rtx);
+	  break;
+	default:
+	  gcc_unreachable();
+	}
+    }
+  else
+    {
+      gcc_assert (SImode == op1mode);
+      emit_move_insn (signed_mul ? mpys32l_rtx : mpy32l_rtx, gen_lowpart (HImode, operands[1]));
+      emit_move_insn (signed_mul ? mpys32h_rtx : mpy32h_rtx, gen_highpart (HImode, operands[1]));
+      if (CONST_INT_P (operands[2]))
+	{
+	  HOST_WIDE_INT iv = INTVAL (operands[2]);
+	  emit_move_insn (op2l_rtx, GEN_INT (trunc_int_for_mode (iv & ((1 << BITS_PER_WORD) - 1), HImode)));
+	  emit_move_insn (op2h_rtx, GEN_INT (trunc_int_for_mode (iv >> BITS_PER_WORD, HImode)));
+	}
+      else
+	{
+	  gcc_assert (SImode == op2mode);
+	  emit_move_insn (op2l_rtx, gen_lowpart (HImode, operands[2]));
+	  emit_move_insn (op2h_rtx, gen_highpart (HImode, operands[2]));
+	}
+      switch (op0mode)
+	{
+	case SImode:
+	  emit_move_insn (gen_lowpart (HImode, operands[0]), reslo_rtx);
+	  emit_move_insn (gen_highpart (HImode, operands[0]), reshi_rtx);
+	  break;
+	case DImode:
+	  {
+	    rtx dst_llo = NULL_RTX;	/* lowpart (hi, lowpart (si, di)) */
+	    rtx dst_lhi = NULL_RTX;	/* highpart (hi, lowpart (si, di)) */
+	    rtx dst_hlo = NULL_RTX;	/* lowpart (hi, highpart (si, di)) */
+	    rtx dst_hhi = NULL_RTX;	/* highpart (hi, highpart (si, di)) */
+
+	    if (REG_P (operands[0]))
+	      {
+		dst_llo = gen_rtx_SUBREG (HImode, operands[0], 0);
+		dst_lhi = gen_rtx_SUBREG (HImode, operands[0], UNITS_PER_WORD);
+		dst_hlo = gen_rtx_SUBREG (HImode, operands[0], 2 * UNITS_PER_WORD);
+		dst_hhi = gen_rtx_SUBREG (HImode, operands[0], 3 * UNITS_PER_WORD);
+	      }
+	    else if (MEM_P (operands[0]))
+	      {
+		dst_llo = adjust_address (operands[0], HImode, 0);
+		dst_lhi = adjust_address (dst_llo, HImode, UNITS_PER_WORD);
+		dst_hlo = adjust_address (dst_lhi, HImode, UNITS_PER_WORD);
+		dst_hhi = adjust_address (dst_hlo, HImode, UNITS_PER_WORD);
+	      }
+	    else
+	      gcc_unreachable ();
+
+	  emit_move_insn (dst_llo, res0_rtx);
+	  emit_move_insn (dst_lhi, res1_rtx);
+	  emit_move_insn (dst_hlo, res2_rtx);
+	  emit_move_insn (dst_hhi, res3_rtx);
+	  break;
+	  }
+	default:
+	  gcc_unreachable();
+	}
+    }
+
+  if (!MSP430_NOINT_HWMUL)
+    emit_insn (gen_mpy_restore_intr ());
+
+  return 1;
+}
+
+const char *
+msp430_emit_call (rtx operands[])
+{
+  rtx x = operands[0];
+  rtx c;
+  rtx r;
+
+  if (GET_CODE (x) == MEM)
+    {
+      c = XEXP (x, 0);
+
+      if (REG_P (c) && REGNO (c) == 1)
+	{
+	  output_asm_insn ("call\t2(%E0)", operands);
+	  return "";
+	}
+
+      if (GET_CODE (c) == PLUS)
+	{
+	  r = XEXP (c, 0);
+	  if (REG_P (r) && REGNO (r) == 1)
+	    {
+	      output_asm_insn ("call\t2+%A0", operands);
+	      return "";
+	    }
+	}
+    }
+
+  output_asm_insn ("call\t%0", operands);
+  return "";
+}
+
+#if defined(MAX_INSNS_PER_PEEP2)
+int
+dead_or_set_in_peep (int which, rtx insn ATTRIBUTE_UNUSED, rtx x)
+{
+  extern int peep2_current_count;
+  rtx r;
+  rtx next;
+
+  if (which > peep2_current_count)
+    return 0;
+
+  next = peep2_next_insn (which);
+  if (!next)
+    return 0;
+  if (!REG_P (x))
+    return 0;
+  r = find_regno_note (next, REG_DEAD, REGNO (x));
+
+  if (!r)
+    return 0;
+
+  r = XEXP (r, 0);
+  return GET_MODE (r) == GET_MODE (x);
+}
+#endif /* MAX_INSNS_PER_PEEP2 */
+
+static void
+msp430_asm_trampoline_template (FILE * fd)
+{
+  fprintf (fd, "; TRAMPOLINE HERE\n"
+	   "; move context (either r1 or r4) to r6\n"
+	   "; call function (0xf0f0 will be changed)\n");
+  fprintf (fd, "\tmov	#0xf0f0, r6\n");
+  fprintf (fd, "\tbr	#0xf0f0\n");
+  fprintf (fd, "; END OF TRAMPOLINE\n\n");
+}
+
+static void
+msp430_trampoline_init (rtx m_tramp, tree fndecl, rtx static_chain)
+{
+  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (m_tramp, 2)),
+		  static_chain);
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (m_tramp, 6)), fnaddr);
+}
+
+/* ---------------------------------------------------------------------------------------------------------------------------------------------- */
+
+static bool
+msp430_rtx_costs (rtx x, int code, int outer_code, int *total,
+		  bool speed ATTRIBUTE_UNUSED)
+{
+  int cst;
+  int mode_size_words;
+  rtx op0, op1;
+	/***
+	[(outer:mode1 (inner:mode (op1) (op2))]
+
+	inner		outer	mode1	op1   op2
+	--------------------------
+	CONST_INT	UNKNOWN	VOID
+	PLUS		SET	HI	reg + reg
+	ASHIFT	SET	HI	reg << 1
+	ASHIFT	SET	HI	reg << 15
+	NEG		SET	HI	reg
+	DIV		SET	HI	reg / 32
+	MOD		SET	HI	reg % 32
+	UDIV		SET	QI	reg / reg
+	MULT		SET	QI	reg * reg
+	MULT		SET	HI	0<-reg * 0<-reg
+	TRUNCATE	SET	QI	HI -> QI
+	UDIV		SET	HI	reg / reg
+	MULT		SET	HI	reg * reg
+	MULT		SET	SI	0<-reg * 0<-reg
+	TRUNCATE	SET	HI	SI -> HI
+	UDIV		SET	SI	reg / reg
+	MULT		SET	SI	reg * reg
+	MULT		SET	DI	0<-reg * 0<-reg
+	TRUNCATE	SET	SI	DI -> SI
+	UDIV		SET	DI	reg / reg
+	MULT		SET	DI	reg * reg
+	MULT		SET	TI	0<-reg * 0<-reg
+	TRUNCATE	SET	DI	TI -> DI
+	UDIV		SET	TI	reg / reg
+	MULT		SET	TI	reg * reg
+	MULT		SET	OI	reg * reg
+	TRUNCATE	SET	TI	OI -> TI
+	UDIV		SET	OI	reg / reg
+	MULT		SET	OI	reg * reg
+	CONST_INT	COMPARE	VOID	
+	...
+	CONST_INT	PLUS	HI	reg + const
+	PLUS		MEM	HI	X(rn)
+	PLUS		CONST_INT	???????? ?????
+	MEM		SET	any
+	PLUS		MEM	HI	reg + const
+
+	***/
+  cst = COSTS_N_INSNS (5);
+  mode_size_words =
+    (GET_MODE_SIZE (GET_MODE (x)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
+  if (outer_code == SET)
+    {
+      op0 = XEXP (x, 0);
+      switch (code)
+	{
+	case CONST_INT:	/* source only !!! */
+	  {
+	    HOST_WIDE_INT i = INTVAL (x);
+	    if (MSP430_CG_INT_P (i))
+	      cst = COSTS_N_INSNS (1);
+	    else
+	      cst = COSTS_N_INSNS (2);
+	  }
+	  break;
+	case PLUS:
+	case MINUS:
+	case AND:
+	case IOR:
+	case XOR:
+	case UNSPEC:
+	case UNSPEC_VOLATILE:
+	  cst = COSTS_N_INSNS (mode_size_words);
+	  break;
+	case ASHIFT:
+	case LSHIFTRT:
+	case ASHIFTRT:
+	  op1 = XEXP (x, 1);
+	  /* cst = COSTS_N_INSNS(10);
+	     break; */
+	  if (CONST_INT_P (op1) && INTVAL (op1) == 1)
+	    cst = COSTS_N_INSNS (mode_size_words);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 15)
+	    cst = 3 * COSTS_N_INSNS (mode_size_words);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 8)
+	    cst = 2 * COSTS_N_INSNS (mode_size_words);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 16)
+	    cst = COSTS_N_INSNS (mode_size_words);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 24)
+	    cst = 4 * COSTS_N_INSNS (mode_size_words);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 31)
+	    cst = 3 * COSTS_N_INSNS (mode_size_words);
+	  if (code == ASHIFTRT)
+	    cst += COSTS_N_INSNS (1);
+	  break;
+
+	case NEG:
+	  cst = 2 * COSTS_N_INSNS (mode_size_words);
+	  break;
+	case DIV:
+	case MOD:
+	case MULT:
+	case UDIV:
+	  cst = COSTS_N_INSNS (64);
+	  break;
+	case TRUNCATE:
+	  cst = COSTS_N_INSNS (mode_size_words);
+	  break;
+	case ZERO_EXTEND:
+	  cst = 2 * COSTS_N_INSNS (mode_size_words);
+	  break;
+	case SIGN_EXTEND:
+	case ABS:
+	  cst = 2 * COSTS_N_INSNS (mode_size_words);
+	  cst += COSTS_N_INSNS (2);
+	  break;
+	default:
+	  cst = 0;
+	}
+    }
+  else if (outer_code == COMPARE)
+    {
+      cst = COSTS_N_INSNS (mode_size_words);
+      cst += COSTS_N_INSNS (2);
+    }
+  else if (outer_code == JUMP_INSN)
+    {
+      cst = COSTS_N_INSNS (2);
+    }
+  else if (outer_code == CALL_INSN)
+    {
+      cst = COSTS_N_INSNS (4);
+    }
+  else
+    return false;
+
+  *total = cst;
+  if (cst)
+    return true;
+  return false;
+}
+
+int
+default_rtx_costs (rtx X ATTRIBUTE_UNUSED, enum rtx_code code,
+		   enum rtx_code outer_code ATTRIBUTE_UNUSED,
+		   bool speed ATTRIBUTE_UNUSED)
+{
+  int cost = 4;
+
+  switch (code)
+    {
+    case SYMBOL_REF:
+      cost += 2;
+      break;
+    case LABEL_REF:
+      cost += 2;
+      break;
+    case MEM:
+      cost += 2;
+      break;
+    case CONST_INT:
+      cost += 2;
+      break;
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
+      cost += 2;
+      break;
+    default:
+      break;
+    }
+  return cost;
+}
+
+
+static void
+msp430_globalize_label (FILE * stream, const char *name)
+{
+  if (*name == '*' || *name == '@')
+    name++;
+  if (*name >= '0' && *name <= '9')
+    return;
+  fputs (".global\t", stream);
+  assemble_name (stream, name);
+  putc ('\n', stream);
+}
+
+static int
+msp430_address_costs (rtx x, bool speed ATTRIBUTE_UNUSED)
+{
+  enum rtx_code code = GET_CODE (x);
+  rtx op0, op1;
+
+  switch (code)
+    {
+    case PLUS:			/* X(rn), addr + X */
+      op0 = XEXP (x, 0);
+      op1 = XEXP (x, 1);
+      if (REG_P (op0))
+	{
+	  if (INTVAL (op1) == 0)
+	    return COSTS_N_INSNS (2);
+	  else
+	    return COSTS_N_INSNS (3);
+	}
+      break;
+    case REG:
+      return COSTS_N_INSNS (2);
+      break;
+    default:
+      break;
+    }
+  return COSTS_N_INSNS (3);
+}
+
+#if 0
+/* @TODO@ Verify the exception in this is handled */
+void
+msp430_expand_mov_intptr (rtx dest, rtx src)
+{
+  if (push_operand (dest, HImode) && !general_no_elim_operand (src, HImode))
+    src = copy_to_mode_reg (HImode, src);
+
+  emit_insn (gen_rtx_SET (VOIDmode, dest, src));
+}
+#endif
+
+/* [4.5.2] 17.2 Driver -- no hooks */
+/* [4.5.2] 17.3 Run-time Target */
+/* [4.5.2] 17.4 Per-Function Data -- no hooks*/
+/* [4.5.2] 17.5: Storage Layout */
+
+/* [4.5.2] 17.6 Type Layout */
+/* SF 3191528: TARGET_DEFAULT_SHORT_ENUMS */
+
+/* [4.5.2] 17.7 Registers */
+
+/* [4.5.2] 17.8 Register Classes */
+/* TODO TARGET_IRA_COVER_CLASSES seems important */
+
+/* [4.5.2] 17.9 Old Constraints */
+
+/* [4.5.2] 17.10 Stack and Calling */
+/* 17.10.5 Elimination */
+#undef TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED msp430_frame_pointer_required
+#undef TARGET_CAN_ELIMINATE
+#define TARGET_CAN_ELIMINATE msp430_can_eliminate
+/* 17.10.8 Scalar Return */
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE msp430_function_value
+#undef TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE msp430_libcall_value
+/* 17.19.9 Aggregate Return */
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY msp430_return_in_memory
+/* 17.10.11 Function Entry */
+/* 17.10.13 Tail Calls */
+
+/* [4.5.2] 17.11 Varargs */
+
+/* [4.5.2] 17.12 Trampolines */
+#undef TARGET_ASM_TRAMPOLINE_TEMPLATE
+#define TARGET_ASM_TRAMPOLINE_TEMPLATE msp430_asm_trampoline_template
+#undef TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT msp430_trampoline_init
+
+/* [4.5.2] 17.13 Library Calls */
+
+/* [4.5.2] 17.14 Addressing Modes */
+#undef TARGET_LEGITIMATE_ADDRESS_P
+#define TARGET_LEGITIMATE_ADDRESS_P msp430_legitimate_address_p
+
+/* [4.5.2] 17.15 Anchored Addresses */
+
+/* [4.5.2] 17.16 Condition Code */
+
+/* [4.5.2] 17.17 Costs */
+#undef 	TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS msp430_rtx_costs
+#undef	TARGET_ADDRESS_COST
+#define	TARGET_ADDRESS_COST msp430_address_costs
+
+/* [4.5.2] 17.18 Scheduling */
+
+/* [4.5.2] 17.19 Sections */
+
+/* [4.5.2] 17.20 PIC -- not supported */
+
+/* [4.5.2] 17.21 Assembler Format */
+/* 17.21.1 File Framework */
+#undef TARGET_ASM_FILE_START
+#define TARGET_ASM_FILE_START msp430_file_start
+#undef TARGET_ASM_FILE_START_FILE_DIRECTIVE
+#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true
+/* TARGET_ASM_NAMED_SECTION is defined in msp430.h */
+#undef 	TARGET_SECTION_TYPE_FLAGS
+#define TARGET_SECTION_TYPE_FLAGS msp430_section_type_flags
+/* 17.21.2 Data Output */
+/* TODO: Verify these */
+#undef TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\t.word\t"
+/* 17.21.4 Label Output */
+#undef TARGET_ASM_GLOBALIZE_LABEL
+#define TARGET_ASM_GLOBALIZE_LABEL msp430_globalize_label
+
+/* [4.5.2] 17.25 Target Attributes */
+#undef 	TARGET_ATTRIBUTE_TABLE
+#define TARGET_ATTRIBUTE_TABLE msp430_attribute_table
+
+/* [4.5.2] 17.26 Emulated TLS */
+/* [4.5.2] 17.27 MIPS Coprocessors -- not relevant */
+/* [4.5.2] 17.28 PCH Target */
+/* [4.5.2] 17.29 C++ ABI */
+/* [4.5.2] 17.30 Named Address Spaces */
+
+/* [4.5.2] 17.31 Misc */
+#undef TARGET_INIT_BUILTINS
+#define TARGET_INIT_BUILTINS msp430_init_builtins
+#undef TARGET_EXPAND_BUILTIN
+#define TARGET_EXPAND_BUILTIN msp430_expand_builtin
+#undef TARGET_SET_CURRENT_FUNCTION
+#define TARGET_SET_CURRENT_FUNCTION msp430_set_current_function
+
+/* [4.5.2] 17.1 Target Structure */
+struct gcc_target targetm = TARGET_INITIALIZER;
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430.h gcc-4.5.3/gcc/config/msp430/msp430.h
new file mode 100644
index 0000000..d4073b8
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430.h
@@ -0,0 +1,811 @@
+/* This work is partially financed by the European Commission under the
+ * Framework 6 Information Society Technologies Project
+ * "Wirelessly Accessible Sensor Populations (WASP)".
+ */
+
+/* Definitions of target machine for GNU compiler,
+   for Texas Instruments MSP430 microcontrollers.
+   Copyright (C) 2001-2009 Free Software Foundation, Inc.
+   Contributed by Dmitry Diky <diwil@mail.ru>
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* TODO:
+ *
+ * The GCC internals manual (http://gcc.gnu.org/onlinedocs/gccint, but
+ * only if you're working on the trunk) defines the current standard
+ * back-end expectations.  The following sections are defined in the
+ * chapter 17 "Target Macros" of the 4.5.2 version of the internals
+ * manual.  A [+] before the section indicates its contents have been
+ * reviewed and the implementation brought into compliance:
+ *
+ * Target Structure: The targetm variable.
+ * Driver: Controlling how the driver runs the compilation passes.
+ * Run-time Target: Defining ‘-m’ options like -m68000 and -m68020.
+ * Per-Function Data: Defining data structures for per-function information.
+ * [+] Storage Layout: Defining sizes and alignments of data.
+ * [+] Type Layout: Defining sizes and properties of basic user data types.
+ * [+] Registers: Naming and describing the hardware registers.
+ * [+] Register Classes: Defining the classes of hardware registers.
+ * [+] Old Constraints: The old way to define machine-specific constraints.
+ * [+] Stack and Calling: Defining which way the stack grows and by how much.
+ * [+] Varargs: Defining the varargs macros.
+ * [+] Trampolines: Code set up at run time to enter a nested function.
+ * [+] Library Calls: Controlling how library routines are implicitly called.
+ * [+] Addressing Modes: Defining addressing modes valid for memory operands.
+ * [+] Anchored Addresses: Defining how -fsection-anchors should work.
+ * [+] Condition Code: Defining how insns update the condition code.
+ * [+] Costs: Defining relative costs of different operations.
+ * [+] Scheduling: Adjusting the behavior of the instruction scheduler.
+ * [+] Sections: Dividing storage into text, data, and other sections.
+ * [+] PIC: Macros for position independent code.
+ * [+] Assembler Format: Defining how to write insns and pseudo-ops to output.
+ * [+] Debugging Info: Defining the format of debugging output.
+ * Floating Point: Handling floating point for cross-compilers.
+ * Mode Switching: Insertion of mode-switching instructions.
+ * Target Attributes: Defining target-specific uses of __attribute__.
+ * Emulated TLS: Emulated TLS support.
+ * MIPS Coprocessors: MIPS coprocessor support and how to customize it.
+ * PCH Target: Validity checking for precompiled headers.
+ * C++ ABI: Controlling C++ ABI changes.
+ * Named Address Spaces: Adding support for named address spaces
+ * Misc: Everything else.
+ *
+ * Target macros and hooks should not be defined if the default
+ * behavior is correct for the platform.  To make it clear that the
+ * maintainer is aware of the macro and has verified it, it may be
+ * defined to be its default in a comment (see, for example,
+ * STRUCTURE_SIZE_BOUNDARY below), with a prefix DEFAULT: to make it
+ * clear this is a comment, not droppings from disabled code.
+ */
+
+/** Update this on each release */
+#define MSP430_MSPGCC_VERSION 20110706
+
+/** Bit-markers for type of CPU present. */
+typedef enum msp430_cpu_e
+{
+  MSP430_CPU_MSP430 = 0x0000,
+  MSP430_CPU_MSP430X = 0x0002,
+  MSP430_CPU_MSP430XV2 = 0x0003,
+  MSP430_CPU = 0x0003
+} msp430_cpu_e;
+
+/** Bit-markers for type of hardware multiplier present. */
+typedef enum msp430_mpy_e
+{
+  MSP430_MPY_NONE = 0x0000,
+  MSP430_MPY_TYPE_16 = 0x0010,
+  MSP430_MPY_TYPE_32 = 0x0020,
+  MSP430_MPY_TYPE_ANY = 0x0030,
+  MSP430_MPY_HAS_SE = 0x0001,
+  MSP430_MPY_HAS_DW = 0x0002,
+  MSP430_MPY_16 = MSP430_MPY_TYPE_16,
+  MSP430_MPY_16SE = MSP430_MPY_16 | MSP430_MPY_HAS_SE,
+  MSP430_MPY_32 = MSP430_MPY_TYPE_16 | MSP430_MPY_TYPE_32 | MSP430_MPY_HAS_SE,
+  MSP430_MPY_32DW = MSP430_MPY_32 | MSP430_MPY_HAS_DW
+} msp430_mpy_e;
+
+extern msp430_cpu_e msp430_cpu;
+extern msp430_mpy_e msp430_mpy;
+extern int msp430_ivcnt;
+
+extern const char *msp430_mcu_name;
+extern int msp430_has_hwmul;
+
+#define MSP430_HAS_HWMUL_INTERNAL (msp430_has_hwmul)
+
+int msp430_current_function_noint_hwmul_function_p (void);
+#define MSP430_NOINT_HWMUL (msp430_current_function_noint_hwmul_function_p())
+
+/* 1 if the integral value can be produced by the MSP430 CG registers */
+#define MSP430_CG_INT_P(VALUE)	\
+  ((-1 == (VALUE))		\
+   || (0 == (VALUE))		\
+   || (1 == (VALUE))		\
+   || (2 == (VALUE))		\
+   || (4 == (VALUE))		\
+   || (8 == (VALUE)))
+
+/* [4.5.2] 16.19.5 Insn Lengths */
+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \
+  (LENGTH = msp430_adjust_insn_length (INSN, LENGTH))
+
+/* [4.5.2] 17.1 Target Structure -- defined in msp430.c */
+
+/* [4.5.2] 17.2 Driver */
+/* On startup read the spec file that translates known MCUs into
+ * device-specific flags (note: this is an msp430 extension to the
+ * upstream driver).  Also normalize any legacy mcu descriptions,
+ * then ensure we have -mcpu and -mmpy configurations derived from
+ * the mcu. */
+#define DRIVER_SELF_SPECS \
+  "%:include_noerr(msp430mcu.spec)" \
+  "%(msp430_normalizemcu)" \
+  " %(msp430_cpu)" \
+  " %(msp430_mpy)" \
+  " %(msp430_ivcnt)"
+/* Accept -posix; invoke a special function to
+ * rote-translate -mmcu options into preprocessor definition
+ * options.  */
+#define CPP_SPEC "%{posix:-D_POSIX_SOURCE} %:msp430_mcucpp(%{mmcu=*:%*})"
+/* Provide device-specific -mivcnt, -mcpu, -mmpy options. */
+#define CC1_SPEC "%{profile:-p} %{mcpu=*} %{mmpy=*} %{mivcnt=*}"
+/* TODO: legacy value */
+#define CC1PLUS_SPEC "-fno-rtti -fno-exceptions"
+/* Pass MCU-related options to the assembler. */
+#define ASM_SPEC "%{mcpu=*} %{mmcu=*}"
+/* Use the msp430 linker emulation */
+#define LINK_SPEC "-m msp430"
+/* TODO: legacy value */
+#define LIB_SPEC "-lc"
+/* Select the corresponding interrupt vector initializer based on
+ * mivcnt. */
+#define STARTFILE_SPEC				\
+  "%{mivcnt=16:crt0ivtbl16%O%s} "		\
+  "%{mivcnt=32:crt0ivtbl32%O%s} "		\
+  "%{mivcnt=64:crt0ivtbl64%O%s}"
+#define ENDFILE_SPEC \
+  "%{menable-watchdog|mno-disable-watchdog|!mdisable-watchdog:-lcrt0; :-lcrt0dwdt}"
+extern const char *msp430_mcucpp (int argc, const char **argv);
+extern const char *msp430_mculdscriptpath (int argc, const char **argv);
+#define EXTRA_SPEC_FUNCTIONS				\
+  { "msp430_mcucpp", msp430_mcucpp },			\
+  { "msp430_mculdscriptpath", msp430_mculdscriptpath },
+#define EXTRA_SPECS							\
+  { "msp430_normalizemcu", "" },					\
+  { "msp430_cpu", "%{!mcpu=*:%{mcpu=430}}" },				\
+  { "msp430_mpy", "%{!mmpy=*:%{mmpy=none}}" },				\
+  { "msp430_ivcnt", "%{!mivcnt=*:%{mivcnt=16}}" },			\
+				/* Override this.  The value is essentially the default from gcc.c,
+				 * but we need to be able to define a default linker script derived
+				 * from the -mmcu parameter, and it has to be at the end; it doesn't
+				 * work when placed after the emulation in LINK_SPEC.  I did strip out
+				 * the -pie support, as it depends on a potentially-undefined
+				 * macro. */
+#define LINK_COMMAND_SPEC "\
+%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
+    %(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\
+    %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
+    %{static:} %{L*} %(mfwrap) %(link_libgcc) %o\
+    %{fopenmp|ftree-parallelize-loops=*:%:include(libgomp.spec)%(link_gomp)} %(mflib)\
+    %{fprofile-arcs|fprofile-generate|coverage:-lgcov}\
+    %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\
+    %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} \
+    %{mmcu=*:-L %:msp430_mculdscriptpath(%{mmcu=*:%*})} \
+    }}}}}}"
+#define MULTILIB_DEFAULTS { "mcpu=430", "mmpy=none" }
+
+/* [4.5.2] 17.3 Run-time Target */
+#define TARGET_CPU_CPP_BUILTINS()					\
+  do {									\
+    char defstr[64];							\
+    builtin_define_std ("MSP430");					\
+    if(msp430_has_hwmul)						\
+      builtin_define ("MSP430_HAS_HWMUL");				\
+    else								\
+      builtin_define ("MSP430_NO_HWMUL");				\
+    if (MSP430_CPU_MSP430X <= msp430_cpu)				\
+      {									\
+	snprintf(defstr, sizeof (defstr), "__MSP430X__=%d", msp430_cpu); \
+	builtin_define (defstr);					\
+      }									\
+    snprintf (defstr, sizeof (defstr), "__MSPGCC__=%d", MSP430_MSPGCC_VERSION); \
+    builtin_define (defstr);						\
+    snprintf (defstr, sizeof (defstr), "__MSP430_CPU__=%d", msp430_cpu); \
+    builtin_define (defstr);						\
+    if (MSP430_MPY_NONE != msp430_mpy)					\
+      {									\
+	snprintf (defstr, sizeof (defstr), "__MSP430_MPY__=%d", msp430_mpy); \
+	builtin_define (defstr);					\
+	if (msp430_mpy & MSP430_MPY_TYPE_16)				\
+	  {								\
+	    snprintf (defstr, sizeof (defstr), "__MSP430_MPY16__=%d", msp430_mpy); \
+	    builtin_define (defstr);					\
+	  }								\
+	if (msp430_mpy & MSP430_MPY_TYPE_32)				\
+	  {								\
+	    snprintf (defstr, sizeof (defstr), "__MSP430_MPY32__=%d", msp430_mpy); \
+	    builtin_define (defstr);					\
+	  }								\
+      }									\
+    snprintf (defstr, sizeof (defstr), "__MSP430_IVCNT__=%d", msp430_ivcnt); \
+    builtin_define (defstr);						\
+  } while (0)
+extern int target_flags;
+#define TARGET_VERSION fprintf (stderr, " (TI MSP430)");
+#define OVERRIDE_OPTIONS msp430_override_options()
+#define CAN_DEBUG_WITHOUT_FP
+
+/* [4.5.2] 17.4 Per-Function Data -- not used*/
+
+/* [4.5.2] 17.5: Storage Layout */
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+#define UNITS_PER_WORD 2
+#define POINTER_SIZE 16
+#define PARM_BOUNDARY 16
+#define STACK_BOUNDARY PARM_BOUNDARY
+#define FUNCTION_BOUNDARY 16
+#define BIGGEST_ALIGNMENT 16
+#define MINIMUM_ATOMIC_ALIGNMENT BITS_PER_UNIT
+#define EMPTY_FIELD_BOUNDARY 16
+#define STRUCTURE_SIZE_BOUNDARY 16
+#define STRICT_ALIGNMENT 1
+/* DEFAULT: #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode) */
+
+/* [4.5.2] 17.6 Type Layout */
+#define SHORT_TYPE_SIZE 16
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE FLOAT_TYPE_SIZE
+#define LONG_DOUBLE_TYPE_SIZE FLOAT_TYPE_SIZE
+#define DEFAULT_SIGNED_CHAR 1
+#define SIZE_TYPE "unsigned int"
+/* DEFAULT: #define PTRDIFF_TYPE "long int */
+
+/* [4.5.2] 17.7 Registers */
+#define MSP430_CG1_REGNUM 2
+#define MSP430_CG2_REGNUM 3
+#define MSP430_MIN_GENERAL_REGNUM 4
+#define MSP430_MAX_GENERAL_REGNUM 15
+#define MSP430_MAX_HARD_REGNUM 15
+#define RETURN_REGISTER_BASE 15
+/* 1 if REG is a valid register number (not a fixed pseudo-reg) */
+#define MSP430_HARD_REGISTER_NUM_P(REGNO) \
+  ((unsigned int)(REGNO) <= MSP430_MAX_HARD_REGNUM)
+/* 1 if REG is a general register */
+#define MSP430_GENERAL_REGISTER_NUM_P(REGNO) \
+  (MSP430_MIN_GENERAL_REGNUM <= (REGNO) \
+   && (REGNO) <= MSP430_MAX_GENERAL_REGNUM)
+
+#define FIRST_PSEUDO_REGISTER 18
+#define FIXED_REGISTERS {							\
+    1,		/* r0 : Program Counter (PC) */					\
+    1,		/* r1 : Stack Pointer (SP) */					\
+    1,		/* r2 : Status Register (SR); Constant Generator (CG1) */	\
+    1,		/* r3 : Constant Generator (CG2) */				\
+    0, 0, 0, 0, /* r4-r7 */							\
+    0, 0, 0, 0, /* r8-r11 */							\
+    0, 0, 0, 0, /* r12-r15 */							\
+    1,		/* r16 (PSEUDO) : Argument Pointer */				\
+    1,		/* r17 (PSEUDO) : Frame Pointer */				\
+    }
+#define CALL_USED_REGISTERS {				\
+    1, 1, 1, 1,	/* r0-r3: fixed registers */		\
+    0, 0, 0, 0,	/* r4-r7 : callee saved */		\
+    0, 0, 0, 0,	/* r8-r11 : callee saved */		\
+    1, 1, 1, 1,	/* r12-r15 : parameter registers */	\
+    1, 1,	/* r16-r17 : fixed pseudo register */	\
+    }
+#define PC_REGNUM 0
+/* TODO: SF 3191557 */
+#define REG_ALLOC_ORDER { 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 }
+#define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()
+#define HARD_REGNO_NREGS(REGNO, MODE) \
+    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+#define HARD_REGNO_MODE_OK(REGNO, MODE) \
+  MSP430_HARD_REGISTER_NUM_P((REGNO) + HARD_REGNO_NREGS (REGNO, MODE) - 1)
+/* TODO: SF 3191569 */
+#define MODES_TIEABLE_P(MODE1, MODE2) 0
+
+/* [4.5.2] 17.8 Register Classes */
+int msp430_general_or_stack_reg (int regno);
+int msp430_indirect_register_operand (rtx x);
+int msp430_indexed_register_operand (rtx x);
+
+enum reg_class
+{
+  NO_REGS,
+  PC_REG,			/* r0 (PC) */
+  SP_REG,			/* r1 (SP) */
+  SR_REG,			/* r2 (SR) */
+  CG1_REG,			/* r2 (CG1) */
+  CG2_REG,			/* r3 (CG2) */
+  CG_REGS,			/* r2,r3 */
+  FP_REG,			/* r4 (HARD_FRAME_POINTER) */
+  GENERAL_REGS,			/* r4-r15 */
+  GENERAL_SP_REGS,		/* r1,r4-r15 */
+  GENERAL_SR_REGS,		/* r2,r4-r15 */
+  POINTER_REGS,                 /* r1,r4-r15 */
+  SOFT_ARGP_REG,		/* r16 (ARG_POINTER) */
+  SOFT_FP_REG,			/* r17 (FRAME_POINTER) */
+  FIXED_PSEUDO_REGS,		/* r16- */
+  FIXED_PSEUDO_GENERAL_REGS,	/* r4-r15,r16- */
+  FIXED_PSEUDO_GENERAL_SP_REGS,	/* r1,r4-r15,r16- */
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+#define REG_CLASS_NAMES {		\
+		"NO_REGS",		\
+		"PC_REG",		\
+		"SP_REG",		\
+		"SR_REG",		\
+		"CG1_REG",		\
+		"CG2_REG",		\
+		"CG_REGS",		\
+		"FP_REG",		\
+		"GENERAL_REGS",		\
+		"GENERAL_SP_REGS",	\
+		"GENERAL_SR_REGS",	\
+		"POINTER_REGS",		\
+		"SOFT_ARGP_REG",	\
+		"SOFT_FP_REG",		\
+		"FIXED_PSEUDO_REGS",	\
+		"FIXED_PSEUDO_GENERAL_REGS",	\
+		"FIXED_PSEUDO_GENERAL_SP_REGS",	\
+		"ALL_REGS" 		\
+}
+#define REG_CLASS_CONTENTS {			\
+  {0x00000000ul},	/* NO_REGS */		\
+  {0x00000001ul},	/* PC_REG */		\
+  {0x00000002ul},	/* SP_REG */		\
+  {0x00000004ul},	/* SR_REG */		\
+  {0x00000004ul},	/* CG1_REG */		\
+  {0x00000008ul},	/* CG2_REG */		\
+  {0x0000000cul},	/* CG_REGS */		\
+  {0x00000010ul},	/* FP_REG */		\
+  {0x0000fff0ul},	/* GENERAL_REGS */      \
+  {0x0000fff2ul},	/* GENERAL_SP_REGS */   \
+  {0x0000fff4ul},	/* GENERAL_SR_REGS */   \
+  {0x0000fff2ul},	/* POINTER_REGS */      \
+  {0x00010000ul},	/* SOFT_ARGP_REG */     \
+  {0x00020000ul},	/* SOFT_FP_REG */	\
+  {0x00030000ul},	/* FIXED_PSEUDO_REGS */ \
+  {0x0003fff0ul},	/* FIXED_PSEUDO_GENERAL_REGS */	\
+  {0x0003fff2ul},	/* FIXED_PSEUDO_GENERAL_SP_REGS */ \
+  {0x0003fffful}	/* ALL_REGS */		\
+}
+#define REGNO_REG_CLASS(REGNO) msp430_regno_reg_class (REGNO)
+#define BASE_REG_CLASS POINTER_REGS
+#define INDEX_REG_CLASS NO_REGS
+#define REGNO_OK_FOR_BASE_STRICT_P(NUM) msp430_regno_ok_for_base_p(NUM, 1)
+#define REGNO_OK_FOR_BASE_NONSTRICT_P(NUM) msp430_regno_ok_for_base_p(NUM, 0)
+#ifdef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(NUM) REGNO_OK_FOR_BASE_STRICT_P(NUM)
+#else
+#define REGNO_OK_FOR_BASE_P(NUM) REGNO_OK_FOR_BASE_NONSTRICT_P(NUM)
+#endif
+#define REGNO_OK_FOR_INDEX_P(NUM) 0
+#define PREFERRED_RELOAD_CLASS(X, CLASS) CLASS
+#define CLASS_MAX_NREGS(CLASS, MODE) HARD_REGNO_NREGS(_unreferenced, MODE)
+
+/* [4.5.2] 17.9 Old Constraints */
+
+/* [4.5.2] 17.10 Stack and Calling */
+/* 17.10.1 Frame Layout */
+#define STACK_GROWS_DOWNWARD
+#define STARTING_FRAME_OFFSET 0
+#define FIRST_PARM_OFFSET(FUNDECL) 0
+#define INCOMING_RETURN_ADDR_RTX gen_rtx_MEM (Pmode, stack_pointer_rtx)
+#define FRAME_POINTER_CFA_OFFSET(FUNDECL) 0
+#define INCOMING_FRAME_SP_OFFSET \
+  ((cfun && cfun->machine && cfun->machine->interrupt) ? 2*UNITS_PER_WORD : GET_MODE_SIZE (Pmode))
+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) msp430_return_addr_rtx (COUNT, FRAMEADDR)
+/* 17.10.2 Exception Handling */
+/* 17.10.3 Stack Checking */
+/* 17.10.4 Frame Registers */
+#define STACK_POINTER_REGNUM 1
+#define STATUS_REGISTER_REGNUM 2
+#define HARD_FRAME_POINTER_REGNUM 4
+#define ARG_POINTER_REGNUM 16
+#define FRAME_POINTER_REGNUM 17
+#define STATIC_CHAIN_REGNUM 6
+/* 17.10.5 Elimination */
+#define ELIMINABLE_REGS {				\
+    {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},		\
+    {ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},	\
+    {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},	\
+    {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},	\
+}
+#define INITIAL_ELIMINATION_OFFSET(FROM_REG, TO_REG, OFFSET_VAR) \
+  OFFSET_VAR = msp430_initial_elimination_offset (FROM_REG, TO_REG)
+/* 17.10.6 Stack Arguments */
+/* NB Default ACCUMULATE_OUTGOING_ARGS is 0, so default PUSH_ARGS is 1 */
+#define PUSH_ROUNDING(NPUSHED) (((NPUSHED) + 1) & ~1)
+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0
+/* 17.10.7 Register Arguments */
+typedef struct
+{
+  int nregs;			/* # registers available for passing */
+  int regno;			/* next available register number */
+} CUMULATIVE_ARGS;
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  (msp430_function_arg (&(CUM), MODE, TYPE, NAMED))
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS ) \
+  msp430_init_cumulative_args (&(CUM), FNTYPE, LIBNAME, FNDECL)
+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME) \
+  msp430_init_cumulative_incoming_args (&(CUM), FNTYPE, LIBNAME)
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+  msp430_function_arg_advance (&CUM, MODE, TYPE, NAMED)
+/* TODO remove magic numbers */
+#define FUNCTION_ARG_REGNO_P(R) (R >= 12 && R <= 15)
+/* 17.10.8 Scalar Return */
+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == RETURN_REGISTER_BASE)
+/* 17.10.9 Aggregate Return */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+/* 17.10.10 Caller Saves */
+/* 17.10.11 Function Entry */
+#define EPILOGUE_USES(REGNO) msp430_epilogue_uses(REGNO)
+/* 17.10.12 Profiling */
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fprintf (FILE, "/* profiler %d */", LABELNO)
+/* 17.10.13 Tail Calls */
+/* 17.10.14 Stack Smashing Protection */
+
+/* [4.5.2] 17.11 Varargs (no macros relevant) */
+
+/* [4.5.2] 17.12 Trampolines */
+#define TRAMPOLINE_SIZE 8
+#define TRAMPOLINE_ALIGNMENT 16
+
+/* [4.5.2] 17.13 Library Calls */
+#define TARGET_LIB_INT_CMP_BIASED true
+
+/* [4.5.2] 17.14 Addressing Modes */
+#define HAVE_POST_INCREMENT 1
+#define CONSTANT_ADDRESS_P(X) (CONSTANT_P (X) && GET_CODE (X) != CONST_DOUBLE)
+#define MAX_REGS_PER_ADDRESS 1
+#define LEGITIMATE_CONSTANT_P(X) 1
+
+/* [4.5.2] 17.15 Anchored Addresses */
+
+/* [4.5.2] 17.16 Condition Code */
+/* TODO: SF 3192579 */
+#define NOTICE_UPDATE_CC(EXP, INSN) msp430_notice_update_cc (EXP, INSN)
+
+/* [4.5.2] 17.17 Costs */
+#define REGISTER_MOVE_COST(MODE, FROM, TO) ((MODE)==QImode ? 1 :	\
+					    (MODE)==HImode ? 1 :	\
+					    (MODE)==SImode ? 2 :	\
+					    (MODE)==SFmode ? 2 : 4)
+/* TODO: SF 3192592 */
+#define MEMORY_MOVE_COST(MODE, CLASS, IN) ((MODE)==QImode ? 2 :		\
+					   (MODE)==HImode ? 2 :		\
+					   (MODE)==SImode ? 4 :		\
+					   (MODE)==SFmode ? 4 : 8)
+/* TODO: SF 3192592 */
+#define BRANCH_COST(SPEED_P, PREDICTABLE_P) 0
+/* TODO: SF 3192592 */
+#define SLOW_BYTE_ACCESS 0
+#define NO_FUNCTION_CSE
+
+/* [4.5.2] 17.18 Scheduling */
+
+/* [4.5.2] 17.19 Sections */
+#define TEXT_SECTION_ASM_OP "\t.text"
+#define DATA_SECTION_ASM_OP "\t.data"
+#define BSS_SECTION_ASM_OP "\t.section\t.bss"
+
+/* [4.5.2] 17.20 PIC */
+/* Not supported on this platform at this time */
+
+/* [4.5.2] 17.21 Assembler Format */
+/* 17.21.1 File Framework */
+#define ASM_COMMENT_START " ; "
+/* TODO: use default? */
+#define ASM_APP_ON "/* #APP */\n"
+/* TODO: use default? */
+#define ASM_APP_OFF "/* #NOAPP */\n"
+/* Define this hook here so TARGET_HAVE_NAMED_SECTIONS is defaulted to
+ * true in c-common.c */
+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section
+/* 17.21.2 Data Output */
+#define ASM_OUTPUT_ASCII(FILE, P, SIZE) gas_output_ascii (FILE, P, SIZE)
+/* TODO: this is probably a misinterpretation of "logical line separator" */
+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C, STR) ((C) == '\n')
+/* 17.21.3 Uninitialized Data */
+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)		\
+  do {								\
+    const char *p = NAME;					\
+    if(*p == '*' || *p == '@' ) p++;				\
+    if(*p >= '0' && *p <= '9' ) break;				\
+    fputs ("\t.comm ", (STREAM));				\
+    assemble_name ((STREAM), (NAME));				\
+    fprintf ((STREAM), ",%lu%s", (unsigned long)(SIZE), (SIZE)>1?",2\n":"\n"); \
+  } while (0)
+#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED)		\
+  do {								\
+    const char *p = (NAME);					\
+    if(*p == '*' || *p == '@' ) p++;				\
+    if(*p >= '0' && *p <= '9' ) break;				\
+    asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED)); \
+  } while(0)
+#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)		\
+  do {								\
+    const char *p = NAME;					\
+    if(*p == '*' || *p == '@' ) p++;				\
+    if(*p >= '0' && *p <= '9' ) break;				\
+    fputs ("\t.local ", (STREAM));				\
+    assemble_name ((STREAM), (NAME));				\
+    fputs ("\n",(STREAM));					\
+    fputs ("\t.comm ", (STREAM));				\
+    assemble_name ((STREAM), (NAME));				\
+    fprintf ((STREAM), ",%lu%s", (unsigned long)(SIZE),(SIZE)>1?",2\n":"\n"); \
+  } while (0)
+/* 17.21.4 Label Output */
+/* TODO: what's this workaround for?  came in at mspgcc4 */
+#define ASM_OUTPUT_LABEL(STREAM, NAME)					\
+  {									\
+    int __msp430_data_name_workaround = (((NAME)[0] == '*') && ((NAME)[1] == '0')); \
+    if (__msp430_data_name_workaround)					\
+      {									\
+	static int repeatable_pseudolabels_resolver = 0;		\
+	fprintf (STREAM, "__");						\
+	assemble_name (STREAM, NAME);					\
+	fprintf (STREAM, "_%d", ++repeatable_pseudolabels_resolver);	\
+      }									\
+    else								\
+      assemble_name (STREAM, NAME);					\
+    fprintf (STREAM, ":\n");						\
+  }
+#define SIZE_ASM_OP "\t.size\t"
+#define TYPE_ASM_OP "\t.type\t"
+#define TYPE_OPERAND_FMT "@%s"
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)	\
+  msp430_asm_declare_function_name (FILE, NAME, DECL)
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)		\
+  do {								\
+    if (!flag_inhibit_size_directive)				\
+      {								\
+        char label[256];					\
+	static int labelno;					\
+	labelno++;						\
+	ASM_GENERATE_INTERNAL_LABEL (label, "Lfe", labelno);	\
+	fprintf(FILE, ".%s%u:\n", "Lfe", labelno) ;		\
+	fprintf (FILE, "%s", SIZE_ASM_OP);			\
+	assemble_name (FILE, (FNAME));				\
+        fprintf (FILE, ",");					\
+	assemble_name (FILE, label);				\
+        fprintf (FILE, "-");					\
+	assemble_name (FILE, (FNAME));				\
+	fprintf (FILE,"\n;; End of function \n\n");		\
+      }								\
+  } while (0)
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			\
+  do {									\
+    int __msp430_data_name_workaround = (((NAME)[0] == '*') && ((NAME)[1] == '0')); \
+    if (__msp430_data_name_workaround)					\
+      fprintf (FILE, "#");						\
+    fprintf (FILE, "%s", "\t.type\t");					\
+    assemble_name (FILE, NAME);						\
+    putc (',', FILE);							\
+    fprintf (FILE, TYPE_OPERAND_FMT, "object");				\
+    putc ('\n', FILE);							\
+    size_directive_output = 0;						\
+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))		\
+      {									\
+	size_directive_output = 1;					\
+	if (__msp430_data_name_workaround)				\
+	  fprintf (FILE, "#");						\
+	fprintf (FILE, "%s", SIZE_ASM_OP);				\
+	assemble_name (FILE, NAME);					\
+	fprintf (FILE, ",%lu\n",  int_size_in_bytes (TREE_TYPE (DECL))); \
+      }									\
+    ASM_OUTPUT_LABEL(FILE, NAME);					\
+  } while (0)
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	\
+  do {									\
+    const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);		\
+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		\
+	&& ! AT_END && TOP_LEVEL					\
+	&& DECL_INITIAL (DECL) == error_mark_node			\
+	&& !size_directive_output)					\
+      {									\
+	size_directive_output = 1;					\
+	fprintf (FILE, "%s", SIZE_ASM_OP);				\
+	assemble_name (FILE, name);					\
+	fprintf (FILE, ",%lu\n",  int_size_in_bytes (TREE_TYPE (DECL))); \
+      }									\
+  } while (0)
+#define ASM_WEAKEN_LABEL(FILE, NAME)		\
+  do						\
+    {						\
+      fputs ("\t.weak\t", (FILE));		\
+      assemble_name ((FILE), (NAME));		\
+      fputc ('\n', (FILE));			\
+    }						\
+  while (0)
+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)	\
+  sprintf (STRING, "*.%s%lu", PREFIX, (unsigned long)NUM)
+#define SUPPORTS_WEAK 1
+/* Here we must catch r0 - r15 used as variable names */
+#define ASM_OUTPUT_LABELREF(FILE,NAME) 			\
+  do{							\
+    const char *p = NAME;				\
+    while(*p == '_') p++;				\
+    if(*p == 'r' || *p == 'R')				\
+      {							\
+	int val;					\
+	char *endptr;					\
+	p++;						\
+	val = strtol (p, &endptr, 10);			\
+	if(val >= 0 && val <= 15 &&			\
+	   *endptr == 0 )				\
+	  {						\
+	    asm_fprintf ((FILE), "_%U%s", (NAME));	\
+	  }						\
+	else						\
+	  asm_fprintf ((FILE), "%U%s", (NAME));		\
+      }							\
+    else						\
+      asm_fprintf ((FILE), "%U%s", (NAME));		\
+  } while(0)
+#define SET_ASM_OP "\t.set\t"
+/* 17.21.5 Initialization */
+/* 17.21.6 Macros for Initialization */
+#define HAS_INIT_SECTION 1
+/* The code that walks the [cd]tors list is not referenced in
+ * _reset_vector_ or _stop_progExec__; doing so here ensures that code
+ * is only linked in if it's actually needed. */
+#define CTORS_SECTION_ASM_OP "\t.global\t__do_global_ctors\n\t.section\t.ctors"
+#define DTORS_SECTION_ASM_OP "\t.global\t__do_global_dtors\n\t.section\t.dtors"
+/* 17.21.7 Instruction Output */
+#define REGISTER_NAMES				\
+  {						\
+    "r0", "r1", "r2", "r3",			\
+    "r4", "r5", "r6", "r7",			\
+    "r8", "r9", "r10", "r11",			\
+    "r12", "r13", "r14", "r15",			\
+    "argp", "sfp"				\
+  }
+#define PRINT_OPERAND(STREAM, X, CODE) msp430_print_operand (STREAM, X, CODE)
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '~')
+#define PRINT_OPERAND_ADDRESS(STREAM, X) msp430_print_operand_address(STREAM, X)
+/* TODO: WTF? */
+#define ASSEMBLER_DIALECT MSP430_HAS_HWMUL_INTERNAL
+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)		\
+{							\
+  gcc_assert (MSP430_HARD_REGISTER_NUM_P(REGNO));	\
+  fprintf (STREAM, "\tpush\tr%d", REGNO);		\
+}
+#define ASM_OUTPUT_REG_POP(STREAM, REGNO)		\
+{							\
+  gcc_assert (MSP430_HARD_REGISTER_NUM_P(REGNO));	\
+  fprintf (STREAM, "\tpop\tr%d", REGNO);		\
+}
+/* 17.21.8 Dispatch Tables */
+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)		\
+  msp430_output_addr_vec_elt(STREAM, VALUE)
+/* 17.21.9 Exception Region Output */
+/* TODO: "Correct DWARF2 unwind info generation requires prologue and
+ * epilogue to be expanded into series of INSNs, so that DWARF2 info
+ * generator can analyze those INSNs. Currently, prologue and epilogue
+ * are printed to the output file as raw text, so, unwind info cannot
+ * be generated." */
+#define DWARF2_UNWIND_INFO 1
+/* 17.21.10 Alignment Output */
+#define ASM_OUTPUT_SKIP(STREAM, N)		\
+  fprintf (STREAM, "\t.skip %lu,0\n", (unsigned long)N)
+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \
+  fprintf (STREAM, "\t.p2align %d,0\n", POWER)
+
+/* [4.5.2] 17.22 Debugging Info */
+/* 17.22.1 All Debuggers */
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+/* 17.22.2 DBX Options -- not supported */
+/* 17.22.3 DBX Hooks -- not supported */
+/* 17.22.4 File Names and DBX -- not supported */
+/* 17.22.5 SDB and DWARF */
+#define DWARF2_DEBUGGING_INFO 1
+/* 17.22.6 VMS Debug -- not supported */
+
+/* [4.5.2] 17.23 Floating Point */
+/* MSP430 doesn't have floating point, and its emulation uses IEEE.
+ * Presumably, none of this section is relevant. */
+
+/* [4.5.2] 17.24 Mode Switching */
+/* For things like configuring an FPU to single- or double-precision
+ * mode.  Not currently relevant. */
+
+/* [4.5.2] 17.25 Target Attributes */
+/* These are all hooks */
+
+/* [4.5.2] 17.26 Emulated TLS */
+/* Thread Local Storage on a microcontroller?  Please. */
+
+/* [4.5.2] 17.27 MIPS Coprocessors -- not relevant */
+
+/* [4.5.2] 17.28 PCH Target */
+/* Pre-compiled headers might be useful, but we're not using them
+ * now. */
+
+/* [4.5.2] 17.29 C++ ABI */
+/* These are all hooks */
+
+/* [4.5.2] 17.30 Named Address Spaces */
+/* This might be relevant when dealing with near versus far memory.
+ * It is specifically for use by embedded processors. */
+
+/* [4.5.2] 17.31 Misc */
+#define CASE_VECTOR_MODE HImode
+#define MOVE_MAX 2
+#define SHIFT_COUNT_TRUNCATED 1
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+#define Pmode HImode
+#define FUNCTION_MODE HImode
+/* TODO: Look at REGISTER_TARGET_PRAGMAS for IAR/CCS compatibility */
+#define DOLLARS_IN_IDENTIFIERS 0
+#define NO_DOLLAR_IN_LABEL 1
+
+/* Undocumented but legitimate */
+#define OBJECT_FORMAT_ELF
+
+/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+enum msp430_frame_flags_e
+{
+  MSP430_FF_prologue_push_sr = 0x0001,
+  MSP430_FF_use_reti = 0x0002,
+  MSP430_FF_prologue_eint = 0x0004,
+  MSP430_FF_prologue_dint = 0x0008,
+  MSP430_FF_epilogue_eint = 0x0010,
+  MSP430_FF_epilogue_dint = 0x0020,
+  MSP430_FF_epilogue_exit_lpm = 0x0040,
+  MSP430_FF_epilogue_pop_sr = 0x0080,
+  MSP430_FF_use_frame_saver = 0x0100,
+  MSP430_FF_preserve_registers = 0x0200,
+  MSP430_FF_allocate_frame = 0x0400,
+  MSP430_FF_inhibit_return = 0x0800,
+  MSP430_FF_treat_as_main = 0x1000,
+  MSP430_FF_ready_for_return = 0x2000
+};
+
+struct GTY(()) machine_function
+{
+  int initialized;
+  tree signal;
+  tree interrupt;
+  tree naked;
+  tree task;
+  tree wakeup;
+  tree critical;
+  tree reentrant;
+  tree saveprologue;
+  tree noint_hwmul;
+  tree hosted;
+
+  /* Aligned frame size as recorded in expand_prologue */
+  int frame_size;
+  
+  /* Bit-mask indicating the registers saved in expand_prologue */
+  unsigned int saved_regs_mask;
+
+  /* Number of registers saved in expand_prologue */
+  int saved_regs_count;
+
+  /* Bit-mask from msp430_frame_flags_e */
+  unsigned int frame_flags;
+
+  /* Vector offset for interrupt: non-negative multiple of two.
+   * Negative indicates an unbound interrupt.  Field valid only if
+   * interrupt is not null. */
+  int vector_offset;
+
+  /* Non-zero if we need the frame pointer (e.g., for a SR_IRQ
+   * builtin) */
+  int frame_pointer_required;
+};
+
+#ifdef RTX_CODE
+extern int default_rtx_costs (rtx X ATTRIBUTE_UNUSED, enum rtx_code code,
+			      enum rtx_code outer_code ATTRIBUTE_UNUSED);
+#endif
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430.md gcc-4.5.3/gcc/config/msp430/msp430.md
new file mode 100644
index 0000000..a64cacb
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430.md
@@ -0,0 +1,2187 @@
+;; -*- Mode: Scheme -*-
+;;   Machine description for GNU compiler,
+;;   for Texas Instruments msp430 MCUs
+;;   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+;;   Contributed by Dmitry Diky <diwil@mail.ru>
+;;	 GCC 4.x port by Ivan Shcherbakov <mspgcc@sysprogs.org>
+
+;; This work is partially financed by the European Commission under the
+;; Framework 6 Information Society Technologies Project
+;; "Wirelessly Accessible Sensor Populations (WASP)".
+
+;
+
+; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+(include "constraints.md")
+(include "predicates.md")
+
+;; Special characters after '%':
+;;  A  No effect (add 0).
+;;  B  Add 1 to REG number, 2 to MEM address or CONST_INT.
+;;  C	   2		    4
+;;  D	   3		    6
+;;  E  adds nothing to reg but used only with (mem:hi (reg:hi))
+;;  S  Add 2 to memory address if using stack pointer (accounts for pre_dec)
+
+(define_constants
+  [(REG_PC			0)
+   (REG_SP			1)
+   (REG_SR			2)
+   (REG_FP			4)
+   ]
+  )
+
+(define_constants
+  [(UNSPEC_ADDC_REG		0)
+   (UNSPEC_BITTEST_LO		1)
+   (UNSPEC_BITTEST_HI		2)
+   (UNSPEC_ADDC_ANY		5)
+   (UNSPEC_BITTEST		6)
+   (UNSPEC_BITTEST_B		7)
+   (UNSPEC_SUBC_ZERO		16)
+   (UNSPEC_CLRC			30)
+   (UNSPEC_ZERO_EXTEND          100)
+   (UNSPEC_SIGN_EXTEND          101)
+   (UNSPEC_LOAD_SP		105)
+   ]
+)
+
+(define_constants
+  [(UNSPECV_UNDEFINED		0)
+   (UNSPECV_REENT_IN		10)
+   (UNSPECV_ADDC_ZERO		15)
+   (UNSPECV_BIT_CLEAR		40)
+   (UNSPECV_MPY_INHIBIT_INTR		100)
+   (UNSPECV_MPY_RESTORE_INTR		101)
+   (UNSPECV_PUSH_SREG			103)
+   (UNSPECV_SAVE_PC_TO_REG		104)
+   (UNSPECV_PROLOGUE_PUSH 		106)
+   (UNSPECV_POP_R2			107)
+   (UNSPECV_NOP				200)
+   (UNSPECV_DINT			201)
+   (UNSPECV_EINT			202)
+   (UNSPECV_READ_STATUS_REGISTER	203)
+   (UNSPECV_WRITE_STATUS_REGISTER	204)
+   (UNSPECV_BIC_STATUS_REGISTER		205)
+   (UNSPECV_BIS_STATUS_REGISTER		206)
+   (UNSPECV_BIC_SR_IRQ			207)
+   (UNSPECV_BIS_SR_IRQ			208)
+   (UNSPECV_READ_STACK_POINTER		209)
+   (UNSPECV_WRITE_STACK_POINTER		210)
+   (UNSPECV_DELAY_CYCLES		211)
+   ]
+  )
+
+;; Condition code settings.
+
+(define_attr "cc" "none,set_czn,set_zn,set_n,compare,clobber,further,oper,cbranch"
+  (const_string "none"))
+
+(define_attr "type" "branch,branch1,arith"
+  (const_string "arith"))
+
+(define_attr "msp430_has_hwmul" "yes,no"
+  (const (if_then_else (symbol_ref "MSP430_HAS_HWMUL_INTERNAL")
+		       (const_string "yes")
+		       (const_string "no"))))
+
+(define_attr "msp430_noint_hwmul" "" (symbol_ref "MSP430_NOINT_HWMUL"))
+
+; Instruction formats.  Yes, it is irritating that format I (fmt1) has
+; two operands, and format II (fmt2) has one.
+;
+; fmt1 : MSP430, three words : double-operand
+; fmt2 : MSP430, two words : single-operand as dst
+; fmt2s : MSP430, two words : single-operand as src
+; condjmp : MSP430, one word : conditional jump with 10-bit word offset
+; fmt1x : MSP430X, four words : extension word, double-operand (fmt1)
+; fmt2x : MSP430X, three words : extension word, single-operand (fmt2)
+; fmtx : MSP430X, two words : no extension word, single-operand
+(define_attr "instr_format"
+  "undef,fmt1,fmt2,fmt2s,condjmp"
+  (const_string "undef"))
+
+; Multiplier for basic instr_format-based length when template includes
+; multiple instances of the same instruction.
+(define_attr "instr_mult"
+  ""
+  (cond [(match_operand:SI 0 "" "")
+	 (const_int 2)
+	 (match_operand:SF 0 "" "")
+	 (const_int 2)
+	 (match_operand:DI 0 "" "")
+	 (const_int 4)]
+	(const_int 1)))
+
+; Length is calculated in bytes, and depends in most cases solely on
+; the instruction format and the number of times the base instruction
+; appears in the output template (for multi-word operands).
+(define_attr "length" ""
+  (cond [(eq_attr "instr_format" "fmt1")
+	 (mult (const_int 6) (attr "instr_mult"))
+	 (eq_attr "instr_format" "fmt2,fmt2s")
+	 (mult (const_int 4) (attr "instr_mult"))
+	 (eq_attr "instr_format" "condjmp")
+	 (if_then_else  (and (ge (minus (pc) (match_dup 0)) 
+				 (const_int -508))
+			     (le (minus (pc) (match_dup 0)) 
+				 (const_int  508)))
+			(mult (const_int 2) (attr "instr_mult"))
+			(mult (const_int 4) (attr "instr_mult")))]
+	(const_int 0)))
+
+;; SI and SF as blobs are treated the same
+(define_mode_iterator SISF [SI SF])
+
+;; Modes to which QI can extend
+(define_mode_iterator QIEXT [DI SI HI])
+
+;; Modes to which HI can extend
+(define_mode_iterator HIEXT [DI SI])
+
+;; Integer modes that can be widened
+(define_mode_iterator WidenableINTModes [SI HI QI])
+
+;; Integer modes
+(define_mode_iterator INTModes [DI SI HI QI])
+
+;; Operand constraints for INTModes iterators
+(define_mode_attr INTModes_constraint_dst
+  [(QI "=rm")		       ; QImode goes to register or memory
+   (HI "=rm")		       ; HImode goes to register or memory
+   (SI "=&r,m")		       ; SImode inhibits early clobber
+   (DI "=&r,m")])	       ; DImode inhibits early clobber
+
+(define_mode_attr INTModes_constraint_src
+  [(QI "rmi")		       ; QI, HI, SI, DI allow anything
+   (HI "rmi")
+   (SI "rmi,rmi")
+   (DI "rmi,rmi")])
+
+(define_mode_attr INTModes_constraint_matchdst
+  [(QI "0")
+   (HI "0")
+   (SI "0,0")
+   (DI "0,0")])
+
+; Variant for commutative operations
+(define_mode_attr INTModes_commutative_matchdst
+  [(QI "%0")
+   (HI "%0")
+   (SI "%0,0")
+   (DI "%0,0")])
+
+; Variants that allow operation on the frame and stack pointer for HImode
+(define_mode_attr INTModes_frameok_dst
+  [(QI "=rm")		       ; QImode goes to register or memory
+   (HI "=Um")		       ; HImode allows frame and stack pointer
+   (SI "=&r,m")		       ; SImode inhibits early clobber
+   (DI "=&r,m")])	       ; DImode inhibits early clobber
+
+(define_mode_attr INTModes_frameok_src
+  [(QI "rmi")		       ; QI, SI, DI allow anything
+   (HI "Umi")		       ; HImode allows frame and stack pointer
+   (SI "rmi,rmi")
+   (DI "rmi,rmi")])
+
+(define_mode_attr INTModes_cc0_czn
+  [(QI "set_czn")
+   (HI "set_czn")
+   (SI "further")
+   (DI "further")])
+
+; Next wider mode, in lower case
+(define_mode_attr wider_mode
+  [(QI "hi")
+   (HI "si")
+   (SI "di")])
+
+; Next wider mode, in upper case
+(define_mode_attr WIDER_MODE
+  [(QI "HI")
+   (HI "SI")
+   (SI "DI")])
+
+;; ==================
+;; Built-in functions
+
+; nop()
+(define_insn "nop"
+  [(unspec_volatile [(const_int 0)] UNSPECV_NOP)]
+  ""
+  "nop"
+  [(set_attr "cc" "none")
+   (set_attr "length" "2")
+   ])
+
+; dint()
+(define_insn "dint"
+  [(unspec_volatile [(const_int 0)] UNSPECV_DINT)
+   (clobber (reg:HI REG_SR))]
+  ""
+  "dint"
+  [(set_attr "cc" "none")
+   (set_attr "length" "2")
+   ])
+
+; eint()
+(define_insn "eint"
+  [(unspec_volatile [(const_int 0)] UNSPECV_EINT)
+   (clobber (reg:HI REG_SR))]
+  ""
+  "eint"
+  [(set_attr "cc" "none")
+   (set_attr "length" "2")
+   ])
+
+; read_status_register(retloc)
+(define_insn "read_status_register"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=rm")
+	(unspec_volatile:HI [(reg:HI REG_SR)] UNSPECV_READ_STATUS_REGISTER))]
+   ""
+   "mov\tr2, %0"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+
+; write_status_register(sr_value)
+(define_insn "write_status_register"
+  [(set (reg:HI REG_SR)
+	(unspec_volatile:HI [(match_operand:HI 0 "msp430_vwa_general_operand" "rmi")] UNSPECV_WRITE_STATUS_REGISTER))]
+   ""
+   "mov\t%0, r2"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+
+; bic_status_register(sr_value)
+(define_insn "bic_status_register"
+  [(set (reg:HI REG_SR)
+	(unspec_volatile:HI [(match_operand:HI 0 "msp430_vwa_general_operand" "rmi")] UNSPECV_BIC_STATUS_REGISTER))]
+   ""
+   "bic\t%0, r2"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+
+; bis_status_register(sr_value)
+(define_insn "bis_status_register"
+  [(set (reg:HI REG_SR)
+	(unspec_volatile:HI [(match_operand:HI 0 "msp430_vwa_general_operand" "rmi")] UNSPECV_BIS_STATUS_REGISTER))]
+   ""
+   "bis\t%0, r2"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+
+; bic_status_register_on_exit(stack_reference, status_value)
+(define_insn "bic_status_register_on_exit"
+  [(set (match_operand:HI 0 "msp430_vwa_memory_operand" "=m")
+	(unspec_volatile:HI [(match_operand:HI 1 "msp430_vwa_general_operand" "rmi")] UNSPECV_BIC_SR_IRQ))]
+   ""
+   "bic\t%1, %0"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+ 
+; bis_status_register_on_exit(stack_reference, status_value)
+(define_insn "bis_status_register_on_exit"
+  [(set (match_operand:HI 0 "msp430_vwa_memory_operand" "=m")
+	(unspec_volatile:HI [(match_operand:HI 1 "msp430_vwa_general_operand" "rmi")] UNSPECV_BIS_SR_IRQ))]
+   ""
+   "bis\t%1, %0"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+ 
+; read_stack_pointer(retloc)
+(define_insn "read_stack_pointer"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=rm")
+	(unspec_volatile:HI [(reg:HI REG_SP)] UNSPECV_READ_STACK_POINTER))]
+   ""
+   "mov\tr1, %0"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+
+; write_stack_pointer(sr_value)
+(define_insn "write_stack_pointer"
+  [(set (reg:HI REG_SP)
+	(unspec_volatile:HI [(match_operand:HI 0 "msp430_vwa_general_operand" "rmi")] UNSPECV_WRITE_STACK_POINTER))]
+   ""
+   "mov\t%0, r1"
+   [(set_attr "cc" "none")
+    (set_attr "instr_format" "fmt1")])
+
+; delay_cycles(loopreg, count)
+(define_insn "delay_cycles"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(unspec_volatile:HI [(match_operand:HI 1 "const_int_operand" "i")] UNSPECV_DELAY_CYCLES))
+   (clobber (match_dup 0))]
+  ""
+  "mov\t%1, %0
+.L__delay__%=:
+\tdec\t%0
+\tjnz\t.L__delay__%="
+  [(set_attr "cc" "clobber")
+   (set_attr "instr_format" "fmt2") 	; sic
+   (set_attr "length" "8")])
+
+;; extendmn2 (sign extension)
+
+(define_insn "extendqi1"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rm")
+	(unspec:HI [(match_dup 0)] UNSPEC_SIGN_EXTEND))]
+  ""
+  "sxt\t%0"
+  [(set_attr "cc" "set_n")
+   (set_attr "instr_format" "fmt2")])
+
+(define_expand "extendsidi2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (sign_extend:DI (match_operand:SI 1 "general_operand" "")))]
+  ""
+  "msp430_expand_signextend (operands); DONE;")
+(define_expand "extendhi<mode>2"
+  [(set (match_operand:HIEXT 0 "nonimmediate_operand" "")
+        (sign_extend:<MODE> (match_operand:HI 1 "general_operand" "")))]
+  ""
+  "msp430_expand_signextend (operands); DONE;")
+(define_expand "extendqi<mode>2"
+  [(set (match_operand:QIEXT 0 "nonimmediate_operand" "")
+        (sign_extend:<MODE> (match_operand:QI 1 "general_operand" "")))]
+  ""
+  "msp430_expand_signextend (operands); DONE;")
+
+;; zero_extendmn2 (zero extension)
+
+(define_expand "zero_extendsidi2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (zero_extend:DI (match_operand:SI 1 "general_operand" "")))]
+  ""
+  "msp430_expand_zeroextend (operands); DONE;")
+(define_expand "zero_extendhi<mode>2"
+  [(set (match_operand:HIEXT 0 "nonimmediate_operand" "")
+        (zero_extend:<MODE> (match_operand:HI 1 "general_operand" "")))]
+  ""
+  "msp430_expand_zeroextend (operands); DONE;")
+(define_expand "zero_extendqi<mode>2"
+  [(set (match_operand:QIEXT 0 "nonimmediate_operand" "")
+        (zero_extend:<MODE> (match_operand:QI 1 "general_operand" "")))]
+  ""
+  "msp430_expand_zeroextend (operands); DONE;")
+
+;; bswap (standard rtl, not standard insn)
+
+(define_insn "*bswaphi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rm")
+        (bswap:HI (match_operand:HI 1 "nonimmediate_operand" "0")))]
+  ""
+"swpb\t%0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt2")])
+
+(define_expand "bswaphi1"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rm")
+	(bswap:HI (match_dup 0)))]
+  ""
+  "")
+
+;; movm
+
+(define_insn "pushqi1"
+  [(set (mem:QI (pre_modify:HI (reg:HI REG_SP) (plus:HI (reg:HI REG_SP) (const_int -2))))
+	(match_operand:QI 0 "msp430_vwa_general_operand" "rmi"))]
+  ""
+  "push.b\t%S0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt2s")])
+
+(define_insn "movqi_zero_extend"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(zero_extend:HI (match_operand:QI 1 "msp430_vwa_general_operand" "rmi")))]
+  ""
+  "mov.b\t%1, %0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+(define_insn "*movqi2"
+  [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand" "=rm")
+	(match_operand:QI 1 "msp430_vwa_general_operand" "rmi"))]
+  ""
+  "mov.b\t%1, %0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+(define_expand "movqi" 
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "pushhi1"
+  [(set (mem:HI (pre_dec:HI (reg:HI REG_SP)))
+	(match_operand:HI 0 "msp430_vwa_general_operand" "Wmi"))]
+  ""
+  "push\t%S0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt2s")])
+
+(define_insn "pophi1"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=r,w")
+	(mem:HI (post_inc:HI (reg:HI REG_SP))))]
+  ""
+  "pop\t%0"
+  [(set_attr "cc" "none,clobber")
+   (set_attr "instr_format" "fmt1")])
+
+(define_insn "*movhi2"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=Um")
+	(match_operand:HI 1 "msp430_vwa_general_operand" "Umi"))]
+  ""
+  "mov\t%1, %0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+(define_expand "movhi" 
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+        (match_operand:HI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "push<mode>1"
+  [(set (mem:SISF (pre_dec:HI (reg:HI REG_SP)))
+	(match_operand:SISF 0 "msp430_vwa_general_operand" "ST,rmi"))]
+  ""
+  "@
+push\t2+%S0\;push\t2+%S0
+push\t%B0\;push\t%A0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt2s")
+   (set_attr "instr_mult" "2")])
+
+(define_insn "*mov<mode>2"
+  [(set (match_operand:SISF 0 "msp430_vwa_nonimmediate_operand" "=rm")
+	(match_operand:SISF 1 "msp430_vwa_general_operand" "rmi"))]
+  ""
+  {
+    return msp430_mov_noclobber (operands);
+  }
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+(define_expand "mov<mode>" 
+  [(set (match_operand:SISF 0 "nonimmediate_operand" "")
+        (match_operand:SISF 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "pushdi1"
+  [(set (mem:DI (pre_dec:HI (reg:HI REG_SP)))
+	(match_operand:DI 0 "msp430_vwa_general_operand" "ST,rmi"))]
+  ""
+  "@
+push\t6+%S0\;push\t6+%S0\;push\t6+%S0\;push\t6+%S0
+push\t%D0\;push\t%C0\;push\t%B0\;push\t%A0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt2s")
+   (set_attr "instr_mult" "4")])
+
+(define_insn "*movdi2"
+  [(set (match_operand:DI 0 "msp430_vwa_nonimmediate_operand" "=rm")
+	(match_operand:DI 1 "msp430_vwa_general_operand" "rmi"))]
+  ""
+  {
+    return msp430_mov_noclobber (operands);
+  }
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+(define_expand "movdi" 
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (match_operand:DI 1 "general_operand" ""))]
+  ""
+  "")
+
+;; addm3, subm3
+
+(define_split
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "")
+	(plus:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "")
+		     (match_operand:<MODE> 2 "const_int_operand" "")))]
+  "CONST_INT_P (operands[2]) && MSP430_CG_INT_P(-INTVAL (operands[2])) && !MSP430_CG_INT_P(INTVAL (operands[2]))"
+  [(set (match_dup 0)
+	(minus:<MODE> (match_dup 1)
+		      (match_dup 2)))]
+  { operands[2] = gen_int_mode (-INTVAL (operands[2]), <MODE>mode); })
+
+(define_split
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "")
+	(minus:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "")
+		      (match_operand:<MODE> 2 "const_int_operand" "")))]
+  "CONST_INT_P (operands[2]) && MSP430_CG_INT_P(-INTVAL (operands[2])) && !MSP430_CG_INT_P(INTVAL (operands[2]))"
+  [(set (match_dup 0)
+	(plus:<MODE> (match_dup 1)
+		     (match_dup 2)))]
+  { operands[2] = gen_int_mode (-INTVAL (operands[2]), <MODE>mode); })
+
+(define_insn "*add<mode>3_std"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_frameok_dst>")
+        (plus:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "<INTModes_commutative_matchdst>")
+		     (match_operand:<MODE> 2 "msp430_vwa_general_operand" "<INTModes_frameok_src>")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 2, "add", "addc"); }
+  [(set_attr "cc" "<INTModes_cc0_czn>")
+   (set_attr "instr_format" "fmt1")])
+
+(define_insn "*sub<mode>3_std"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_frameok_dst>")
+        (minus:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "<INTModes_constraint_matchdst>")
+		      (match_operand:<MODE> 2 "msp430_vwa_general_operand" "<INTModes_frameok_src>")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 2, "sub", "subc"); }
+  [(set_attr "cc" "<INTModes_cc0_czn>")
+   (set_attr "instr_format" "fmt1")])
+
+(define_expand "add<mode>3" 
+  [(set (match_operand:INTModes 0 "nonimmediate_operand" "")
+        (plus:<MODE> (match_operand:<MODE> 1 "nonimmediate_operand" "")
+		     (match_operand:<MODE> 2 "general_operand" "")))]
+  ""
+  "")
+
+(define_expand "sub<mode>3" 
+  [(set (match_operand:INTModes 0 "nonimmediate_operand" "")
+        (minus:<MODE> (match_operand:<MODE> 1 "nonimmediate_operand" "")
+		      (match_operand:<MODE> 2 "general_operand" "")))]
+  ""
+  "")
+
+;; one_cmplm2 (invert)
+
+(define_insn "one_cmpl<mode>2"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "=rm")
+	(not:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "0")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 0, "inv", NULL); }
+  [(set_attr "cc" "set_czn")
+   (set_attr "instr_format" "fmt2")])
+
+;; negm2
+
+(define_insn "negsf2"
+  [(set (match_operand:SF 0 "msp430_vwa_nonimmediate_operand" "=r,m")
+	(neg:SF (match_operand:SF 1 "msp430_vwa_nonimmediate_operand" "0,0")))]
+  ""
+  "xor\t#0x8000, %B0"
+  [(set_attr "cc" "clobber")
+   (set_attr "length" "4,6")])
+
+(define_expand "neg<mode>2"
+  [(match_operand:INTModes 0 "nonimmediate_operand" "")
+   (match_operand:<MODE> 1 "general_operand" "")]
+  ""
+  {
+    emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[1]));
+    emit_insn (gen_add<mode>3 (operands[0], operands[0], const1_rtx));
+    DONE;
+  })
+
+;; nandm3 (extension)
+
+(define_insn "*nand<mode>3"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_constraint_dst>")
+        (and:<MODE> (not:<MODE> (match_operand:<MODE> 1 "msp430_vwa_general_operand" "<INTModes_constraint_src>"))
+		    (match_operand:<MODE> 2 "msp430_vwa_general_operand" "<INTModes_constraint_matchdst>")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 1, "bic", NULL); }
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+; TODO peephole use bic with op2 inverted is CG-int
+; TODO peephole andhi3 with 0xFF -> and.b or clr.b
+; TODO convert multi-word to word, apply individual optimizations e.g. and -1
+
+(define_insn "and<mode>3"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_constraint_dst>")
+        (and:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "<INTModes_commutative_matchdst>")
+		    (match_operand:<MODE> 2 "msp430_vwa_general_operand" "<INTModes_constraint_src>")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 2, "and", NULL); }
+  [(set_attr "cc" "<INTModes_cc0_czn>")
+   (set_attr "instr_format" "fmt1")])
+
+(define_insn "ior<mode>3"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_constraint_dst>")
+        (ior:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "<INTModes_commutative_matchdst>")
+		    (match_operand:<MODE> 2 "msp430_vwa_general_operand" "<INTModes_constraint_src>")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 2, "bis", NULL); }
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+(define_insn "xor<mode>3"
+  [(set (match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_constraint_dst>")
+        (xor:<MODE> (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "<INTModes_commutative_matchdst>")
+		    (match_operand:<MODE> 2 "msp430_vwa_general_operand" "<INTModes_constraint_src>")))]
+  ""
+  { return msp430_output_template (<MODE>mode, 2, "xor", NULL); }
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+;; absm2
+(define_expand "abs<mode>2"
+  [(match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "<INTModes_constraint_dst>")
+   (match_operand:<MODE> 1 "msp430_vwa_general_operand" "<INTModes_constraint_matchdst>")]
+  ""
+  {
+    rtx test_ge = gen_rtx_GE (GE, operands[0], const0_rtx);
+    rtx dest_label = gen_label_rtx ();
+
+    emit_move_insn (operands[0], operands[1]);
+    emit_jump_insn (gen_cbranch<mode>4 (test_ge, operands[0], const0_rtx, dest_label));
+    emit_insn (gen_neg<mode>2 (operands[0], operands[0]));
+    emit_label (dest_label);
+    DONE;
+  })
+
+(define_insn "abssf2"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m")
+        (abs:SF (match_operand:SF 1 "nonimmediate_operand" "0,0")))]
+""
+"and	#0x7fff, %B0"
+  [(set_attr "length" "2,3")
+   (set_attr "cc" "clobber,clobber")])
+
+;; strlenm
+
+(define_expand "strlenhi"
+  [(match_operand:HI 0 "nonimmediate_operand" "=rm")
+   (match_operand:QI 1 "memory_operand" "m")
+   (match_operand:QI 2 "msp430_vwa_general_operand" "rmi")
+   (match_operand:QI 3 "const_int_operand" "i")]
+  ""
+  {
+    rtx sp_rtx = gen_reg_rtx (Pmode);
+    rtx sp_deref_rtx = gen_rtx_MEM (QImode, sp_rtx);
+    rtx guard_rtx = operands[2];
+    rtx loop_label = gen_label_rtx ();
+    rtx test_ne = gen_rtx_NE (NE, sp_deref_rtx, guard_rtx);
+
+    emit_move_insn (sp_rtx, XEXP (operands[1], 0));
+    emit_insn (gen_subhi3 (sp_rtx, sp_rtx, const1_rtx));
+    emit_label (loop_label);
+    emit_insn (gen_addhi3 (sp_rtx, sp_rtx, const1_rtx));
+    emit_jump_insn (gen_cbranchqi4 (test_ne, sp_deref_rtx, guard_rtx, loop_label));
+    emit_insn (gen_subhi3 (operands[0], sp_rtx, XEXP (operands[1], 0)));
+    DONE;
+  })
+
+;; MATERIAL BEYOND HERE NOT VALIDATED FOR LENGTH
+
+;; =================================================================================================
+
+;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;; This instructin sets Z flag
+
+(define_insn "sez"
+  [(set (cc0) (const_int 0))]
+""
+"setz"
+  [(set_attr "length" "1")
+   (set_attr "cc" "compare")])
+
+
+
+;;========================================================================
+;; compare
+
+(define_expand "cbranch<mode>4"
+  [(set (pc)
+     (if_then_else (match_operator 0 "comparison_operator"
+                    [(match_operand:INTModes 1 "msp430_vwa_nonimmediate_operand" "rm")
+                     (match_operand:<MODE> 2 "msp430_vwa_general_operand" "rmi")])
+      (label_ref (match_operand 3 "" ""))
+      (pc)))]
+""
+{ msp430_emit_cbranch(operands); DONE; }
+)
+
+(define_insn "*cbranchqi"
+  [(set (pc)
+     (if_then_else (match_operator:QI 1 "comparison_operator"
+		    [(match_operand:QI 2 "msp430_vwa_nonimmediate_operand" "rm")
+		     (match_operand:QI 3 "general_operand" "rmi")])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+  ""
+  { return msp430_cbranch(insn, operands); }
+  [(set_attr "length" "9") 
+   (set_attr "cc" "cbranch")])
+
+(define_insn "*cbranchhi"
+  [(set (pc)
+     (if_then_else (match_operator:HI 1 "comparison_operator"
+		    [(match_operand:HI 2 "msp430_vwa_nonimmediate_operand" "rm")
+		     (match_operand:HI 3 "general_operand" "rmi")])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+  ""
+  { return msp430_cbranch(insn, operands); }
+  [(set_attr "length" "9")
+   (set_attr "cc" "cbranch")])
+
+(define_insn "*cbranch_uncoded"
+  [(set (pc)
+     (if_then_else (match_operator 1 "comparison_operator"
+		    [(cc0)
+		     (const_int 0)])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+  ""
+  {
+    rtx op[4];
+    op[0] = operands[0];
+    op[1] = operands[1];
+    op[2] = op[3] = NULL;
+    return msp430_cbranch(insn, op);
+  }
+  [(set_attr "length" "9")
+   (set_attr "cc" "cbranch")])
+
+
+;;========================================================================
+;; noop
+
+
+;;============================================================================
+;; call
+;;
+
+(define_expand "call"
+  [(call (match_operand:HI 0 "general_operand" "")
+         (match_operand:HI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "*call_insn"
+  [(call (mem:HI (match_operand:HI 0 "general_operand" "r,P,mi"))
+         (match_operand:HI 1 "general_operand" "X,X,X"))]
+  ""
+  { return msp430_emit_call(operands); }
+  [(set_attr "length" "1,1,2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "call_value"
+  [(set (match_operand 0 "register_operand" "")
+        (call (match_operand:HI 1 "general_operand" "")
+              (match_operand:HI 2 "general_operand" "")))]
+  ""
+  "")
+
+(define_insn "*call_value_insn"
+  [(set (match_operand 0 "register_operand" "=r,r,r")
+	(call (mem:HI (match_operand:HI 1 "general_operand" "r,P,mi"))
+	      (match_operand:HI 2 "general_operand" "X,X,X")))]
+  ""
+  "call\t%S1"
+  [(set_attr "length" "1,1,2")
+   (set_attr "cc" "clobber")])
+
+;;========================================================================
+;;========================================================================
+;; mult helpers
+
+(define_insn "mpy_inhibit_intr"
+  [(set (mem:HI (pre_dec:HI (reg:HI REG_SP)))
+	(unspec_volatile:HI [(const_int 0)] UNSPECV_MPY_INHIBIT_INTR))]
+  ""
+  "push\tr2\;dint\;nop"
+  [(set_attr "length" "6")])
+
+(define_insn "mpy_restore_intr"
+  [(set (mem:HI (post_inc:HI (reg:HI REG_SP)))
+	(unspec_volatile:HI [(const_int 0)] UNSPECV_MPY_RESTORE_INTR))]
+  ""
+  "pop\tr2"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_insn "addc_zero"
+ [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=r,m")
+   (unspec_volatile:HI [(const_int 0 )] UNSPECV_ADDC_ZERO))]
+ ""
+ "addc\\t#0, %0"
+[(set_attr "length" "1,2")
+ (set_attr "cc" "none")])
+
+(define_insn "subc_zero"
+ [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=r,m")
+   (unspec:HI [(const_int 0 )] UNSPEC_SUBC_ZERO))]
+ ""
+ "subc\\t#0, %0"
+[(set_attr "length" "1,2")
+ (set_attr "cc" "none")])
+
+ 
+
+;;========================================================================
+;;========================================================================
+;;========================================================================
+;;
+;;  Multiplication 
+
+(define_expand "mul<mode>3"
+  [(match_operand:INTModes 0 "msp430_vwa_nonimmediate_operand" "")
+   (match_operand:<MODE> 1 "msp430_vwa_nonimmediate_operand" "")
+   (match_operand:<MODE> 2 "msp430_vwa_general_operand" "")]  
+  ""             
+  {
+    msp430_expand_mul (operands, 1);
+    DONE;
+  })
+
+(define_expand "mul<mode><wider_mode>3"
+  [(match_operand:<WIDER_MODE> 0 "msp430_vwa_nonimmediate_operand" "")
+   (match_operand:WidenableINTModes 1 "msp430_vwa_nonimmediate_operand" "")
+   (match_operand:<MODE> 2 "msp430_vwa_general_operand" "")]
+  ""
+  {
+    msp430_expand_mul (operands, 1);
+    DONE;
+  })
+
+(define_expand "umul<mode><wider_mode>3"
+  [(match_operand:<WIDER_MODE> 0 "msp430_vwa_nonimmediate_operand" "")
+   (match_operand:WidenableINTModes 1 "msp430_vwa_nonimmediate_operand" "")
+   (match_operand:<MODE> 2 "msp430_vwa_general_operand" "")]
+  ""
+  {
+    msp430_expand_mul (operands, 0);
+    DONE;
+  })
+
+;; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % /
+;; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % /
+;; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % /
+;; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % /
+
+(define_expand "divmodqi4"
+  [(set (reg:QI 12) (match_operand:QI 1 "register_operand" ""))
+   (set (reg:QI 10) (match_operand:QI 2 "register_operand" ""))
+   (parallel [(set (reg:QI 12) (div:QI (reg:QI 12) (reg:QI 10)))
+              (set (reg:QI 14) (mod:QI (reg:QI 12) (reg:QI 10)))
+              (clobber (reg:QI 10))
+              (clobber (reg:QI 11))
+	      (clobber (reg:QI 13))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 12))
+   (set (match_operand:QI 3 "register_operand" "") (reg:QI 14))]
+  ""
+  "")
+
+(define_insn "*divmodqi4_call"
+  [(set (reg:QI 12) (div:QI (reg:QI 12) (reg:QI 10)))
+   (set (reg:QI 14) (mod:QI (reg:QI 12) (reg:QI 10)))
+   (clobber (reg:QI 10))
+   (clobber (reg:QI 11))
+   (clobber (reg:QI 13))]
+  ""
+  "call	#__divmodqi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "udivmodqi4"
+  [(set (reg:QI 12) (match_operand:QI 1 "register_operand" ""))
+   (set (reg:QI 10) (match_operand:QI 2 "register_operand" ""))
+   (parallel [(set (reg:QI 12) (udiv:QI (reg:QI 12) (reg:QI 10)))
+              (set (reg:QI 14) (umod:QI (reg:QI 12) (reg:QI 10)))
+              (clobber (reg:QI 10))
+              (clobber (reg:QI 11)) 
+              (clobber (reg:QI 13))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 12))
+   (set (match_operand:QI 3 "register_operand" "") (reg:QI 14))]
+  ""
+  "")
+
+(define_insn "*udivmodqi4_call"
+  [(set (reg:QI 12) (udiv:QI (reg:QI 12) (reg:QI 10)))
+   (set (reg:QI 14) (umod:QI (reg:QI 12) (reg:QI 10)))
+   (clobber (reg:QI 10))
+   (clobber (reg:QI 11)) 
+   (clobber (reg:QI 13))]
+  ""
+  "call	#__udivmodqi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+(define_expand "divmodhi4"
+  [(set (reg:HI 12) (match_operand:HI 1 "register_operand" ""))
+   (set (reg:HI 10) (match_operand:HI 2 "register_operand" ""))
+   (parallel [(set (reg:HI 12) (div:HI (reg:HI 12) (reg:HI 10)))
+              (set (reg:HI 14) (mod:HI (reg:HI 12) (reg:HI 10)))
+              (clobber (reg:HI 10))
+              (clobber (reg:HI 11))
+	      (clobber (reg:HI 13))])
+   (set (match_operand:HI 0 "register_operand" "") (reg:HI 12))
+   (set (match_operand:HI 3 "register_operand" "") (reg:HI 14))]
+  ""
+  "")
+
+(define_insn "*divmodhi4_call"
+  [(set (reg:HI 12) (div:HI (reg:HI 12) (reg:HI 10)))
+   (set (reg:HI 14) (mod:HI (reg:HI 12) (reg:HI 10)))
+   (clobber (reg:HI 10))
+   (clobber (reg:HI 11))
+   (clobber (reg:HI 13))]
+  ""
+  "call	#__divmodhi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "udivmodhi4"
+  [(set (reg:HI 12) (match_operand:HI 1 "register_operand" ""))
+   (set (reg:HI 10) (match_operand:HI 2 "register_operand" ""))
+   (parallel [(set (reg:HI 12) (udiv:HI (reg:HI 12) (reg:HI 10)))
+              (set (reg:HI 14) (umod:HI (reg:HI 12) (reg:HI 10)))
+              (clobber (reg:HI 10))
+              (clobber (reg:HI 11)) 
+              (clobber (reg:HI 13))])
+   (set (match_operand:HI 0 "register_operand" "") (reg:HI 12))
+   (set (match_operand:HI 3 "register_operand" "") (reg:HI 14))]
+  ""
+  "")
+
+(define_insn "*udivmodhi4_call"
+  [(set (reg:HI 12) (udiv:HI (reg:HI 12) (reg:HI 10)))
+   (set (reg:HI 14) (umod:HI (reg:HI 12) (reg:HI 10)))
+   (clobber (reg:HI 10))
+   (clobber (reg:HI 11)) 
+   (clobber (reg:HI 13))]
+  ""
+  "call	#__udivmodhi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+;; ///////////////// SINGLE INTEGER %%%%%%%%%%%%%%%%%
+
+(define_expand "divmodsi4"
+  [(set (reg:SI 12) (match_operand:SI 1 "register_operand" ""))
+   (set (reg:SI 10) (match_operand:SI 2 "register_operand" ""))
+   (parallel [(set (reg:SI 12) (div:SI (reg:SI 12) (reg:SI 10)))
+              (set (reg:SI 14) (mod:SI (reg:SI 12) (reg:SI 10)))
+              (clobber (reg:SI 10))
+              (clobber (reg:HI 9))
+	      (clobber (reg:HI 8))])
+   (set (match_operand:SI 0 "register_operand" "") (reg:SI 12))
+   (set (match_operand:SI 3 "register_operand" "") (reg:SI 14))]
+  ""
+  "")
+
+(define_insn "*divmodsi4_call"
+  [(set (reg:SI 12) (div:SI (reg:SI 12) (reg:SI 10)))
+   (set (reg:SI 14) (mod:SI (reg:SI 12) (reg:SI 10)))
+   (clobber (reg:SI 10))
+   (clobber (reg:HI 9))
+   (clobber (reg:HI 8))]
+  ""
+  "call	#__divmodsi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "udivmodsi4"
+  [(set (reg:SI 12) (match_operand:SI 1 "register_operand" ""))
+   (set (reg:SI 10) (match_operand:SI 2 "register_operand" ""))
+   (parallel [(set (reg:SI 12) (udiv:SI (reg:SI 12) (reg:SI 10)))
+              (set (reg:SI 14) (umod:SI (reg:SI 12) (reg:SI 10)))
+              (clobber (reg:SI 10))
+              (clobber (reg:HI 9)) 
+              (clobber (reg:HI 8))])
+   (set (match_operand:SI 0 "register_operand" "") (reg:SI 12))
+   (set (match_operand:SI 3 "register_operand" "") (reg:SI 14))]
+  ""
+  "")
+
+(define_insn "*udivmodsi4_call"
+  [(set (reg:SI 12) (udiv:SI (reg:SI 12) (reg:SI 10)))
+   (set (reg:SI 14) (umod:SI (reg:SI 12) (reg:SI 10)))
+   (clobber (reg:SI 10))
+   (clobber (reg:HI 9)) 
+   (clobber (reg:HI 8))]
+  ""
+  "call	#__udivmodsi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+
+
+;;========================================================================
+;; MOV STRING
+;;   structures and stuff are word aligned.
+;;   so, QI mode only defined (as HI actually)
+;;
+
+(define_expand "movstrhi"
+  [(parallel [(set (match_operand:BLK 0 "memory_operand" "")
+                   (match_operand:BLK 1 "memory_operand" ""))
+              (use (match_operand 2 "const_int_operand" ""))
+              (use (match_operand 3 "const_int_operand" ""))
+              (clobber (match_dup 4))
+              (clobber (match_dup 5))
+              (clobber (match_dup 6))])]
+  ""
+  {   
+    rtx addr0, addr1;
+    rtx a0, a1;
+    
+    if (GET_CODE (operands[2]) != CONST_INT) FAIL;
+  
+    addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));
+    addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));
+    
+    a0 = operands[0];
+    a1 = operands[1];
+    
+    operands[5] = addr0;
+    operands[6] = addr1;
+  
+    operands[0] = gen_rtx_MEM (BLKmode, addr0);
+    operands[1] = gen_rtx_MEM (BLKmode, addr1);
+  
+    if(INTVAL (operands[2]) <= 10 && !(INTVAL(operands[3])&1))
+    {
+      int x = INTVAL (operands[2]);
+      int y = (x&~1) >> 1;
+      int i = 0;
+       
+      while(y--)
+      {
+        rtx dest = gen_rtx_MEM (HImode, gen_rtx_PLUS(HImode, addr0,GEN_INT(i)));
+        emit_insn(gen_movstrhi5(dest,addr1));
+        i+= 2;
+      }
+  
+      if(x & 1)
+      {
+        rtx real_dst = gen_rtx_MEM (HImode, gen_rtx_PLUS(HImode, addr0,GEN_INT(x-1)));
+        emit_insn(gen_movstrqi5(real_dst,addr1));
+      }
+      DONE;
+    }
+    else if(INTVAL (operands[2]) <= 6 && (INTVAL(operands[3])&1))
+    {
+      int x = INTVAL (operands[2]);
+      int i = 0;
+      
+      while(x--)
+      {
+        rtx dst = gen_rtx_MEM (HImode, gen_rtx_PLUS(HImode, addr0,GEN_INT(i)));
+        emit_insn(gen_movstrqi5(dst,addr1));
+        i++;
+      }
+      DONE;
+    }
+    else
+    {
+    	operands[2] = copy_to_mode_reg (HImode, operands[2]);
+    	operands[4] = operands[2];
+    }
+  })
+
+(define_insn "movstrqi5"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=m")
+	(mem:HI (match_operand:HI 1 "register_operand" "+r")))
+	(set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
+  ""
+  "mov.b	@%1+, %0"
+[(set_attr "length" "2")
+ (set_attr "cc" "clobber")])
+
+(define_insn "movstrhi5"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=m")
+	(mem:HI (match_operand:HI 1 "register_operand" "+r")))
+	(set (match_dup 1) (plus:HI (match_dup 1) (const_int 2)))]
+ ""
+ "mov	@%1+, %0"
+ [(set_attr "length" "2")
+ (set_attr "cc" "clobber")])
+
+(define_insn "*movstrhi_insn"
+  [(set (mem:BLK (match_operand:HI 0 "register_operand" "r"))
+        (mem:BLK (match_operand:HI 1 "register_operand" "r")))
+   (use (match_operand:HI 2 "register_operand" "r"))
+   (use (match_operand 3 "const_int_operand" "i"))
+   (clobber (match_dup 2))
+   (clobber (match_dup 0))
+   (clobber (match_dup 1))]
+  ""
+  "* return msp430_movstrhi_insn(insn, operands);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*movstrqi_insn"
+  [(set (mem:BLK (match_operand:HI 0 "register_operand" "r"))
+        (mem:BLK (match_operand:HI 1 "register_operand" "r")))
+   (use (match_operand:QI 2 "register_operand" "r"))
+   (use (match_operand 3 "const_int_operand" "i"))
+   (clobber (match_dup 2))
+   (clobber (match_dup 0))
+   (clobber (match_dup 1))]
+  ""
+  "* return msp430_movstrhi_insn(insn, operands);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+
+
+;;========================================================================
+;; CLEAR STRING
+
+(define_expand "clrstrhi"
+  [(parallel [(set (match_operand:BLK 0 "memory_operand" "")
+                   (const_int 0))
+              (use (match_operand 1 "const_int_operand" ""))
+              (use (match_operand 2 "const_int_operand" "i"))
+              (clobber (match_dup 3))
+              (clobber (match_dup 4))])]
+  ""
+  {
+    rtx addr0;
+  
+    if (GET_CODE (operands[1]) != CONST_INT) FAIL;
+    operands[1] = copy_to_mode_reg (HImode, operands[1]);
+    operands[3] = operands[1];
+    addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));
+    operands[4] = addr0;
+    operands[0] = gen_rtx_MEM (BLKmode, addr0);
+  })
+  
+
+(define_insn "*clrstrhi_insn"
+  [(set (mem:BLK (match_operand:HI 0 "register_operand" "r"))
+        (const_int 0))
+   (use (match_operand:HI 1 "register_operand" "r")) 
+   (use (match_operand 2 "const_int_operand" "i"))
+   (clobber (match_dup 1)) 
+   (clobber (match_dup 0))]
+  ""
+  "* return msp430_clrstrhi_insn(insn, operands);"
+[(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+
+;;  random operations:
+
+(define_insn "*opqi3_pi"
+  [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand"          "=r,m")
+	(match_operator:QI 3 "three_operands_msp430"
+	 [(match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "%0,0")
+	 (mem:QI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%3.b	@%2+, %0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+(define_insn "*ophi3_pi"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"          "=r,m")
+	(match_operator:HI 3 "three_operands_msp430"
+	 [(match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "%0,0")
+	  (mem:HI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%3	@%2+, %0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+(define_insn "*opsi3_pi"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"          "=r,m")
+	(match_operator:SI 3 "three_operands_msp430"
+	 [(match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "%0,0")
+	  (mem:SI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%A3\\t@%2+, %A0
+\\t%B3\\t@%2+, %B0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+(define_insn "*opdi3_pi"
+  [(set (match_operand:DI 0 "msp430_vwa_nonimmediate_operand"          "=r,m")
+	(match_operator:DI 3 "three_operands_msp430"
+	 [(match_operand:DI 1 "msp430_vwa_nonimmediate_operand" "%0,0")
+	  (mem:DI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%A3\\t@%2+, %A0
+\\t%B3\\t@%2+, %B0
+\\t%C3\\t@%2+, %C0
+\\t%D3\\t@%2+, %D0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+;; ==========================================================================
+;; there are shift helpers
+
+(define_insn "trunchiqi"
+  [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand" "=r,m") 
+	(truncate:QI (match_operand:HI 1 "register_operand" "r,r")))]
+""
+"mov.b	%1, %0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "none,none")])
+
+(define_insn "truncsihi"
+  [(set (match_operand:HI 0 "register_operand" "=r") 
+	(truncate:HI (match_operand:SI 1 "register_operand" "r")))]
+""
+"mov	%1, %0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+
+(define_insn "truncsiqi"
+  [(set (match_operand:QI 0 "register_operand" "=r") 
+	(truncate:QI (match_operand:SI 1 "register_operand" "r")))]
+""
+"mov.b	%1, %0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+
+(define_insn "truncdiqi"
+  [(set (match_operand:QI 0 "register_operand" "=r") 
+	(truncate:QI (match_operand:DI 1 "register_operand" "r")))]
+""
+"mov.b	%1, %0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+(define_insn "truncdisi"
+  [(set (match_operand:SI 0 "register_operand" "=r") 
+	(truncate:SI (match_operand:DI 1 "register_operand" "r")))]
+""
+"mov	%A1,%A0
+	mov    %B1,%B0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+
+;;<< << << << << << << << << << << << << << << << << << << << << << << << <<
+;; << << << << << << << << << << << << << << << << << << << << << << << <<
+;;<< << << << << << << << << << << << << << << << << << << << << << << << <<
+;; << << << << << << << << << << << << << << << << << << << << << << << <<
+;;<< << << << << << << << << << << << << << << << << << << << << << << << <<
+;; arithmetic shift left
+
+(define_expand "ashlqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"       "")
+        (ashift:QI (match_operand:QI 1 "nonimmediate_operand" "")
+                   (match_operand:QI 2 "general_operand"  "")))]
+  ""
+  {
+    if(!const_int_operand(operands[2],VOIDmode))
+      {
+        rtx op0,op1;
+     
+	op0 = force_reg(QImode,operands[0]);
+	op1 = force_reg(QImode,operands[1]);
+	operands[2] = copy_to_mode_reg(QImode,operands[2]);
+	emit_insn(gen_ashlqi3_cnt (op0, op1, operands[2]));
+	emit_move_insn(operands[0],op0);
+	/*emit_move_insn(operands[1],op1);*/ 
+	DONE;
+      }
+    else if(!register_operand(operands[1], QImode) 
+	    && is_shift_better_in_reg(operands))
+      {
+        operands[1] = copy_to_mode_reg(QImode,operands[1]);
+	emit_insn (gen_ashlqi3fnl(operands[0], operands[1], operands[2]));
+	DONE;
+      }
+  })
+
+(define_insn "ashlqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (ashift:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashlqi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "ashlqi3fnl"
+  [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand"       "=rm")
+        (ashift:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "0")
+                   (match_operand:QI 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashlqi3(insn, operands);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; HImode  ======================================
+(define_expand "ashlhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (ashift:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{ msp430_ashlhi3(operands); DONE; }")
+
+(define_insn "ashlhi3_cnt"
+  [(parallel [(set (match_operand:HI 0 "register_operand"       "=r")
+	      (ashift:HI (match_operand:HI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "r")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_ashlhi3(insn, operands);"
+  [(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlhi3_1"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (ashift:HI (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+                   (const_int 1)))]
+  ""
+  "rla\\t%0"
+  [(set_attr "length" "1,2,3")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlhi3_15"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (ashift:HI (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+                   (const_int 15)))]
+  ""
+  "rra\\t%0
+\\tclr\\t%0
+\\trrc\\t%0"
+  [(set_attr "length" "3,5,7")
+   (set_attr "cc" "clobber")])
+
+
+;; SImode ======================================
+
+(define_expand "ashlsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"       "")
+        (ashift:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{ msp430_ashlsi3(operands); DONE; }")
+
+(define_insn "ashlsi3_cnt"
+  [(parallel [(set (match_operand:SI 0 "register_operand"       "=r")
+	      (ashift:SI (match_operand:SI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashlsi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlsi3_31"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (ashift:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+                   (const_int 31)))]
+  ""
+"rra\\t%A0
+\\tclr\\t%A0
+\\tclr\\t%B0
+\\trrc\\t%B0"
+[(set_attr "length" "4,7,8")
+  (set_attr "cc" "clobber")])
+
+
+(define_insn "*ashlsi3_8"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (ashift:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+                   (const_int 8)))]
+  ""
+"*{
+    if(which_alternative==0)
+    {
+      return \"xor.b\\t%A0, %B0\\n\\txor\\t%A0, %B0\\n\\tswpb\\t%B0\\n\\tand.b\\t#-1, %A0\\n\\tswpb\\t%A0 \";
+    }
+    else
+    {
+      return \"xor.b\\t%A0, %B0\\n\\tclr.b\\t%L0\\n\\txor\\t%A0, %B0\\n\\tswpb\\t%B0\\n\\tclr.b\\t%J0\\n\\tswpb\\t%A0\";
+    }
+}"
+  [(set_attr "length" "5,11,12")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlsi3_16"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,m,r,m")
+        (ashift:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "rR,rR,m,m")
+                   (const_int 16)))]
+""
+"mov	%A1, %B0
+\tmov	#0, %A0"
+[(set_attr "length" "1,2,2,3")
+  (set_attr "cc" "clobber")])
+
+(define_insn "*ashlsi3_1"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=m,R,r")
+        (ashift:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+                   (const_int 1)))]
+  ""
+"rla\\t%A0
+\\trlc\\t%B0"
+[(set_attr "length" "6,5,2")
+  (set_attr "cc" "clobber")])
+
+;; DImode ======================================
+
+(define_expand "ashldi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "")
+        (ashift:DI (match_operand:DI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{
+   if( !const_int_operand(operands[2],VOIDmode) ||
+       INTVAL(operands[2]) > 1)
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(DImode,operands[0]);
+     op1 = force_reg(DImode,operands[1]);
+     operands[2] = copy_to_mode_reg(HImode,operands[2]);
+     emit_insn(gen_ashldi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], DImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(DImode,operands[1]);
+      emit_insn (gen_ashldi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "ashldi3_cnt"
+  [(parallel [(set (match_operand:DI 0 "register_operand"       "=r")
+	      (ashift:DI (match_operand:DI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_ashldi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "ashldi3fnl"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "=rm")
+        (ashift:DI (match_operand:DI 1 "nonimmediate_operand" "0")
+                   (match_operand:HI 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashldi3(insn, operands);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>     
+;; arithmetic shift right
+
+(define_expand "ashrqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"       "")
+        (ashiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "")
+                   (match_operand:QI 2 "general_operand"  "")))]
+""
+"{
+   if(!const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(QImode,operands[0]);
+     op1 = force_reg(QImode,operands[1]);
+     operands[2] = copy_to_mode_reg(QImode,operands[2]);
+     emit_insn(gen_ashrqi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], QImode) 
+		&& INTVAL(operands[2])>2 
+		&& INTVAL(operands[2])!=7)
+   {
+      operands[1] = copy_to_mode_reg(QImode,operands[1]);
+      emit_insn (gen_ashrqi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+   else if(INTVAL(operands[2]) == 7)
+   {
+      /* to do it simple we need a register */
+      rtx r1 = gen_reg_rtx(HImode);
+      emit_insn(gen_extendqihi2(r1,operands[1]));
+      emit_insn(gen_bswaphi1(r1));
+      emit_insn(gen_trunchiqi(operands[0],r1));
+      DONE;
+   }
+}")
+
+(define_insn "ashrqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashrqi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "ashrqi3fnl"
+  [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand"       "=rm")
+        (ashiftrt:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "0")
+                   (match_operand:QI 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashrqi3(insn, operands);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; HImode  ======================================
+(define_expand "ashrhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (ashiftrt:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{msp430_ashrhi3(operands); DONE; }")
+
+(define_insn "ashrhi3_cnt"
+  [(parallel [(set (match_operand:HI 0 "register_operand"       "=r")
+	      (ashiftrt:HI (match_operand:HI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashrhi3(insn, operands);"
+  [(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*ashrhi3_1"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"       "=rR,m")
+        (ashiftrt:HI (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "0,0")
+		     (const_int 1)))]
+  ""
+  "rra\\t%0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*ashrhi3_15"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"       "=rR,m")
+        (ashiftrt:HI (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "0,0")
+		     (const_int 15)))]
+  ""
+  "swpb\\t%0
+\\tsxt\\t%0
+\\tswpb\\t%0
+\\tsxt\\t%0"
+  [(set_attr "length" "4,8")
+   (set_attr "cc" "clobber")])
+
+
+
+;; SImode ======================================
+
+(define_expand "ashrsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"       "")
+        (ashiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{msp430_ashrsi3(operands);DONE; }")
+
+(define_insn "ashrsi3_cnt"
+  [(parallel [(set (match_operand:SI 0 "register_operand"       "=r")
+	      (ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashrsi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashrsi3_1"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=rR,m")
+        (ashiftrt:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0")
+		     (const_int 1)))]
+  ""
+  "rra\\t%B0
+\\trrc\\t%A0"
+  [(set_attr "length" "2,4")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashrsi3_31"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (ashiftrt:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+		     (const_int 31)))]
+  ""
+"swpb	%B0
+\\tsxt	%B0
+\\tswpb	%B0
+\\tsxt	%B0
+\\tmov	%B0, %A0"
+  [(set_attr "length" "5,10,10")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashrsi3_8"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (ashiftrt:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+		     (const_int 8)))]
+  ""
+"*{
+    if(which_alternative==0)
+    {
+      return \" swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\txor\\t%B0, %A0\\n\\tsxt\\t%B0\";
+    }
+    else
+    {
+      return \" swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\tclr.b\\t%J0\\n\\txor\\t%B0, %A0\\n\\tsxt\\t%B0\";
+    }
+}"
+  [(set_attr "length" "5,11,12")
+   (set_attr "cc" "clobber")])
+
+;; DImode ======================================
+
+(define_expand "ashrdi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "")
+        (ashiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{
+   if( !const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(DImode,operands[0]);
+     op1 = force_reg(DImode,operands[1]);
+     operands[2] = copy_to_mode_reg(HImode,operands[2]);
+     emit_insn(gen_ashrdi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], DImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(DImode,operands[1]);
+      emit_insn (gen_ashrdi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "ashrdi3_cnt"
+  [(parallel [(set (match_operand:DI 0 "register_operand"       "=r")
+	      (ashiftrt:DI (match_operand:DI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_ashrdi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "ashrdi3fnl"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "=rm")
+        (ashiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "0")
+                   (match_operand:HI 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashrdi3(insn, operands);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+
+
+
+
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;; logical shift right
+
+(define_expand "lshrqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"       "")
+        (lshiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "")
+                   (match_operand:QI 2 "general_operand"  "")))]
+""
+"{
+   if(!const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(QImode,operands[0]);
+     op1 = force_reg(QImode,operands[1]);
+     operands[2] = copy_to_mode_reg(QImode,operands[2]);
+     emit_insn(gen_lshrqi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], QImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(QImode,operands[1]);
+      emit_insn (gen_lshrqi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_expand "lshrqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"")
+
+(define_insn "*lshrqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_lshrqi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "lshrqi3fnl"
+  [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand"       "=rm")
+        (lshiftrt:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "0")
+                   (match_operand:QI 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_lshrqi3(insn, operands);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; HImode  ======================================
+
+(define_insn "clrc"
+ [(unspec:HI [(const_int 123454321)] UNSPEC_CLRC)]
+""
+ "clrc"
+[(set_attr "length" "1")
+  (set_attr "cc" "clobber")])
+
+ 
+(define_expand "lshrhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (lshiftrt:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand 2 "general_operand"  "")))]
+""
+"{msp430_lshrhi3(operands); DONE; }")
+
+(define_insn "lshrhi3_cnt"
+  [(parallel [(set (match_operand:HI 0 "register_operand"       "=r")
+	      (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_lshrhi3(insn, operands);"
+  [(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*lshrhi3_15"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (lshiftrt:HI (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+		     (const_int 15)))]
+  ""
+  "rla\\t%0
+\\tclr\\t%0
+\\trlc\\t%0"
+  [(set_attr "length" "3,6,8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*lshrhi3_1"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand"       "=rR,m")
+        (lshiftrt:HI (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "0,0")
+		     (const_int 1)))]
+  ""
+"clrc
+\\trrc\\t%0"
+  [(set_attr "length" "2,3")
+   (set_attr "cc" "clobber")])
+
+;; SImode ======================================
+
+(define_expand "lshrsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"       "")
+        (lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{ msp430_lshrsi3(operands); DONE; }")
+
+(define_insn "lshrsi3_cnt"
+  [(parallel [(set (match_operand:SI 0 "register_operand"       "=r")
+	      (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_lshrsi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*lshrsi3_31"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (lshiftrt:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+		     (const_int 31)))]
+  ""
+"rla	%B0
+\\tclr	%B0
+\\tclr	%A0
+\\trlc	%A0"
+  [(set_attr "length" "4,9,10")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*lshrsi3_8"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (lshiftrt:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+		     (const_int 8)))]
+  ""
+"*{
+    if(which_alternative==0)
+    {
+      return \"swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\txor\\t%B0, %A0\\n\\tand.b\\t#-1, %B0\";
+    }
+    else
+    {
+      return \"swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\tclr.b\\t%J0\\n\\txor\\t%B0, %A0\\n\\tclr.b\\t%L0\";
+    }
+}"
+  [(set_attr "length" "5,11,12")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*lshrsi3_1"
+  [(set (match_operand:SI 0 "msp430_vwa_nonimmediate_operand"       "=r,R,m")
+        (lshiftrt:SI (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "0,0,0")
+		     (const_int 1)))]
+  ""
+"clrc
+\\trrc\\t%B0
+\\trrc\\t%A0"
+  [(set_attr "length" "3,4,5")
+   (set_attr "cc" "clobber")])
+
+;; DImode ======================================
+
+(define_expand "lshrdi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "")
+        (lshiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{
+   if( !const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(DImode,operands[0]);
+     op1 = force_reg(DImode,operands[1]);
+     operands[2] = copy_to_mode_reg(HImode,operands[2]);
+     emit_insn(gen_lshrdi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], DImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(DImode,operands[1]);
+      emit_insn (gen_lshrdi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "lshrdi3_cnt"
+  [(parallel [(set (match_operand:DI 0 "register_operand"       "=r")
+	      (lshiftrt:DI (match_operand:DI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_lshrdi3(insn, operands);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "lshrdi3fnl"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "=rm")
+        (lshiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "0")
+                   (match_operand:HI 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_lshrdi3(insn, operands);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; =====================================================================
+;; single bit extract
+;; as soon as all operatoins performed on io registers
+;; let use only QImode. 
+
+(define_expand "extv"
+ [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand" "")
+       (sign_extract:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "") 
+			(match_operand 2 "const_int_operand" "")
+			(match_operand 3 "const_int_operand" "")))]
+""
+"{
+    if(INTVAL(operands[2]) != 1 || INTVAL(operands[3]) <= 0)
+      FAIL;
+}")
+
+(define_insn "*extv" 
+ [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand" "=r,r,r,r,m,m,m,m")
+       (sign_extract:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "r,m,r,m,r,m,r,m") 
+			(const_int 1)
+			(match_operand 2 "const_int_operand" "P,P,i,i,P,P,i,i")))]
+ ""
+"* {
+  operands[2] = GEN_INT(1<<INTVAL(operands[2]));
+  return 	\"bit.b\\t%2, %1\\n\"
+		\"\\tclr.b\\t%0\\n\"
+		\"\\tadc.b\\t%0\";
+}"
+  [(set_attr "length" "3,4,4,5,5,6,6,7")
+     (set_attr "cc" "clobber")])
+
+(define_expand "extzv"
+ [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand" "")
+       (zero_extract:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "") 
+			(match_operand 2 "const_int_operand" "")
+			(match_operand 3 "const_int_operand" "")))]
+""
+"{
+    if(INTVAL(operands[2]) != 1 || INTVAL(operands[3]) <= 0) 
+      FAIL;
+}")
+
+(define_insn "*extzv" 
+ [(set (match_operand:QI 0 "msp430_vwa_nonimmediate_operand" "=r,r,r,r,m,m,m,m")
+       (zero_extract:QI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "r,m,r,m,r,m,r,m")
+			(match_operand 2 "const_int_operand" "")
+			(match_operand 3 "const_int_operand" "P,P,i,i,P,P,i,i")))]
+ "INTVAL(operands[2]) == 1"
+"* {
+  operands[3] = GEN_INT(1<<INTVAL(operands[3]));
+  return 	\"bit.b\\t%3, %1\\n\"
+		\"\\tclr.b\\t%0\\n\"
+		\"\\tadc.b\\t%0\";
+}"
+  [(set_attr "length" "3,4,4,5,5,6,6,7")
+     (set_attr "cc" "clobber")])
+
+
+
+;;=======================================================================
+;;  various BRANCH insns...
+;;
+;;
+
+;; Unconditional jump instruction.
+(define_insn "jump"
+  [(set (pc) (label_ref (match_operand 0 "" "")))]
+  ""
+  "*
+{
+  int dist = msp430_jump_dist(operands[0],insn);
+  if (dist<500 && dist>-500)
+    return \"jmp	%0\";
+  return \"br	#%0\"; 
+}"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+; indirect jump
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:HI 0 "general_operand" "mri"))]
+  ""
+  "br\t%0"
+  [(set_attr "cc" "none")
+   (set_attr "instr_format" "fmt1")])
+
+
+;;=======================================================================
+;;=======================================================================
+;;=======================================================================
+;;=======================================================================
+
+
+;;=======================================================================
+;;
+;;    CASE
+;;
+
+;; Table helper
+(define_insn "tablejump"
+  [(set (pc) (match_operand:HI 0 "general_operand" "rRP,i,m"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "br	%0	;	%1"
+ [(set_attr "length" "1,2,2")   
+   (set_attr "cc" "clobber")])
+
+
+;; =============================================================
+;; match De Morgan's law
+
+;; =============================================================
+;; PEEPHOLES
+
+;; a &= ~b;
+
+(define_insn "*bit_clear"
+ [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=r,m,m,r") 
+       (unspec_volatile:HI [(match_operand:HI 1 "msp430_vwa_general_operand" "rRP,mi,rRP,mi")] UNSPECV_BIT_CLEAR))]
+""
+"bic	%1, %0"
+  [(set_attr "length" "1,3,2,2")
+     (set_attr "cc" "none")])
+
+;; these two for:
+;; (ulong) x = (ulong) func() << 16;
+;; x |= func();
+;; func() is uint
+;;
+
+;;
+;; these for some shifts and stuff.
+;; every peephole saves up to 4 bytes.
+;;
+
+(define_insn "*addc_reg"
+  [(set (match_operand:HI 0 "register_operand" "=r,r") 
+	(unspec:HI [(match_operand:HI 1 "register_operand" "%0,0") 
+		    (match_operand:HI 2 "msp430_vwa_general_operand" "rP,mi")] UNSPEC_ADDC_REG))]
+""
+"addc	%2, %0"
+[(set_attr "length" "1,2")
+   (set_attr "cc" "clobber,clobber")])
+
+
+(define_insn "*addc_any"
+  [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "=m,m") 
+	(unspec:HI [(match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "%0,0") 
+		    (match_operand:HI 2 "msp430_vwa_general_operand" "rP,mi")] UNSPEC_ADDC_ANY))]
+""
+"addc	%2, %0"
+[(set_attr "length" "2,3")
+   (set_attr "cc" "clobber,clobber")])
+
+
+;; =========================================================================
+;;  This one for bit tests like:
+;;	volatile long a;
+;;	while(a&CONST_HALFNIBBLE) ;
+
+(define_insn "*bittest_lo"
+  [(set (cc0) 
+	(unspec:SI [(match_operand:SI 0 "msp430_vwa_nonimmediate_operand" "r,r,m,m") 
+		    (match_operand:SI 1 "msp430_vwa_general_operand" "rPR,mi,rPR,mi")] UNSPEC_BITTEST_LO))]
+""
+"bit	%A1,%A0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+(define_insn "*bittest_hi"
+  [(set (cc0) 
+	(unspec:SI [(match_operand:SI 0 "msp430_vwa_nonimmediate_operand" "r,r,m,m") 
+		    (match_operand:SI 1 "msp430_vwa_general_operand" "rPR,mi,rPR,mi")] UNSPEC_BITTEST_HI))]
+""
+"bit	%B1,%B0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+;;
+;;  The same for HI mode: while(smts&0xXXXX) ;
+;;
+(define_insn "*bittest"
+  [(set (cc0)
+        (unspec:HI [(match_operand:HI 0 "msp430_vwa_general_operand" "r,r,m,m")
+                    (match_operand:HI 1 "msp430_vwa_general_operand" "rPR,mi,rPR,mi")] UNSPEC_BITTEST))]
+""
+"bit	%1,%0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+
+;; The same for QI mode
+
+(define_insn "*bittest_b"
+  [(set (cc0)
+        (unspec:QI [(match_operand:QI 0 "msp430_vwa_general_operand" "r,r,m,m")
+                    (match_operand:QI 1 "msp430_vwa_general_operand" "rPR,mi,rPR,mi")] UNSPEC_BITTEST_B))]
+""
+"bit.b	%1,%0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+
+
+;; ======================================================================
+
+;; Enable Interrupts
+;; return insn
+(define_insn "return"
+  [(return)]
+  "(reload_completed && cfun && cfun->machine
+    && (cfun->machine->frame_flags & MSP430_FF_ready_for_return)
+    && !(cfun->machine->frame_flags & MSP430_FF_inhibit_return)
+    && !(cfun->machine->frame_flags & MSP430_FF_use_reti))"
+  "ret"
+  [(set_attr "cc" "none")
+   (set_attr "length" "1")])
+
+(define_insn "*return_pop_sr"
+  [(return)]
+  "(reload_completed && cfun && cfun->machine
+    && (cfun->machine->frame_flags & MSP430_FF_ready_for_return)
+    && !(cfun->machine->frame_flags & MSP430_FF_inhibit_return)
+    && (cfun->machine->frame_flags & MSP430_FF_use_reti))"
+  "reti"
+  [(set_attr "cc" "none")
+   (set_attr "length" "1")])
+
+(define_insn "*return_fallthru"
+  [(return)]
+  "(reload_completed && cfun && cfun->machine
+    && (cfun->machine->frame_flags & MSP430_FF_ready_for_return)
+    && (cfun->machine->frame_flags & MSP430_FF_inhibit_return))"
+  ""
+  [(set_attr "cc" "none")
+   (set_attr "length" "0")])
+
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+  "
+  {
+    expand_prologue (); 
+    DONE;
+  }")
+
+(define_expand "epilogue"
+  [(const_int 0)]
+  ""
+  "
+  {
+    expand_epilogue (); 
+    DONE;
+  }")
+
+(include "peephole.md")
diff --git gcc-4.5.3.orig/gcc/config/msp430/msp430.opt gcc-4.5.3/gcc/config/msp430/msp430.opt
new file mode 100644
index 0000000..ae3aed7
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/msp430.opt
@@ -0,0 +1,53 @@
+; Options for the MSP430 port of the compiler.
+; Converted from msp430.c (gcc 3.2.3 port)
+
+; For every option from this file (such as PROF_STD), a corresponding command-line option is checked and an internal GCC flag is set.
+; To check such flag one should use the TARGET_xxx macro (such as TARGET_PROF_STD).
+; This replaces the deprecated #define TARGET_SWITCHES syntax
+; String options are defined similarily and replace the #define TARGET_OPTIONS syntax
+
+;; This work is partially financed by the European Commission under the
+;; Framework 6 Information Society Technologies Project
+;; "Wirelessly Accessible Sensor Populations (WASP)".
+
+mdisable-hwmul
+Target Report Mask(NO_HWMUL)
+Disable hardware multiplier (DEPRECATED; use -mmpy=none)
+
+minline-hwmul
+Target Report Mask(INLINESIHWMUL)
+Issue inline multiplication code for 32-bit integers
+
+mnoint-hwmul
+Target Report Mask(NOINT_HWMUL)
+Assume interrupt routine does not do hardware multiply
+
+mno-volatile-workaround
+Target Report Mask(NVWA)
+Do not perform volatile workaround for bitwise operations
+
+msave-prologue
+Target Report Mask(SAVE_PROLOGUE)
+Use subroutine call for function prologue/epilogue when possible
+
+mdisable-watchdog
+Target Var(msp430_disable_watchdog) Init(1)
+Link the crt0 modules that disable the watchdog on startup
+
+; ---------------------------------------- Here start the string options imported from TARGET_OPTIONS macro ----------------------------------------
+
+mmcu=
+Target RejectNegative Joined Var(msp430_mcu_name) Init("msp430f169")
+-mmcu=MCU	Select the target MCU
+
+mcpu=
+Target RejectNegative Joined Var(msp430_opt_cpu)
+-mcpu=CPU	Select the CPU model: 430, 430x, 430xv2
+
+mmpy=
+Target RejectNegative Joined Var(msp430_opt_mpy)
+-mmpy=MPY	Define available hardware multiply: none, 16, 16se, 32, 32dw
+
+mivcnt=
+Target RejectNegative Joined Var(msp430_opt_ivcnt)
+-mivcnt=IVCNT	Specify number of interrupt vectors on chip: 16, 32, 64
diff --git gcc-4.5.3.orig/gcc/config/msp430/peephole.md gcc-4.5.3/gcc/config/msp430/peephole.md
new file mode 100644
index 0000000..0841eee
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/peephole.md
@@ -0,0 +1,767 @@
+;; -*- Mode: Scheme -*-
+;;   Machine description for GNU compiler,
+;;   for Texas Instruments msp430 MCUs
+;;   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+;;   Contributed by Dmitry Diky <diwil@mail.ru>
+;;	 GCC 4.x port by Ivan Shcherbakov <mspgcc@sysprogs.org>
+
+;; This work is partially financed by the European Commission under the
+;; Framework 6 Information Society Technologies Project
+;; "Wirelessly Accessible Sensor Populations (WASP)".
+
+; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+; Old-style RTL-to-text optimizers
+
+(define_peephole 
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "register_operand" ""))) 
+   (set (match_operand:HI 2 "register_operand" "") 
+	(plus:HI (match_dup 2) (match_dup 0)))]
+"dead_or_set_in_peep(1,insn,operands[0])" 
+"sxt	%1
+	add	%1, %2"
+[(set_attr "length" "3")
+   (set_attr "cc" "clobber")])
+
+
+(define_peephole 
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" ""))) 
+   (set (match_operand:HI 2 "register_operand" "") (match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])" 
+"mov.b	%1, %2
+	sxt	%2"
+[(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;; ============================================================= 
+;; a = (uint16_t)( (uint8_t)SFR ) << 8;
+;; (inderect_jump + 50)
+(define_peephole 
+  [(set (match_operand:QI 0 "register_operand" "") 
+	(match_operand:QI 1 "msp430_vwa_memory_operand" "m"))
+   (set (match_operand:HI 2 "register_operand" "")
+	(ashift:HI (match_dup 2) (const_int 8)))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+"mov.b	%1, %0
+	swpb	%2"
+[(set_attr "length" "3")
+   (set_attr "cc" "clobber")])
+
+; New-style RTL-to-RTL optimizers
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "general_operand" ""))
+   (set (mem:HI (post_dec (reg:HI 1)))
+	(match_dup 0))]
+"dead_or_set_in_peep(1, insn, operands[0])"
+  [(set (mem:HI (post_dec (reg:HI 1)))
+	(match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "general_operand" ""))
+   (set (mem:SI (post_dec (reg:HI 1)))
+	(match_dup 0))]
+"dead_or_set_in_peep(1, insn, operands[0])"
+  [(set (mem:SI (post_dec (reg:HI 1)))
+	(match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SF 0 "register_operand" "") 
+	(match_operand:SF 1 "general_operand" ""))
+   (set (mem:SF (post_dec (reg:HI 1)))
+	(match_dup 0))]
+"dead_or_set_in_peep(1, insn, operands[0])"
+  [(set (mem:SF (post_dec (reg:HI 1)))
+	(match_dup 1))]
+"")
+
+
+(define_peephole2
+ [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "") 
+       (const_int 0))
+  (set (match_dup 0) (ior:HI (match_dup 0) 
+			     (match_operand:HI 1 "const_int_operand" "")))]
+ ""
+ [(set (match_dup 0) (match_dup 1))]
+ "")
+ 
+
+(define_peephole2
+ [(set (match_operand:HI 0 "msp430_vwa_nonimmediate_operand" "") 
+       (const_int 0))
+  (set (match_dup 0) (xor:HI (match_dup 0) 
+			     (const_int -1)))]
+ ""
+ [(set (match_dup 0) (const_int -1))]
+ "")
+ 
+
+;; do not check for zeros here, cause this insn already issued.
+(define_peephole2
+   [(set (match_operand:SI 1 "register_operand" "")
+         (sign_extend:SI (match_operand:HI 0 "register_operand" "")))
+    (set (match_dup 1) (ashift:SI (match_dup 1) (const_int 16)))]
+""
+  [(set (subreg:HI (match_dup 1) 2) (match_dup 0))]
+"")
+
+(define_peephole2
+   [(set (match_operand:SI 1 "register_operand" "")
+         (zero_extend:SI (match_operand:HI 0 "register_operand" "")))
+    (set (match_dup 1) (ashift:SI (match_dup 1) (const_int 16)))]
+""
+  [(set (subreg:HI (match_dup 1) 2) (match_dup 0))]
+"")
+
+(define_peephole2
+   [(set (match_operand:SI 0 "register_operand" "")
+         (zero_extend:SI (match_operand:HI 1 "register_operand" "")))
+    (set (match_operand:SI 2 "register_operand" "")
+         (ior:SI (match_dup 2) (match_dup 0)))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (subreg:HI (match_dup 2) 0) 
+        (ior:HI (subreg:HI (match_dup 2) 0) (match_dup 1)))]
+"")
+
+(define_peephole2
+   [(set (match_operand:HI 0 "register_operand" "")  
+         (match_operand:HI 1 "msp430_vwa_general_operand" ""))
+    (set (match_operand:SI 2 "register_operand" "")
+         (zero_extend:SI (match_dup 0)))
+    (set (match_operand:SI 3 "register_operand" "") 
+         (ior:SI (match_dup 3) (match_dup 2)))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (subreg:HI (match_dup 3) 0) 
+        (ior:HI (subreg:HI (match_dup 3) 0) (match_dup 1)))]
+"")
+
+
+;; (ulong) x = (ulong) f >> 16;
+;;
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "register_operand" "")) 
+   (set (match_dup 0) 
+	(lshiftrt:SI (match_dup 0) 
+		     (const_int 16)))]
+""
+[(set (subreg:HI (match_dup 0) 0) (subreg:HI (match_dup 1) 2))
+ (set (subreg:HI (match_dup 0) 2) (const_int 0))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "register_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(ior:SI (match_dup 2) (match_dup 0)))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (ior:SI (match_dup 2) 
+		              (match_dup 1)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(zero_extend:SI (match_operand:HI 1 "general_operand" "")))
+   (set (match_dup 0) 
+	(ashift:SI (match_dup 0) (const_int 16)))]
+""
+  [(set (subreg:HI (match_dup 0) 2) (match_dup 1))]
+"")
+
+
+;; shift right & set
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "register_operand" ""))
+   (set (match_operand:HI 2 "register_operand" "")
+	(match_dup 0))
+   (set (match_dup 2) 
+	(and:HI (match_dup 2) 
+		(match_operand 3 "const_int_operand" "")))
+   (set (match_dup 2) 
+	(lshiftrt:HI (match_dup 2) 
+		     (match_operand 4 "const_int_operand" ""))) 
+   (set (match_dup 1) (match_dup 2))]
+"dead_or_set_in_peep(4,insn, operands[2])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 1)  
+	(and:HI (match_dup 1)  
+		(match_dup 3))) 
+   (set (match_dup 1) 
+	(lshiftrt:HI (match_dup 1) 
+		     (match_dup 4)))] 
+"")
+
+;; shift left and set
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "register_operand" ""))
+   (set (match_operand:HI 2 "register_operand" "")
+	(match_dup 0))
+   (set (match_dup 2) 
+	(and:HI (match_dup 2) 
+		(match_operand 3 "const_int_operand" "")))
+   (set (match_dup 2) 
+	(ashift:HI (match_dup 2) 
+		   (match_operand 4 "const_int_operand" ""))) 
+   (set (match_dup 1) (match_dup 2))]
+"dead_or_set_in_peep(4,insn, operands[2])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 1)  
+	(and:HI (match_dup 1)  
+		(match_dup 3))) 
+   (set (match_dup 1) 
+	(ashift:HI (match_dup 1) 
+		   (match_dup 4)))] 
+"")
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "msp430_vwa_general_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(zero_extend:SI (match_dup 0)))
+   (set (match_operand:SI 3 "register_operand" "") 
+	(plus:SI (match_dup 3) (match_dup 2)))]
+"dead_or_set_in_peep(2,insn, operands[2])"
+  [(set (subreg:HI (match_dup 3) 0) 
+	(plus:HI (subreg:HI (match_dup 3) 0) 
+		 (match_dup 1)))
+   (set (subreg:HI (match_dup 3) 2) 
+	(unspec:HI [(subreg:HI (match_dup 3) 2) (const_int 0)] UNSPEC_ADDC_REG))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "msp430_vwa_general_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(zero_extend:SI (match_dup 0)))
+   (set (match_operand:SI 3 "msp430_vwa_nonimmediate_operand" "") 
+	(plus:SI (match_dup 3) (match_dup 2)))]
+"dead_or_set_in_peep(2,insn, operands[2])"
+  [(set (subreg:HI (match_dup 3) 0) 
+	(plus:HI (subreg:HI (match_dup 3) 0) 
+		 (match_dup 1)))
+   (set (subreg:HI (match_dup 3) 2) 
+	(unspec:HI [(subreg:HI (match_dup 3) 2) (const_int 0)] UNSPEC_ADDC_ANY))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "msp430_vwa_general_operand" ""))
+   (set (match_operand:SI 2 "msp430_vwa_nonimmediate_operand" "")
+        (zero_extend:SI (match_dup 0)))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (subreg:HI (match_dup 2) 0) (match_dup 1))
+   (set (subreg:HI (match_dup 2) 2) (const_int 0))]
+"")
+
+;;
+;; these are for redudant moves.
+;;
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "msp430_vwa_nonimmediate_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(ior:SI (match_dup 2) (match_dup 0)))
+   (set (match_dup 1) (match_dup 2))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 1) (ior:SI (match_dup 1) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(ior:SI (match_dup 0) 
+		(match_operand:SI 1 "register_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 1) (ior:SI (match_dup 1) (match_dup 0)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "register_operand" ""))
+   (set (match_dup 0) 
+	(not:HI (match_dup 0)))
+   (set (match_operand:HI 2 "register_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && dead_or_set_in_peep(0,insn, operands[1])"
+  [(set (match_dup 1) (not:HI (match_dup 1)))
+   (set (match_dup 2) (match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "register_operand" ""))
+   (set (match_dup 0) 
+	(not:SI (match_dup 0)))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && dead_or_set_in_peep(0,insn, operands[1])"
+  [(set (match_dup 1) (not:SI (match_dup 1)))
+   (set (match_dup 2) (match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SF 0 "register_operand" "")
+	(match_operand:SF 1 "msp430_vwa_general_operand" ""))
+   (set (match_operand:SF 2 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (match_dup 1))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "msp430_vwa_general_operand" ""))
+   (set (match_operand:SI 2 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "msp430_vwa_general_operand" ""))
+   (set (match_operand:HI 2 "msp430_vwa_nonimmediate_operand" "")
+        (match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (match_dup 1))]
+"")
+
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) 
+       (if_then_else (match_operator:SI 3 "equality_operator"
+		      [(match_dup 0) (const_int 0)]) 
+       (label_ref (match_operand 4 "" ""))
+       (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 0"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_BITTEST_LO))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) (if_then_else (match_operator:SI 3 "equality_operator"
+			   [(match_dup 0) (const_int 0)])
+	    (label_ref (match_operand 4 "" ""))
+	    (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 1"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_BITTEST_HI))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) 
+       (if_then_else (match_operator:HI 3 "equality_operator"
+		      [(match_operand:HI 4 "register_operand" "") (const_int 0)]) 
+       (label_ref (match_operand 5 "" ""))
+       (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 1
+	&& REGNO(operands[4]) == REGNO(operands[0])+1"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_BITTEST_LO))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 5))
+	     (pc)))]
+"")
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) 
+       (if_then_else (match_operator:HI 3 "equality_operator"
+		      [(match_operand:HI 4 "register_operand" "") (const_int 0)]) 
+       (label_ref (match_operand 5 "" ""))
+       (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 0
+	&& REGNO(operands[4]) == REGNO(operands[0])"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_BITTEST_LO))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 5))
+	     (pc)))]
+"")
+
+(define_peephole2
+ [(set (match_operand:HI 0 "register_operand" "")
+       (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" ""))
+  (set (match_dup 0) (and:HI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) (if_then_else (match_operator:HI 3 "equality_operator"
+			   [(match_dup 0) (const_int 0)])
+	    (label_ref (match_operand 4 "" "")) 
+	    (pc)))]
+"dead_or_set_in_peep(2,insn, operands[0]) "
+  [(set (cc0) 
+	(unspec:HI [(match_dup 1) (match_dup 2)] UNSPEC_BITTEST))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+
+(define_peephole2
+ [(set (match_operand:QI 0 "register_operand" "")
+       (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" ""))
+  (set (match_dup 0) (and:QI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) (if_then_else (match_operator:QI 3 "equality_operator"
+			   [(match_dup 0) (const_int 0)])
+	    (label_ref (match_operand 4 "" "")) 
+	    (pc)))]
+"dead_or_set_in_peep(2,insn, operands[0]) "
+  [(set (cc0) 
+	(unspec:QI [(match_dup 1) (match_dup 2)] UNSPEC_BITTEST_B))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+        (match_operand:QI 1 "msp430_vwa_general_operand" ""))
+   (set (match_dup 0)
+	(minus:QI (match_dup 0) 
+		  (match_operand:QI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:QI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (minus:QI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+        (match_operand:QI 1 "msp430_vwa_general_operand" ""))
+   (set (match_dup 0)
+	(plus:QI (match_dup 0) 
+		 (match_operand:QI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:QI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (plus:QI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "msp430_vwa_general_operand" ""))
+   (set (match_dup 0)
+	(minus:HI (match_dup 0) 
+		  (match_operand:HI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (minus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "msp430_vwa_general_operand" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0) 
+		 (match_operand:HI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (plus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "msp430_vwa_general_operand" ""))
+   (set (match_dup 0)
+	(minus:SI (match_dup 0) 
+		  (match_operand:SI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (minus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "msp430_vwa_general_operand" ""))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0) 
+		 (match_operand:SI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (plus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+
+;; =============================================================
+;; 
+;;  adjust frame pointer index
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "msp430_vwa_general_operand" "")))
+   (set (match_dup 0) 
+	(plus:HI (match_dup 0) (match_operand:HI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:HI (match_dup 1)))
+   (set (match_dup 3) (plus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(sign_extend:SI (match_operand:HI 1 "msp430_vwa_general_operand" "")))
+   (set (match_dup 0) 
+	(plus:SI (match_dup 0) (match_operand:SI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:SI (match_dup 1)))
+   (set (match_dup 3) (plus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "msp430_vwa_general_operand" "")))
+   (set (match_dup 0) 
+	(minus:HI (match_dup 0) (match_operand:HI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:HI (match_dup 1)))
+   (set (match_dup 3) (minus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(sign_extend:SI (match_operand:HI 1 "msp430_vwa_general_operand" "")))
+   (set (match_dup 0) 
+	(minus:SI (match_dup 0) (match_operand:SI 2 "msp430_vwa_general_operand" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:SI (match_dup 1)))
+   (set (match_dup 3) (minus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+;; =============================================================
+;; mov & 'and'
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "msp430_vwa_nonimmediate_operand" ""))
+   (set (match_dup 0) 
+	(and:HI (match_dup 0) 
+		(match_operand:HI 2 "msp430_vwa_general_operand" ""))) 
+   (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 1) 
+	(and:HI (match_dup 1) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "msp430_vwa_nonimmediate_operand" ""))
+   (set (match_dup 0) 
+	(and:SI (match_dup 0) 
+		(match_operand:SI 2 "msp430_vwa_general_operand" ""))) 
+   (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 1) 
+	(and:SI (match_dup 1) (match_dup 2)))]
+"")
+
+
+
+;;
+;; after mult and stuff
+;;
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(reg:SI 14))
+   (set (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+  [(set (match_dup 1) (reg:SI 14))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(reg:HI 14))
+   (set (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+  [(set (match_dup 1) (reg:HI 14))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(reg:SI 12))
+   (set (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+  [(set (match_dup 1) (reg:SI 12))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(reg:HI 12))
+   (set (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+  [(set (match_dup 1) (reg:HI 12))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(sign_extend:SI (match_operand:QI 1 "msp430_vwa_general_operand" "")))
+   (set (match_operand:SI 2 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+  [(set (match_dup 2) (sign_extend:SI (match_dup 1)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(sign_extend:SI (match_operand:HI 1 "msp430_vwa_general_operand" "")))
+   (set (match_operand:SI 2 "msp430_vwa_nonimmediate_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+  [(set (match_dup 2) (sign_extend:SI (match_dup 1)))]
+"")
+
+
+;; =============================================================
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(ior:HI (match_dup 0) 
+		(match_operand:HI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(match_operand:SI 3 "register_operand" ""))]
+"(REGNO(operands[0]) == REGNO(operands[2])
+  && REGNO(operands[3])+1 == REGNO(operands[0]))"
+  [(set (match_dup 1) 
+	(ior:HI (match_dup 1) 
+		(match_dup 0)))
+   (set (subreg:HI (match_dup 2) 0)
+	(subreg:HI (match_dup 3) 0))]
+"")
+
+
+
+;; =============================================================
+;; combine ior and mov.
+;;
+(define_peephole2
+[(set (match_operand:QI 0 "register_operand" "") 
+      (ior:QI (match_dup 0) 
+      	      (match_operand:QI 1 "msp430_vwa_nonimmediate_operand" "")))
+ (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+[(set (match_dup 1) (ior:QI (match_dup 1) (match_dup 0)))]
+"")
+
+(define_peephole2
+[(set (match_operand:HI 0 "register_operand" "") 
+      (ior:HI (match_dup 0) 
+      	      (match_operand:HI 1 "msp430_vwa_nonimmediate_operand" "")))
+ (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+[(set (match_dup 1) (ior:HI (match_dup 1) (match_dup 0)))]
+"")
+
+(define_peephole2
+[(set (match_operand:SI 0 "register_operand" "") 
+      (ior:SI (match_dup 0) 
+      	      (match_operand:SI 1 "msp430_vwa_nonimmediate_operand" "")))
+ (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+[(set (match_dup 1) (ior:SI (match_dup 1) (match_dup 0)))]
+"")
+
+(define_peephole2
+[(set (match_operand:DI 0 "register_operand" "") 
+      (ior:DI (match_dup 0) 
+      	      (match_operand:DI 1 "msp430_vwa_nonimmediate_operand" "")))
+ (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])"
+[(set (match_dup 1) (ior:DI (match_dup 1) (match_dup 0)))]
+"")
+
diff --git gcc-4.5.3.orig/gcc/config/msp430/predicates.md gcc-4.5.3/gcc/config/msp430/predicates.md
new file mode 100644
index 0000000..2147e3b
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/predicates.md
@@ -0,0 +1,163 @@
+;; -*- Mode: Scheme -*-
+;; Predicate definitions for MSP430
+;; Copyright (C) 2006 Free Software Foundation, Inc.
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 2, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+;; Boston, MA 02110-1301, USA.
+
+;; This work is partially financed by the European Commission under the
+;; Framework 6 Information Society Technologies Project
+;; "Wirelessly Accessible Sensor Populations (WASP)".
+
+;; <==== Comment by Ivan Shcherbakov ====>
+;; All predicates here were checked againist latest port of GCC 3.2.3
+(define_special_predicate "equality_operator"
+  (match_code "eq,ne")
+{
+  return ((mode == VOIDmode || GET_MODE (op) == mode) && (GET_CODE (op) == EQ || GET_CODE (op) == NE));
+})
+
+(define_special_predicate "inequality_operator"
+  (match_code "ge,gt,le,lt,geu,gtu,leu,ltu")
+{
+  return comparison_operator (op, mode) && !equality_operator (op, mode);
+})
+
+
+;; The Volatile Work-Around
+;; ========================
+;;
+;; History and Rationale
+;; ---------------------
+;;
+;; This precious wonder exists because MSP430 peripheral registers are
+;; rightly declared as "volatile", meaning they can be changed without
+;; program action, and every read and write defined by the abstract
+;; machine must be executed.  In practice, gcc's ignorance of the
+;; existence of read-modify-write (RMW) operations means that
+;; invocation of memory_operand(op) on an op that involves a volatile
+;; reference are rejected, requiring that the value be explicitly read
+;; into a register and written from a register.  So, something like:
+;;
+;;   extern unsigned int volatile periph16;
+;;   periph16 &= 8;
+;;
+;; becomes:
+;;
+;;   mov &periph16, r15
+;;   and #8, r15
+;;   mov r15, &periph16
+;;
+;; By default, the msp430 back end turns on a volatile workaround,
+;; accessed by using the alternative msp430_vwa_*_operand predicates
+;; below, which allow the above to expand to:
+;;
+;;   and #8, &periph16
+;;
+;; This has been how it's been since time immemorial.  Although the
+;; documentation implies it was intended for use on binary operations,
+;; it's also required for moving values around, and has been applied
+;; to at least some arithmetic operations as well.  Until there's
+;; clear evidence that this subversion of operand checking can produce
+;; a violation of the semantics of volatile, we'll leave it.
+;;
+;; Use of msp430_vwa_*_operand Predicates
+;; --------------------------------------
+;;
+;; - Use it on pushm1 and movm instructions
+;; - Use it on all bitwise operations (and, ior, xor, shifts)
+;; - Use it on multiword insns (SI, SF, DI) for consistency (it will
+;;   be necessary for PSImode when 20-bit is added).
+;; - Use it on arithmetic operations (historical)
+;; - Use it on built-ins, which are generally unspec_volatile to
+;;   prevent them from being moved around
+;; - Do NOT use it on define_expands
+;;
+
+;; True if op is a nonimmediate_operand when the volatile work-around
+;; is taken into account.
+(define_predicate "msp430_vwa_nonimmediate_operand"
+  (match_code "reg,subreg,mem")
+{
+  int save_volatile_ok = volatile_ok;
+  int rv;
+
+  if (!TARGET_NVWA)
+    volatile_ok = 1;
+  rv = nonimmediate_operand (op, mode);
+  volatile_ok = save_volatile_ok;
+  return rv;
+})
+
+;; True if op is a memory_operand when the volatile work-around
+;; is taken into account.
+(define_predicate "msp430_vwa_memory_operand"
+  (match_code "subreg,mem")
+{
+  int save_volatile_ok = volatile_ok;
+  int rv;
+
+  if (!TARGET_NVWA)
+    volatile_ok = 1;
+  rv = memory_operand (op, mode);
+  volatile_ok = save_volatile_ok;
+  return rv;
+})
+
+;; True if op is a general_operand when the volatile work-around
+;; is taken into account.
+(define_predicate "msp430_vwa_general_operand"
+  (match_code "const_int,const_double,const,symbol_ref,label_ref,subreg,reg,mem")
+{
+  int save_volatile_ok = volatile_ok;
+  int rv;
+
+  if (!TARGET_NVWA)
+    volatile_ok = 1;
+  rv = general_operand (op, mode);
+  volatile_ok = save_volatile_ok;
+  return rv;
+})
+
+(define_predicate "three_operands_msp430"
+  (match_code "plus,minus,and,ior,xor")
+{
+  enum rtx_code code = GET_CODE (op);
+  if (GET_MODE (op) != mode)
+    return 0;
+
+  return (code == PLUS || code == MINUS || code == AND || code == IOR || code == XOR);
+})
+
+;; True for any non-virtual or eliminable register.  Used in places where
+;; instantiation of such a register may cause the pattern to not be recognized.
+(define_predicate "register_no_elim_operand"
+  (match_operand 0 "register_operand")
+{
+  if (GET_CODE (op) == SUBREG)
+    op = SUBREG_REG (op);
+  return !(op == arg_pointer_rtx
+	   || op == frame_pointer_rtx
+	   || IN_RANGE (REGNO (op),
+			FIRST_PSEUDO_REGISTER, LAST_VIRTUAL_REGISTER));
+})
+
+;; Return false if this is any eliminable register.  Otherwise general_operand.
+(define_predicate "general_no_elim_operand"
+  (if_then_else (match_code "reg,subreg")
+    (match_operand 0 "register_no_elim_operand")
+    (match_operand 0 "general_operand")))
diff --git gcc-4.5.3.orig/gcc/config/msp430/t-msp430 gcc-4.5.3/gcc/config/msp430/t-msp430
new file mode 100644
index 0000000..a212504
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/t-msp430
@@ -0,0 +1,156 @@
+# Specific names for MSP430 tools
+AR_FOR_TARGET = msp430-ar
+RANLIB_FOR_TARGET = msp430-ranlib
+NM_FOR_TARGET = msp430-nm
+
+CROSS_LIBGCC1 = libgcc1-asm.a
+LIB1ASMSRC = msp430/libgcc.S
+LIB1ASMFUNCS = \
+	_cmpsi2 \
+	_ucmpsi2 \
+	_cmpdi2 \
+	_ucmpdi2 \
+	_cmpsf2 \
+	_mulqi3 \
+	_mulhi3 \
+	_mulsi3 \
+	_muldi3 \
+	_mulsi3hw \
+	_umulqihi3 \
+	_umulhisi3 \
+	_umulsidi3 \
+	_mulqihi3 \
+	_mulhisi3 \
+	_mulsidi3 \
+	_udivmodqi4 \
+	_divmodqi4 \
+	_udivmodhi4 \
+	_divmodhi4 \
+	_udivmodsi4 \
+	_divmodsi4 \
+	__prologue_saver \
+	__epilogue_restorer \
+	__epilogue_restorer_intr \
+	_udivmoddi3_parts \
+	_udivdi3 \
+	_umoddi3 \
+	_divdi3 \
+	_moddi3
+	
+# libgcc...
+LIBGCC1_TEST =
+
+CRT0ASMFUNCS = \
+	_reset_vector__ \
+	__init_stack \
+	__low_level_init \
+	_copy_data \
+	_clear_bss \
+	__stop_progExec__ \
+	_endless_loop__ \
+	_unexpected_ \
+	_ctors430 \
+	_dtors430
+
+CRT0ASMSRC = msp430/crt0.S
+
+crt0asmfuncs-o = $(patsubst %,$(T)%$(objext),$(CRT0ASMFUNCS))
+
+$(crt0asmfuncs-o): %$(objext): $(srcdir)/config/$(CRT0ASMSRC)
+	 $(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -DL$(*F) -xassembler-with-cpp \
+	  -o $*.o -c $(srcdir)/config/$(CRT0ASMSRC)
+
+$(T)libcrt0.a: $(crt0asmfuncs-o)
+	-rm -f $@
+	$(AR) $(ARFLAGS) $@ $^
+	$(RANLIB) $@
+
+EXTRA_MULTILIB_PARTS += $(T)libcrt0.a
+
+crt0asmfuncs-dwdt-o = $(patsubst %,$(T)%-dwdt$(objext),$(CRT0ASMFUNCS))
+
+$(crt0asmfuncs-dwdt-o): %-dwdt$(objext): $(srcdir)/config/$(CRT0ASMSRC)
+	 $(GCC_FOR_TARGET) -DWITH_DISABLE_WDT $(MULTILIB_CFLAGS) -DL$(*F) -xassembler-with-cpp \
+	  -o $*-dwdt.o -c $(srcdir)/config/$(CRT0ASMSRC)
+
+$(T)libcrt0dwdt.a: $(crt0asmfuncs-dwdt-o)
+	-rm -f $@
+	$(AR) $(ARFLAGS) $@ $^
+	$(RANLIB) $@
+
+EXTRA_MULTILIB_PARTS += $(T)libcrt0dwdt.a
+
+# Interrupt vector tables.  Not part of crt0 because this is completely
+# orthogonal to multilib, and we need three alternatives.
+EXTRA_PARTS += crt0ivtbl16$(objext) crt0ivtbl32$(objext) crt0ivtbl64$(objext)
+
+$(T)crt0ivtbl16.o: $(srcdir)/config/msp430/crt0ivtbl.S $(GCC_PASSES)
+	$(GCC_FOR_TARGET) -c -DINTERRUPT_VECTOR_COUNT=16 \
+		$(srcdir)/config/msp430/crt0ivtbl.S \
+		-o $(T)crt0ivtbl16$(objext)
+
+$(T)crt0ivtbl32.o: $(srcdir)/config/msp430/crt0ivtbl.S $(GCC_PASSES)
+	$(GCC_FOR_TARGET) -c -DINTERRUPT_VECTOR_COUNT=32 \
+		$(srcdir)/config/msp430/crt0ivtbl.S \
+		-o $(T)crt0ivtbl32$(objext)
+
+$(T)crt0ivtbl64.o: $(srcdir)/config/msp430/crt0ivtbl.S $(GCC_PASSES)
+	$(GCC_FOR_TARGET) -c -DINTERRUPT_VECTOR_COUNT=64 \
+		$(srcdir)/config/msp430/crt0ivtbl.S \
+		-o $(T)crt0ivtbl64$(objext)
+
+# We do not have the DF type.
+# Most of the C functions in libgcc2 use almost all registers,
+TARGET_LIBGCC2_CFLAGS = -DDF=SF -Dinhibit_libc -g
+
+fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/msp430/t-msp430
+	echo '#define FLOAT' > fp-bit.c
+	echo '#define FLOAT_ONLY' >> fp-bit.c
+	echo '#define CMPtype HItype' >> fp-bit.c
+	echo '#define DF SF' >> fp-bit.c
+	echo '#define DI SI' >> fp-bit.c
+	echo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c
+	echo '#define SMALL_MACHINE' >> fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+FPBIT = fp-bit.c
+
+# We do not create a multilib for 430xv2, since it is identical to 430x
+# except in terms of instruction timings.  It maps to 430x.
+TM_MSP430_CPU=430/430x
+
+# Although 16se, 32, and 32dw are valid options, currently the msp430
+# back end generates code only for the 16 variant, which works on the other
+# variants.  The other options map to 16.
+TM_MSP430_MPY=none/16
+
+MULTILIB_OPTIONS = \
+    mcpu=$(subst /,/mcpu=,$(TM_MSP430_CPU)) \
+    mmpy=$(subst /,/mmpy=,$(TM_MSP430_MPY))
+MULTILIB_MATCHES = \
+    mcpu?430x=mcpu?430xv2 \
+    mmpy?16=mmpy?16se \
+    mmpy?16=mmpy?32 \
+    mmpy?16=mmpy?32dw
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
+
+msp430-cbranch.o: $(srcdir)/config/msp430/msp430-cbranch.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TM_H) $(TREE_H) output.h $(C_COMMON_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/msp430/msp430-cbranch.c
+
+msp430-builtins.o: $(srcdir)/config/msp430/msp430-builtins.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TM_H) $(TREE_H) output.h $(C_COMMON_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/msp430/msp430-builtins.c
+
+msp430-function.o: $(srcdir)/config/msp430/msp430-function.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TM_H) $(TREE_H) output.h $(C_COMMON_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/msp430/msp430-function.c
+
+EXTRA_GCC_OBJS += msp430-gcc.o
+
+msp430-gcc.o: $(srcdir)/config/msp430/msp430-gcc.c $(CONFIG_H) $(TM_H) $(C_COMMON_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+  $(DRIVER_DEFINES) \
+  -DPREFIX=\"$(prefix)\" \
+  $(srcdir)/config/msp430/msp430-gcc.c
diff --git gcc-4.5.3.orig/gcc/config/msp430/xm-msp430.h gcc-4.5.3/gcc/config/msp430/xm-msp430.h
new file mode 100644
index 0000000..af51cd3
--- /dev/null
+++ gcc-4.5.3/gcc/config/msp430/xm-msp430.h
@@ -0,0 +1 @@
+#include "tm.h"
diff --git gcc-4.5.3.orig/gcc/configure.ac gcc-4.5.3/gcc/configure.ac
index 45d2959..ecbc78e 100644
--- gcc-4.5.3.orig/gcc/configure.ac
+++ gcc-4.5.3/gcc/configure.ac
@@ -3689,6 +3689,7 @@ case "$target" in
   i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* \
   | x86_64*-*-* | hppa*-*-* | arm*-*-* \
   | xstormy16*-*-* | cris-*-* | crisv32-*-* | xtensa*-*-* | bfin-*-* | score*-*-* \
+  | msp430-*-* \
   | spu-*-* | fido*-*-* | m32c-*-*)
     insn="nop"
     ;;
diff --git gcc-4.5.3.orig/gcc/emit-rtl.c gcc-4.5.3/gcc/emit-rtl.c
index ad21efd..859e2c5 100644
--- gcc-4.5.3.orig/gcc/emit-rtl.c
+++ gcc-4.5.3/gcc/emit-rtl.c
@@ -1640,7 +1640,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,
       base = get_base_address (base);
       if (base && DECL_P (base)
 	  && TREE_READONLY (base)
-	  && (TREE_STATIC (base) || DECL_EXTERNAL (base)))
+	  && (TREE_STATIC (base) || DECL_EXTERNAL (base))
+          && !TREE_THIS_VOLATILE (base))
 	{
 	  tree base_type = TREE_TYPE (base);
 	  gcc_assert (!(base_type && TYPE_NEEDS_CONSTRUCTING (base_type))
diff --git gcc-4.5.3.orig/gcc/expr.c gcc-4.5.3/gcc/expr.c
index 59b8690..4c29557 100644
--- gcc-4.5.3.orig/gcc/expr.c
+++ gcc-4.5.3/gcc/expr.c
@@ -942,7 +942,7 @@ move_by_pieces (rtx to, rtx from, unsigned HOST_WIDE_INT len,
 	  data.autinc_from = 1;
 	  data.explicit_inc_from = -1;
 	}
-      if (USE_LOAD_POST_INCREMENT (mode) && ! data.autinc_from)
+      if (USE_LOAD_POST_INCREMENT (mode) && ! data.reverse && ! data.autinc_from)
 	{
 	  data.from_addr = copy_to_mode_reg (from_addr_mode, from_addr);
 	  data.autinc_from = 1;
diff --git gcc-4.5.3.orig/gcc/gcc.c gcc-4.5.3/gcc/gcc.c
index e7ee382..e38d8d7 100644
--- gcc-4.5.3.orig/gcc/gcc.c
+++ gcc-4.5.3/gcc/gcc.c
@@ -403,6 +403,7 @@ static const char *if_exists_else_spec_function (int, const char **);
 static const char *replace_outfile_spec_function (int, const char **);
 static const char *version_compare_spec_function (int, const char **);
 static const char *include_spec_function (int, const char **);
+static const char *include_noerr_spec_function (int, const char **);
 static const char *print_asm_header_spec_function (int, const char **);
 static const char *compare_debug_dump_opt_spec_function (int, const char **);
 static const char *compare_debug_self_opt_spec_function (int, const char **);
@@ -1726,6 +1727,7 @@ static const struct spec_function static_spec_functions[] =
   { "replace-outfile",		replace_outfile_spec_function },
   { "version-compare",		version_compare_spec_function },
   { "include",			include_spec_function },
+  { "include_noerr",		include_noerr_spec_function },
   { "print-asm-header",		print_asm_header_spec_function },
   { "compare-debug-dump-opt",	compare_debug_dump_opt_spec_function },
   { "compare-debug-self-opt",	compare_debug_self_opt_spec_function },
@@ -8794,6 +8796,29 @@ include_spec_function (int argc, const char **argv)
   return NULL;
 }
 
+/* %:include_noerr builtin spec function.  This differs from
+   %include_noerr in that it can be nested inside a spec, and thus be
+   %conditionalized or referenced in DRIVER_SELF_SPECS.  It takes one
+   %argument, the filename, and looks for it in the startfile path.
+   %The result is always NULL, i.e. an empty expansion.  */
+
+static const char *
+include_noerr_spec_function (int argc, const char **argv)
+{
+  char *file;
+
+  if (argc != 1)
+    abort ();
+
+  file = find_a_file (&startfile_prefixes, argv[0], R_OK, true);
+  if (file)
+    read_specs (file, FALSE);
+  else if (verbose_flag)
+    notice ("could not find specs file %s\n", argv[0]);
+
+  return NULL;
+}
+
 /* %:print-asm-header spec function.  Print a banner to say that the
    following output is from the assembler.  */
 
diff --git gcc-4.5.3.orig/gcc/loop-invariant.c gcc-4.5.3/gcc/loop-invariant.c
index e6c429e..f3f989f 100644
--- gcc-4.5.3.orig/gcc/loop-invariant.c
+++ gcc-4.5.3/gcc/loop-invariant.c
@@ -1367,6 +1367,32 @@ find_invariants_to_move (bool speed)
     }
 }
 
+/* Replace the uses, reached by the definition of invariant INV, by REG.
+
+   IN_GROUP is nonzero if this is part of a group of changes that must be
+   performed as a group.  In that case, the changes will be stored.  The
+   function `apply_change_group' will validate and apply the changes.  */
+
+static int
+replace_uses (struct invariant *inv, rtx reg, bool in_group)
+{
+  /* Replace the uses we know to be dominated.  It saves work for copy
+     propagation, and also it is necessary so that dependent invariants
+     are computed right.  */
+  if (inv->def)
+    {
+      struct use *use;
+      for (use = inv->def->uses; use; use = use->next)
+	validate_change (use->insn, use->pos, reg, true);
+
+      /* If we aren't part of a larger group, apply the changes now.  */
+      if (!in_group)
+	return apply_change_group ();
+    }
+
+  return 1;
+}
+
 /* Move invariant INVNO out of the LOOP.  Returns true if this succeeds, false
    otherwise.  */
 
@@ -1378,7 +1404,6 @@ move_invariant_reg (struct loop *loop, unsigned invno)
   unsigned i;
   basic_block preheader = loop_preheader_edge (loop)->src;
   rtx reg, set, dest, note;
-  struct use *use;
   bitmap_iterator bi;
   int regno;
 
@@ -1402,10 +1427,10 @@ move_invariant_reg (struct loop *loop, unsigned invno)
 	}
 
       /* Move the set out of the loop.  If the set is always executed (we could
-	 omit this condition if we know that the register is unused outside of the
-	 loop, but it does not seem worth finding out) and it has no uses that
-	 would not be dominated by it, we may just move it (TODO).  Otherwise we
-	 need to create a temporary register.  */
+	 omit this condition if we know that the register is unused outside of
+	 the loop, but it does not seem worth finding out) and it has no uses
+	 that would not be dominated by it, we may just move it (TODO).
+	 Otherwise we need to create a temporary register.  */
       set = single_set (inv->insn);
       reg = dest = SET_DEST (set);
       if (GET_CODE (reg) == SUBREG)
@@ -1416,9 +1441,14 @@ move_invariant_reg (struct loop *loop, unsigned invno)
       reg = gen_reg_rtx_and_attrs (dest);
 
       /* Try replacing the destination by a new pseudoregister.  */
-      if (!validate_change (inv->insn, &SET_DEST (set), reg, false))
+      validate_change (inv->insn, &SET_DEST (set), reg, true);
+
+      /* As well as all the dominated uses.  */
+      replace_uses (inv, reg, true);
+
+      /* And validate all the changes.  */
+      if (!apply_change_group ())
 	goto fail;
-      df_insn_rescan (inv->insn);
 
       emit_insn_after (gen_move_insn (dest, reg), inv->insn);
       reorder_insns (inv->insn, inv->insn, BB_END (preheader));
@@ -1446,22 +1476,9 @@ move_invariant_reg (struct loop *loop, unsigned invno)
       delete_insn (inv->insn);
     }
 
-
   inv->reg = reg;
   inv->orig_regno = regno;
 
-  /* Replace the uses we know to be dominated.  It saves work for copy
-     propagation, and also it is necessary so that dependent invariants
-     are computed right.  */
-  if (inv->def)
-    {
-      for (use = inv->def->uses; use; use = use->next)
-	{
-	  *use->pos = reg;
-	  df_insn_rescan (use->insn);
-	}
-    }
-
   return true;
 
 fail:
diff --git gcc-4.5.3.orig/gcc/lto/Make-lang.in gcc-4.5.3/gcc/lto/Make-lang.in
index ccdf2e3..05143b0 100644
--- gcc-4.5.3.orig/gcc/lto/Make-lang.in
+++ gcc-4.5.3/gcc/lto/Make-lang.in
@@ -94,3 +94,6 @@ lto/lto-coff.o: lto/lto-coff.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \
 lto/lto-macho.o: lto/lto-macho.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \
 	toplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H) \
 	lto/lto-macho.h lto/lto-endian.h
+
+# LTO testing is done as part of C/C++/Fortran etc. testing.
+check-lto:
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/bic_sr_irq.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/bic_sr_irq.c
new file mode 100644
index 0000000..282fe08
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/bic_sr_irq.c
@@ -0,0 +1,48 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern void * alloca (unsigned int);
+extern unsigned int use_data (void *arg);
+extern unsigned int sr_value;
+
+__attribute__ ((interrupt(1*2)))
+void clear_sr ()
+{
+  unsigned char data[14];
+  unsigned int sr_local;
+  
+  /* The following are 4-byte instructions */
+  /* { dg-final { scan-assembler "bic\[ \t\]#8, 22\\(r1\\)" } } */
+  __bic_status_register_on_exit(8);
+  sr_local = use_data (data);
+  /* { dg-final { scan-assembler "bic\[ \t\]r15, 22\\(r1\\)" } } */
+  __bic_status_register_on_exit(sr_local);
+  /* { dg-final { scan-assembler "bic\[ \t\]@r1, 22\\(r1\\)" } } */
+  __bic_status_register_on_exit(*(unsigned int*)data);
+
+  /* The following are 6-byte instructions */
+  /* { dg-final { scan-assembler "bic\[ \t\]#9, 22\\(r1\\)" } } */
+  __bic_status_register_on_exit(9);
+  /* { dg-final { scan-assembler "bic\[ \t\]&sr_value, 22\\(r1\\)" } } */
+  __bic_status_register_on_exit(sr_value);
+  /* { dg-final { scan-assembler "bic\[ \t\]4\\(r1\\), 22\\(r1\\)" } } */
+  __bic_status_register_on_exit(*(2 + (unsigned int*)data));
+
+}
+
+__attribute__ ((interrupt(2*2)))
+void alloca_sr (int len)
+{
+  char* locbuf;
+
+  /* { dg-final { scan-assembler "bic\[ \t\]#1, @r4" } } */
+  __bic_status_register_on_exit(1);
+  locbuf = alloca(len);
+  locbuf[0] = 'A';
+  locbuf[1] = 0;
+  use_data(locbuf);
+  /* SF 3198920: This one gets stored in the wrong location, because
+   * r1 still has the locbuf allocation reflected in it. */
+  /* { dg-final { scan-assembler "bic\[ \t\]#2, @r4" } } */
+  __bic_status_register_on_exit(2);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/bis_sr_irq.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/bis_sr_irq.c
new file mode 100644
index 0000000..56f9444
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/bis_sr_irq.c
@@ -0,0 +1,46 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern void * alloca (unsigned int);
+extern unsigned int use_data (unsigned char *arg);
+extern unsigned int sr_value;
+
+__attribute__ ((interrupt(1*2)))
+void set_sr ()
+{
+  unsigned char data[14];
+  unsigned int sr_local;
+  
+  /* The following are 4-byte instructions */
+  /* { dg-final { scan-assembler "bis\[ \t\]#8, 22\\(r1\\)" } } */
+  __bis_status_register_on_exit(8);
+  sr_local = use_data (data);
+  /* { dg-final { scan-assembler "bis\[ \t\]r15, 22\\(r1\\)" } } */
+  __bis_status_register_on_exit(sr_local);
+  /* { dg-final { scan-assembler "bis\[ \t\]@r1, 22\\(r1\\)" } } */
+  __bis_status_register_on_exit(*(unsigned int*)data);
+
+  /* The following are 6-byte instructions */
+  /* { dg-final { scan-assembler "bis\[ \t\]#9, 22\\(r1\\)" } } */
+  __bis_status_register_on_exit(9);
+  /* { dg-final { scan-assembler "bis\[ \t\]&sr_value, 22\\(r1\\)" } } */
+  __bis_status_register_on_exit(sr_value);
+  /* { dg-final { scan-assembler "bis\[ \t\]4\\(r1\\), 22\\(r1\\)" } } */
+  __bis_status_register_on_exit(*(2 + (unsigned int*)data));
+
+}
+
+__attribute__ ((interrupt(2*2)))
+void alloca_sr (int len)
+{
+  char* locbuf;
+
+  /* { dg-final { scan-assembler "bis\[ \t\]#1, @r4" } } */
+  __bis_status_register_on_exit(1);
+  locbuf = alloca(len);
+  locbuf[0] = 'A';
+  locbuf[1] = 0;
+  use_data(locbuf);
+  /* { dg-final { scan-assembler "bis\[ \t\]#2, @r4" } } */
+  __bis_status_register_on_exit(2);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/bswap.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/bswap.c
new file mode 100644
index 0000000..0db1432
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/bswap.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+unsigned int
+bswaphi2 (unsigned int v)
+{
+  /* { dg-final { scan-assembler "\n\tmov.b\tr15, r15\n\tswpb\tr15\n\tret\n" } } */
+  return v << 8;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtin_address.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtin_address.c
new file mode 100644
index 0000000..9f92c77
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtin_address.c
@@ -0,0 +1,82 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#if LIVE_P1_ISR
+#include <msp430.h>
+#define ISR_VECTOR PORT1_VECTOR
+#else /* LIVE_P1_ISR */
+#define ISR_VECTOR 1*2
+extern volatile unsigned char P1IV;
+#endif /* ISR_VECTOR */
+
+extern void * alloca (unsigned int len);
+
+extern void reference (void* p);
+
+void fn ()
+{
+  extern volatile void* ra_fn;
+  extern volatile void* fa_fn;
+  /* { dg-final { scan-assembler "mov\t@r4, &ra_fn *\n" } } */
+  ra_fn = __builtin_return_address(0);
+  /* { dg-final { scan-assembler "mov\tr4, &fa_fn *\n" } } */
+  fa_fn = __builtin_frame_address(0);
+}
+
+void fnl ()
+{
+  extern volatile void* ra_fnl;
+  extern volatile void* fa_fnl;
+  char data[4];
+  reference(data);
+  /* { dg-final { scan-assembler "mov\t@r4, &ra_fnl *\n" } } */
+  ra_fnl = __builtin_return_address(0);
+  /* { dg-final { scan-assembler "mov\tr4, &fa_fnl *\n" } } */
+  fa_fnl = __builtin_frame_address(0);
+}
+
+void fnd (int len)
+{
+  extern volatile void* ra_fnd;
+  extern volatile void* fa_fnd;
+  
+  char * data = alloca(len);
+  reference(data);
+  /* { dg-final { scan-assembler "mov\t@r4, &ra_fnd *\n" } } */
+  ra_fnd = __builtin_return_address(0);
+  /* { dg-final { scan-assembler "mov\tr4, &fa_fnd *\n" } } */
+  fa_fnd = __builtin_frame_address(0);
+}
+
+void fnma (int zero, int one, int two, int three, int four, int five)
+{
+  extern volatile void* ra_fnma;
+  extern volatile void* fa_fnma;
+  
+  int data[6];
+  data[0] = zero;
+  data[1] = one;
+  data[2] = two;
+  data[3] = three;
+  data[4] = four;
+  data[5] = five;
+  reference(data);
+  /* { dg-final { scan-assembler "mov\t@r4, &ra_fnma *\n" } } */
+  ra_fnma = __builtin_return_address(0);
+  /* { dg-final { scan-assembler "mov\tr4, &fa_fnma *\n" } } */
+  fa_fnma = __builtin_frame_address(0);
+}
+
+__attribute__((interrupt(ISR_VECTOR)))
+void isr ()
+{
+  extern volatile void* ra_isr;
+  extern volatile void* fa_isr;
+
+  /* Read the vector to clear the interrupt. */
+  (void)P1IV;
+  /* { dg-final { scan-assembler "mov\t2\\(r4\\), &ra_isr *\n" } } */
+  ra_isr = __builtin_return_address(0);
+  /* { dg-final { scan-assembler "mov\tr4, &fa_fnma *\n" } } */
+  fa_isr = __builtin_frame_address(0);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtins_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_1.c
new file mode 100644
index 0000000..757bdbf
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+void test ()
+{
+  /* { dg-final { scan-assembler "dint\n\tnop\n\teint\n\tnop\n\tret" } } */
+  __dint();
+  __eint();
+  __nop();
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtins_bic_sr.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_bic_sr.c
new file mode 100644
index 0000000..ee1e6ab
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_bic_sr.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile unsigned int read_sr;
+extern unsigned int write_sr;
+extern unsigned int *sr_ptr;
+
+void test ()
+{
+  int i;
+  unsigned int sr;
+
+  /* { dg-final { scan-assembler "bic\t&write_sr, r2\n" } } */
+  __bic_status_register(write_sr);
+  /* { dg-final { scan-assembler "bic\t#4660, r2\n" } } */
+  __bic_status_register(0x1234);
+  /* { dg-final { scan-assembler "bic\t#8, r2\n" } } */
+  __bic_status_register(8);
+  /* { dg-final { scan-assembler "bic\tr15, r2\n" } } */
+  __bic_status_register(read_sr & 0x42);
+  /* { dg-final { scan-assembler "bic\t@r15, r2\n" } } */
+  __bic_status_register(*sr_ptr);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtins_bis_sr.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_bis_sr.c
new file mode 100644
index 0000000..2f8d023
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_bis_sr.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile unsigned int read_sr;
+extern unsigned int write_sr;
+extern unsigned int *sr_ptr;
+
+void test ()
+{
+  int i;
+  unsigned int sr;
+
+  /* { dg-final { scan-assembler "bis\t&write_sr, r2\n" } } */
+  __bis_status_register(write_sr);
+  /* { dg-final { scan-assembler "bis\t#4660, r2\n" } } */
+  __bis_status_register(0x1234);
+  /* { dg-final { scan-assembler "bis\t#8, r2\n" } } */
+  __bis_status_register(8);
+  /* { dg-final { scan-assembler "bis\tr15, r2\n" } } */
+  __bis_status_register(read_sr & 0x42);
+  /* { dg-final { scan-assembler "bis\t@r15, r2\n" } } */
+  __bis_status_register(*sr_ptr);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtins_read_sr.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_read_sr.c
new file mode 100644
index 0000000..6420567
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_read_sr.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile unsigned int read_sr;
+extern unsigned int *sr_ptr;
+
+void test ()
+{
+  int i;
+  unsigned int sr;
+
+  /* { dg-final { scan-assembler "mov\tr2, r15\n" } } */
+  sr = __read_status_register();
+  /* { dg-final { scan-assembler "mov\tr2, \&read_sr\n" } } */
+  read_sr = __read_status_register();
+  /* { dg-final { scan-assembler "mov\tr2, @r15\n" } } */
+  *sr_ptr = __read_status_register();
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtins_sp.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_sp.c
new file mode 100644
index 0000000..b0a1cd8
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_sp.c
@@ -0,0 +1,29 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern void * volatile read_sp;
+extern void * volatile write_sp;
+extern void * volatile * sp_ptr;
+
+void test ()
+{
+  int i;
+  void * sp;
+
+  /* { dg-final { scan-assembler "mov\tr1, r15\n" } } */
+  sp = __read_stack_pointer();
+  /* { dg-final { scan-assembler "mov\tr1, \&read_sp\n" } } */
+  read_sp = __read_stack_pointer();
+  /* { dg-final { scan-assembler "mov\tr1, @r15\n" } } */
+  *sp_ptr = __read_stack_pointer();
+  /* { dg-final { scan-assembler "mov\t&write_sp, r1\n" } } */
+  __write_stack_pointer(write_sp);
+  /* { dg-final { scan-assembler "mov\t#4660, r1\n" } } */
+  __write_stack_pointer((void *)0x1234);
+  /* { dg-final { scan-assembler "mov\t#8, r1\n" } } */
+  __write_stack_pointer((void *)8);
+  /* { dg-final { scan-assembler "mov\tr15, r1\n" } } */
+  __write_stack_pointer((void *)(0x42 & (unsigned int)read_sp));
+  /* { dg-final { scan-assembler "mov\t@r15, r1\n" } } */
+  __write_stack_pointer(*sp_ptr);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/builtins_write_sr.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_write_sr.c
new file mode 100644
index 0000000..c891527
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/builtins_write_sr.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile unsigned int read_sr;
+extern unsigned int write_sr;
+extern unsigned int *sr_ptr;
+
+void test ()
+{
+  int i;
+  unsigned int sr;
+
+  /* { dg-final { scan-assembler "mov\t&write_sr, r2\n" } } */
+  __write_status_register(write_sr);
+  /* { dg-final { scan-assembler "mov\t#4660, r2\n" } } */
+  __write_status_register(0x1234);
+  /* { dg-final { scan-assembler "mov\t#8, r2\n" } } */
+  __write_status_register(8);
+  /* { dg-final { scan-assembler "mov\tr15, r2\n" } } */
+  __write_status_register(read_sr & 0x42);
+  /* { dg-final { scan-assembler "mov\t@r15, r2\n" } } */
+  __write_status_register(*sr_ptr);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/critical_attribute.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/critical_attribute.c
new file mode 100644
index 0000000..b60ea3b
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/critical_attribute.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+__attribute__((critical))
+int
+critical (int a)
+{
+  /* { dg-final { scan-assembler "critical:\n\tpush\tr2\n\tdint\n\tnop\n\tadd\t#1, r15\n\tpop\tr2\n\tret\n" } } */
+  return a+1;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/elimination.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/elimination.c
new file mode 100644
index 0000000..22b4334
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/elimination.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+static unsigned char is_initialized = 0;
+
+int putchar (int c)
+{
+  /* { dg-final { scan-assembler "\tmov\tr15, -4\\(r4\\)\n" } } */
+  if (! is_initialized) {
+    unsigned int delay;
+
+    is_initialized = 1;
+    delay = 0;
+    while (++delay);
+  }
+
+  return c;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/framesaver_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/framesaver_1.c
new file mode 100644
index 0000000..c1a29ad
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/framesaver_1.c
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile int v1;
+extern volatile int v2;
+extern volatile int v3;
+extern void doit();
+
+__attribute__ ((saveprologue))
+int func (int a, int b, int c) /* { dg-warning "saveprologue no longer supported" } */
+{
+  /* NOT dg-final { scan-assembler "\tadd\t\#llo\\(-18\\), r1\n\tmov\tr0, r12\n\tbr\t#__prologue_saver" } } */
+  int l1 = v1+v2;
+  int l2 = v2+v3;
+  int l3 = v1+v3;
+  doit();
+  return a+b+c+l1+l2+l3;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/framesaver_2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/framesaver_2.c
new file mode 100644
index 0000000..73978ef
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/framesaver_2.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile int v1;
+extern volatile int v2;
+extern volatile int v3;
+extern void doit(char * data);
+
+__attribute__ ((saveprologue))
+int func (int a, int b, int c) /* { dg-warning "saveprologue no longer supported" } */
+{
+  /* NOT dg-final { scan-assembler "\tadd\t\#llo\\(-20\\), r1\n\tmov\tr0, r12\n\tbr\t#__prologue_saver" } } */
+  int l1 = v1+v2;
+  int l2 = v2+v3;
+  int l3 = v1+v3;
+  char* data = __builtin_alloca (l3);
+  doit(data);
+  return a+b+c+l1+l2+l3;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/gen_return_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/gen_return_1.c
new file mode 100644
index 0000000..8dac65e
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/gen_return_1.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+extern int test ();
+extern void doit ();
+
+int func ()
+{
+  if (test ())
+    /* { dg-final { scan-assembler "mov\t#2, r15\n\tret\n" } } */
+    return 2;
+  doit();
+  /* { dg-final { scan-assembler "mov\t#1, r15\n\tret\n" } } */
+  return 1;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/gen_return_2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/gen_return_2.c
new file mode 100644
index 0000000..12d81a8
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/gen_return_2.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+extern int test ();
+extern void doit ();
+
+__attribute__ ((naked))
+int func ()
+{
+  /* { dg-final { scan-assembler-not "\tret\n" } } */
+  if (test ())
+    return 2;
+  doit();
+  return 1;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/msp430.exp gcc-4.5.3/gcc/testsuite/gcc.target/msp430/msp430.exp
new file mode 100644
index 0000000..735bb9b
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/msp430.exp
@@ -0,0 +1,41 @@
+# Copyright (C) 2011 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't an MSP430 target.
+if ![istarget msp430-*-*] then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# If a testcase doesn't have special options, use these.
+global DEFAULT_CFLAGS
+if ![info exists DEFAULT_CFLAGS] then {
+    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
+}
+
+# Initialize `dg'.
+dg-init
+
+# Main loop.
+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cCS\]]] \
+	"" $DEFAULT_CFLAGS
+
+# All done.
+dg-finish
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/section_attribute.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/section_attribute.c
new file mode 100644
index 0000000..1ff5391
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/section_attribute.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+__attribute__ ((naked,section(".init2")))
+void __init_stack ()
+{
+  /* { dg-final { scan-assembler ".section\t.init2,\"ax\",@progbits" } } */
+  /* { dg-final { scan-assembler "mov\t#256, r1\n" } } */
+  __write_stack_pointer((void*)0x100);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3104943_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_1.c
new file mode 100644
index 0000000..e4079da
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_1.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct record {
+  int data[1];
+};
+
+extern struct record ef ();
+
+struct record
+f ()
+{
+  struct record rv = { sizeof(rv) };
+  /* { dg-final { scan-assembler "mov\t#2, r15" } } */
+  return rv;
+}
+
+int
+xf ()
+{
+  struct record rv = ef();
+  /* { dg-final { scan-assembler "add\t#1, r15\n" } } */
+  return 1 + rv.data[0];
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3104943_2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_2.c
new file mode 100644
index 0000000..26401d9
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_2.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct record {
+  int data[2];
+};
+
+extern struct record ef ();
+
+struct record
+f ()
+{
+  struct record rv = { 1, sizeof(rv) };
+  /* { dg-final { scan-assembler "mov\t#1, r14" } } */
+  /* { dg-final { scan-assembler "mov\t#4, r15" } } */
+  return rv;
+}
+
+int
+xf ()
+{
+  struct record rv = ef();
+  /* { dg-final { scan-assembler "mov\tr14, r15" } } */
+  return 1 + rv.data[0];
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3104943_3.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_3.c
new file mode 100644
index 0000000..931c4ab
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_3.c
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct record {
+  int data[3];
+};
+
+extern struct record ef ();
+
+struct record
+f ()
+{
+  struct record rv = { 1, 2, sizeof(rv) };
+  /* NOTE: Although this can fit in 3 registers, the middle end treats
+     the return value as a DImode integer, which cannot be placed
+     starting in r13. */
+  /* { dg-final { scan-assembler "mov\t#1, r12" } } */
+  /* { dg-final { scan-assembler "mov\t#2, r13" } } */
+  /* { dg-final { scan-assembler "mov\t#6, r14" } } */
+  /* { dg-final { scan-assembler "mov\t#0, r15" } } */
+  return rv;
+}
+
+int
+xf ()
+{
+  struct record rv = ef();
+  /* { dg-final { scan-assembler "mov\tr12, r15" } } */
+  return 1 + rv.data[0];
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3104943_4.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_4.c
new file mode 100644
index 0000000..a809957
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_4.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct record {
+  int data[4];
+};
+
+extern struct record ef ();
+
+struct record
+f ()
+{
+  struct record rv = { 1, 2, 3, sizeof(rv) };
+  /* { dg-final { scan-assembler "mov\t#1, r12" } } */
+  /* { dg-final { scan-assembler "mov\t#2, r13" } } */
+  /* { dg-final { scan-assembler "mov\t#3, r14" } } */
+  /* { dg-final { scan-assembler "mov\t#8, r15" } } */
+  return rv;
+}
+
+int
+xf ()
+{
+  struct record rv = ef();
+  /* { dg-final { scan-assembler "mov\tr12, r15" } } */
+  return 1 + rv.data[0];
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3104943_5.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_5.c
new file mode 100644
index 0000000..69085b2
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3104943_5.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct record {
+  int data[5];
+};
+
+extern struct record ef ();
+
+struct record
+f ()
+{
+  struct record rv = { 1, 2, 3, 4, sizeof(rv) };
+  /* { dg-final { scan-assembler "mov\t#1, @r15" } } */
+  /* { dg-final { scan-assembler "mov\t#2, 2\\(r15\\)" } } */
+  /* { dg-final { scan-assembler "mov\t#3, 4\\(r15\\)" } } */
+  /* { dg-final { scan-assembler "mov\t#4, 6\\(r15\\)" } } */
+  /* { dg-final { scan-assembler "mov\t#10, 8\\(r15\\)" } } */
+  return rv;
+}
+
+int
+xf ()
+{
+  struct record rv = ef();
+  /* { dg-final { scan-assembler "mov\t@r1, r15" } } */
+  return 1 + rv.data[0];
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3112089.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3112089.c
new file mode 100644
index 0000000..ed177ba
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3112089.c
@@ -0,0 +1,67 @@
+/* https://sourceforge.net/tracker/?func=detail&aid=3112089&group_id=277223&atid=1177287 */
+
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef unsigned long int uint32_t;
+typedef unsigned int uint16_t;
+typedef unsigned char uint8_t;
+
+#define TIMERS_MAX 3
+#define TIMER_NULL TIMERS_MAX
+
+typedef struct{
+  uint32_t count;
+  uint32_t interval;
+  uint16_t *mbox;			/* caller supplied */
+  uint8_t prev;
+  uint8_t next;
+} TimerTCB;
+
+typedef uint8_t TimerId;
+
+volatile TimerTCB timerTable[TIMERS_MAX];
+volatile uint8_t timerListHead;
+volatile uint8_t timerListTail;
+volatile uint8_t timerFreeList;
+
+volatile uint32_t localTime;
+
+uint8_t TimerTickHandler(void);
+TimerId TimerCreate(uint32_t val, uint16_t *mbox, uint8_t options);
+
+uint8_t TimerTickHandler(void)
+{
+  uint8_t sts = 0;		/* assume no wakeup required */
+  volatile uint8_t t;
+  uint16_t *mbox;
+  uint32_t val;
+
+  localTime++;
+  if(timerListHead != TIMER_NULL){
+    timerTable[timerListHead].count--;
+
+    while((timerListHead != TIMER_NULL) && (timerTable[timerListHead].count == 0)){
+      /* What we're looking for is:
+        mov     2(r14), r15
+        mov     @r14, r14
+        jeq     .L11
+
+	except with a comparison of the newly read r14 before the jeq. */
+      /* { dg-final { scan-assembler "cmp\[ \t\]#0, r15" } } */
+      UART_SendByte('t');
+      t = timerListHead;
+
+      /* Remove from list of active timers */
+      timerListHead = timerTable[t].next;
+
+      if(timerListHead != TIMER_NULL){
+	timerTable[timerListHead].prev = TIMER_NULL;
+      }
+
+      sts = 1;
+    }
+  }
+  return sts;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3148801.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3148801.c
new file mode 100644
index 0000000..d10da65
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3148801.c
@@ -0,0 +1,20 @@
+/* https://sourceforge.net/tracker/?func=detail&aid=3148801&group_id=42303&atid=432701 */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct word5 {
+  int data[5];
+};
+
+extern struct word5 copy5 (struct word5 in);
+
+int test ()
+{
+  struct word5 local = { 1, 2, 3, 4, 5 };
+  struct word5 tmp;
+
+  /* { dg-final { scan-assembler "push\[ \t\]#5\n\[ \t\]push\[ \t\]#4\n\[ \t\]push\[ \t\]#3\n\[ \t\]push\[ \t\]#2\n" } } */
+  tmp = copy5(local);
+  return tmp.data[0];
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3177314_base.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3177314_base.c
new file mode 100644
index 0000000..24a3cf2
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3177314_base.c
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-additional-files "sf3177314_ext.c" } */
+
+extern int longname_l10iiiviiii20iiiviiii30iiiviiii40iiiviiii50iiiviiii60iiiviiii70iiiviiii80iiiviiii90iiiviiii100iiviiii110iiviiii120iiviiii130iiviiii140iiviiii150iiviiii160iiviiii170iiviiii180iiviiii190iiviiii200iiviiii210iiviiii220iiviiii230iiviiii240iiviiii250iiviiii260iiviiii270iiviiii280iiviiii290iiviiii;
+
+int main (int argc, char* argi[]) {
+  return 0 == longname_l10iiiviiii20iiiviiii30iiiviiii40iiiviiii50iiiviiii60iiiviiii70iiiviiii80iiiviiii90iiiviiii100iiviiii110iiviiii120iiviiii130iiviiii140iiviiii150iiviiii160iiviiii170iiviiii180iiviiii190iiviiii200iiviiii210iiviiii220iiviiii230iiviiii240iiviiii250iiviiii260iiviiii270iiviiii280iiviiii290iiviiii;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3177314_ext.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3177314_ext.c
new file mode 100644
index 0000000..061519d
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3177314_ext.c
@@ -0,0 +1,2 @@
+/* secondary test file referenced via sf3177314_base.c */
+int longname_l10iiiviiii20iiiviiii30iiiviiii40iiiviiii50iiiviiii60iiiviiii70iiiviiii80iiiviiii90iiiviiii100iiviiii110iiviiii120iiviiii130iiviiii140iiviiii150iiviiii160iiviiii170iiviiii180iiviiii190iiviiii200iiviiii210iiviiii220iiviiii230iiviiii240iiviiii250iiviiii260iiviiii270iiviiii280iiviiii290iiviiii;
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3188386.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3188386.c
new file mode 100644
index 0000000..877edb2
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3188386.c
@@ -0,0 +1,20 @@
+/* https://sourceforge.net/tracker/?func=detail&aid=3188386&group_id=42303&atid=432701 */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct sixbytes {
+  int data[3];
+};
+
+struct sixbytes
+f ()
+{
+  struct sixbytes rv = { 1, 2, sizeof(rv) };
+  /* { dg-final { scan-assembler "mov\[ \t\]#1, r12" } } */
+  /* { dg-final { scan-assembler "mov\[ \t\]#2, r13" } } */
+  /* { dg-final { scan-assembler "mov\[ \t\]#6, r14" } } */
+  /* { dg-final { scan-assembler "mov\[ \t\]#0, r15" } } */
+  
+  return rv;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3188386_2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3188386_2.c
new file mode 100644
index 0000000..e18575c
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3188386_2.c
@@ -0,0 +1,17 @@
+/* https://sourceforge.net/tracker/?func=detail&aid=3188386&group_id=42303&atid=432701 */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct fivebytes {
+  char data[5];
+} __attribute__((packed));
+
+struct fivebytes
+f ()
+{
+  struct fivebytes rv = { 1, 2, 3, 4, sizeof(rv) };
+  
+  /* { dg-final { scan-assembler "mov\t#513, r12\n\tmov\t#1027, r13\n\tmov\t#5, r14\n\tmov\t#0, r15" } } */
+  return rv;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_1.c
new file mode 100644
index 0000000..6a755dc
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_1.c
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+int naked __attribute__((naked)); /* { dg-warning "'naked' attribute ignored" } */
+int signal __attribute__((signal)); /* { dg-warning "'signal' attribute ignored" } */
+int interrupt __attribute__((interrupt)); /* { dg-warning "'interrupt' attribute ignored" } */
+int task __attribute__((task)); /* { dg-warning "'task' attribute ignored" } */
+int wakeup __attribute__((wakeup)); /* { dg-warning "'wakeup' attribute ignored" } */
+int critical __attribute__((critical)); /* { dg-warning "'critical' attribute ignored" } */
+int reentrant __attribute__((reentrant)); /* { dg-warning "'reentrant' attribute ignored" } */
+int saveprologue __attribute__((saveprologue)); /* { dg-warning "'saveprologue' attribute ignored" } */
+int noint_hwmul __attribute__((noint_hwmul)); /* { dg-warning "'noint_hwmul' attribute ignored" } */
+
+
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_2.c
new file mode 100644
index 0000000..2014aae
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_2.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+
+__attribute__((wakeup))
+void wakeup_requires_interrupt () { } /* { dg-warning "'wakeup' attribute ignored \\(requires 'interrupt'\\)" } */
+__attribute__((signal))
+void signal_requires_interrupt () { } /* { dg-warning "'signal' attribute ignored \\(requires 'interrupt'\\)" } */
+
+__attribute__((reentrant,naked))
+void reentrant_naked () { } /* { dg-warning "'reentrant' attribute ignored \\(incompatible with 'naked'\\)" } */
+__attribute__((critical,naked))
+void critical_naked () { } /* { dg-warning "'critical' attribute ignored \\(incompatible with 'naked'\\)" } */
+
+__attribute__((reentrant,critical))
+void no_reentrant_critical () { } /* { dg-warning "'reentrant' attribute ignored \\(incompatible with 'critical'\\)" } */
+__attribute__((reentrant,interrupt(2)))
+void no_reentrant_interrupt () { } /* { dg-warning "'reentrant' attribute ignored \\(incompatible with 'interrupt'\\)" } */
+__attribute__((critical,interrupt(4)))
+void no_critical_interrupt () { } /* { dg-warning "'critical' attribute ignored \\(incompatible with 'interrupt'\\)" } */
+
+__attribute__((naked,task))
+void no_naked_task () { } /* { dg-warning "'naked' attribute ignored \\(incompatible with 'task'\\)" } */
+
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_3.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_3.c
new file mode 100644
index 0000000..b9055d4
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_3.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern void ref (int * p);
+extern int call ();
+
+/* Task functions may allocate frames */
+__attribute__ ((task))
+int task_with_frame ()
+{
+  int v;
+  ref(&v);
+  return v;
+}
+
+/* Naked functions should not allocate frames.  SF 3264484 describes
+ * why this is a warning not an error. */
+__attribute__ ((naked))
+int naked_with_frame () /* { dg-warning "function requires 2 bytes for stack storage but frame allocation inhibited by 'naked'" } */
+{
+  int v;
+  ref(&v);
+  return v;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_4.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_4.c
new file mode 100644
index 0000000..f9c54e8
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_4.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+
+/* Interrupt vectors non-negative */
+__attribute__ ((interrupt(-2)))
+void negative_isr () { } /* { dg-error "interrupt vector offset -2 must be even and non-negative" } */
+
+/* Interrupt vectors even */
+__attribute__ ((interrupt(1)))
+void odd_isr () { } /* { dg-error "interrupt vector offset 1 must be even and non-negative" } */
+
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_5.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_5.c
new file mode 100644
index 0000000..9fdafd5
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_5.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+
+/* Standard syntax */
+__attribute__ ((interrupt(4*2)))
+void vectored_isr () { }
+/* { dg-final { scan-assembler "vectored_isr:\n.global\t__isr_4\n__isr_4:\n" } } */
+
+/* Old flag for non-associated ISR */
+__attribute__ ((interrupt(255)))
+void legacy_unvectored_isr () { }
+
+/* New syntax for non-associated ISR */
+__attribute__ ((interrupt))
+void unvectored_isr () { }
+
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_6.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_6.c
new file mode 100644
index 0000000..92c9937
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_6.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-mivcnt=16" } */
+
+/* Vector out of range */
+__attribute__ ((interrupt(16*2)))
+void overflowed_vector () { } /* { dg-error "interrupt vector 16 is beyond end of MCU vector table" } */
+
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_7.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_7.c
new file mode 100644
index 0000000..b291112
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_7.c
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+/* None of these non-hosted functions should generate a return
+ * instruction of any sort. */
+/* { dg-final { scan-assembler-not "\tret" } } */
+
+__attribute__ ((task))
+int task ()
+{
+  return 32;
+}
+
+__attribute__ ((naked))
+int naked ()
+{
+  return 33;
+}
+
+extern int v;
+
+__attribute__ ((interrupt,naked))
+void naked_isr ()
+{
+  v = 34;
+  /* { dg-final { scan-assembler "\tmov\t#34, &v\n" } } */
+}
+
+__attribute__ ((interrupt,task))
+void task_isr ()
+{
+  v = 35;
+  /* { dg-final { scan-assembler "\tmov\t#35, &v\n" } } */
+}
+
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3200763_8.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_8.c
new file mode 100644
index 0000000..4c2fd4c
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3200763_8.c
@@ -0,0 +1,34 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+/* Hosted tasks include the return instruction */
+__attribute__ ((task,hosted))
+int hosted_task ()
+{
+  /* { dg-final { scan-assembler "\tmov\t#32, r15\n\tret\n" } } */
+  return 32;
+}
+
+/* Hosted naked include the return instruction */
+__attribute__ ((naked,hosted))
+int hosted_naked ()
+{
+  /* { dg-final { scan-assembler "\tmov\t#33, r15\n\tret\n" } } */
+  return 33;
+}
+
+extern int v;
+
+__attribute__ ((interrupt,naked,hosted))
+void hosted_naked_isr ()
+{
+  v = 34;
+  /* { dg-final { scan-assembler "\tmov\t#34, &v\n\treti\n" } } */
+}
+
+__attribute__ ((interrupt,task,hosted))
+void hosted_task_isr ()
+{
+  v = 35;
+  /* { dg-final { scan-assembler "\tmov\t#35, &v\n\treti\n" } } */
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3201686.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3201686.c
new file mode 100644
index 0000000..a81bd7a
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3201686.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+/* { dg-final { scan-assembler-not ".type\tdisappearing,@function" } } */
+extern volatile int v;
+static void disappearing ()
+{
+  v = 'd';
+}
+
+/* { dg-final { scan-assembler ".type\tpreserved,@function" } } */
+__attribute__ ((interrupt(1*2)))
+static void preserved ()
+{
+  v = 'p';
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3207853.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3207853.c
new file mode 100644
index 0000000..ba9072e
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3207853.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern void doit (unsigned long long int v);
+void call ()
+{
+  static const unsigned long long int value = 0x123456789abcdef0ULL;
+
+  /* Builds on 64-bit systems generate different code than ones on
+   * 32-bit systems. */
+  /* { dg-final { scan-assembler "mov\t#llo\\((-1698898192|1311768467463790320)\\), r12" } } */
+  /* { dg-final { scan-assembler "mov\t#lhi\\((-1698898192|1311768467463790320)\\), r13" } } */
+  /* { dg-final { scan-assembler "mov\t#(llo\\(305419896\\)|hlo\\(1311768467463790320\\)), r14" } } */
+  /* { dg-final { scan-assembler "mov\t#(lhi\\(305419896\\)|hhi\\(1311768467463790320\\)), r15" } } */
+  doit(value);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_1.c
new file mode 100644
index 0000000..6733638
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_1.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tnop\n\tret" } } */
+  __delay_cycles (1);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_11.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_11.c
new file mode 100644
index 0000000..fecda99
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_11.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tmov\t#3, r15\n.L__delay__5:\n\tdec\tr15\n\tjnz\t.L__delay__5\n\tret" } } */
+  __delay_cycles (11);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_2.c
new file mode 100644
index 0000000..e0bd991
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_2.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tnop\n\tnop\n\tret" } } */
+  __delay_cycles (2);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_3.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_3.c
new file mode 100644
index 0000000..2d51a60
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_3.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tnop\n\tnop\n\tnop\n\tret" } } */
+  __delay_cycles (3);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_4.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_4.c
new file mode 100644
index 0000000..b97a0c1
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_4.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tmov\t#1, r15\n.L__delay__5:\n\tdec\tr15\n\tjnz\t.L__delay__5\n\tret" } } */
+  __delay_cycles (4);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_5.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_5.c
new file mode 100644
index 0000000..c654c70
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_5.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tnop\n\tmov\t#1, r15\n.L__delay__6:\n\tdec\tr15\n\tjnz\t.L__delay__6\n\tret" } } */
+  __delay_cycles (5);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_6.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_6.c
new file mode 100644
index 0000000..d3ad235
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_6.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tnop\n\tnop\n\tmov\t#1, r15\n.L__delay__7:\n\tdec\tr15\n\tjnz\t.L__delay__7\n\tret" } } */
+  __delay_cycles (6);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_7.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_7.c
new file mode 100644
index 0000000..87b2454
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_7.c
@@ -0,0 +1,7 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+void foo ()
+{
+  /* { dg-final { scan-assembler "foo:\n\tmov\t#2, r15\n.L__delay__5:\n\tdec\tr15\n\tjnz\t.L__delay__5\n\tret" } } */
+  __delay_cycles (7);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3237005_check.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_check.c
new file mode 100644
index 0000000..a6e8567
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3237005_check.c
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+int foo (int n)
+{
+  __delay_cycles (n); /* { dg-error "__delay_cycles argument must be non-negative integer constant" } */
+  __delay_cycles (-4); /* { dg-error "__delay_cycles argument must be non-negative integer constant" } */
+  __delay_cycles(3 * 65536UL); /* ok: 2 + 65535*3 + 1 */
+  __delay_cycles(1 + 3 * 65536UL); /* ok: 2 + 65535*3 + 2 */
+  __delay_cycles(2 + 3 * 65536UL); /* { dg-error "__delay_cycles argument too large" } */
+  __delay_cycles(3 + 3 * 65536UL); /* { dg-error "__delay_cycles argument too large" } */
+  return 0;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3257192_1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3257192_1.c
new file mode 100644
index 0000000..034144b
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3257192_1.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern int v;
+extern void ref (int * p);
+
+__attribute__ ((reentrant,noreturn))
+void noreturn (int arg)
+{
+  int a;
+  ref(&a);
+  v = a+arg;
+  __dint();
+  __bis_status_register (0xF0);
+} /* { dg-warning "'noreturn' function does return" } */
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3261372.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3261372.c
new file mode 100644
index 0000000..f6ab6a3
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3261372.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-g" } */
+
+__attribute__((critical))
+int
+critical (int a)
+{
+  return a+1;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3290923.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3290923.c
new file mode 100644
index 0000000..2dbbb1b
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3290923.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern int longcall (unsigned long long int regs,
+		     int a1,
+		     int a2);
+
+int test ()
+{
+  int rv;
+  rv = longcall (0ULL, 1, 1);
+  /* { dg-final { scan-assembler "\n\tcall\t#longcall\n\tadd\t#4, r1\n" } } */
+  rv += longcall (0ULL, 2, 2);
+  return rv;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3296698.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3296698.c
new file mode 100644
index 0000000..8bf7ca6
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3296698.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+
+typedef struct {
+    int bit:1;
+    int :15;
+} type_x;
+
+static inline type_x getX() {
+    union {
+      int f;
+      type_x t;
+    } c;
+    c.f = *(int *)0x100;
+    return c.t;
+}
+
+extern void subr();
+
+void func() {
+  /* { dg-final { scan-assembler "\n\tbit.b\t#1,&256\n\tjeq\t.L1\n\tcall\t#subr\n" } } */
+  if (getX().bit)
+    subr();
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/sf3300205.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3300205.c
new file mode 100644
index 0000000..745a80f
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/sf3300205.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+volatile unsigned char s_char;
+volatile unsigned char s_short;
+volatile unsigned char s_int;
+volatile unsigned char s_long;
+volatile unsigned char s_longlong;
+volatile unsigned char s_float;
+volatile unsigned char s_double;
+
+void test ()
+{
+  /* { dg-final { scan-assembler "\tmov.b\t#1, \&s_char\n" } } */
+  s_char = sizeof(char);
+  /* { dg-final { scan-assembler "\tmov.b\t#2, \&s_short\n" } } */
+  s_short = sizeof(short int);
+  /* { dg-final { scan-assembler "\tmov.b\t#2, \&s_int\n" } } */
+  s_int = sizeof(int);
+  /* { dg-final { scan-assembler "\tmov.b\t#4, \&s_long\n" } } */
+  s_long = sizeof(long int);
+  /* { dg-final { scan-assembler "\tmov.b\t#8, \&s_longlong\n" } } */
+  s_longlong = sizeof(long long int);
+  /* { dg-final { scan-assembler "\tmov.b\t#4, \&s_float\n" } } */
+  s_float = sizeof(float);
+  /* { dg-final { scan-assembler "\tmov.b\t#4, \&s_double\n" } } */
+  s_double = sizeof(double);
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/vararg-1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vararg-1.c
new file mode 100644
index 0000000..531fd0c
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vararg-1.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <stdarg.h>
+
+int test (int a1, ...)
+{
+  int v1;
+  va_list va_arglist;
+
+  va_start (va_arglist, a1);
+  v1 = va_arg (va_arglist, int);
+  va_end (va_arglist);
+  /* { dg-final { scan-assembler "\tmov\t4\\(r1\\), r15\n\tret\n" } } */
+  return v1;
+}
+
+extern int etest (int a1, ...);
+
+int calltest ()
+{
+  /* { dg-final { scan-assembler "\tcall\t#etest\n\tadd\t#4, r1\n\tret\n" } } */
+  return etest (1, 2);
+}
+  
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/vwa1.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vwa1.c
new file mode 100644
index 0000000..85e8139
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vwa1.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+extern volatile unsigned int periph;
+
+void vwa (unsigned int v)
+{
+  /* { dg-final { scan-assembler "\n\tand\tr15, \&periph\n" } } */
+  periph &= v;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/vwa2.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vwa2.c
new file mode 100644
index 0000000..5ab3974
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vwa2.c
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O -mno-volatile-workaround" } */
+
+extern volatile unsigned int periph;
+
+void vwa (unsigned int v)
+{
+  /* { dg-final { scan-assembler "\n\tmov\t\&periph, r14\n\tand\tr14, r15\n\tmov\tr15, \&periph\n" } } */
+  periph &= v;
+}
diff --git gcc-4.5.3.orig/gcc/testsuite/gcc.target/msp430/vwa3.c gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vwa3.c
new file mode 100644
index 0000000..70af5af
--- /dev/null
+++ gcc-4.5.3/gcc/testsuite/gcc.target/msp430/vwa3.c
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-options "-O -mno-volatile-workaround" } */
+
+extern volatile unsigned char periph8;
+extern volatile unsigned int periph16;
+
+extern void use (unsigned long long int regargs,
+		 unsigned int p16,
+		 unsigned char p8);
+
+void vwa_push ()
+{
+  /* pushm1 requires vwa support */
+  /* { dg-final { scan-assembler "\n\tmov.b\t\&periph8, r14\n\tmov\t\&periph16, r15\n\tpush.b\tr14\n\tpush\tr15\n" } } */
+  use (0ULL, periph16, periph8);
+}
diff --git gcc-4.5.3.orig/gcc/tree-sra.c gcc-4.5.3/gcc/tree-sra.c
index 06d2cdf..c43ad25 100644
--- gcc-4.5.3.orig/gcc/tree-sra.c
+++ gcc-4.5.3/gcc/tree-sra.c
@@ -809,7 +809,7 @@ create_access (tree expr, gimple stmt, bool write)
 /* Return true iff TYPE is a RECORD_TYPE with fields that are either of gimple
    register types or (recursively) records with only these two kinds of fields.
    It also returns false if any of these records has a zero-size field as its
-   last field.  */
+   last field or has a bit-field.  */
 
 static bool
 type_consists_of_records_p (tree type)
@@ -825,6 +825,9 @@ type_consists_of_records_p (tree type)
       {
 	tree ft = TREE_TYPE (fld);
 
+	if (DECL_BIT_FIELD (fld))
+	  return false;
+
 	if (!is_gimple_reg_type (ft)
 	    && !type_consists_of_records_p (ft))
 	  return false;
diff --git gcc-4.5.3.orig/libgcc/config.host gcc-4.5.3/libgcc/config.host
index c5f3d6e..685c177 100644
--- gcc-4.5.3.orig/libgcc/config.host
+++ gcc-4.5.3/libgcc/config.host
@@ -229,6 +229,8 @@ avr-*-*)
     # Make HImode functions for AVR
     tmake_file=${cpu_type}/t-avr
 	;;
+msp430-*-*)
+	;;
 bfin*-elf*)
         ;;
 bfin*-uclinux*)
