diff -Nur bfd/archures.c bfd/archures.c
--- bfd/archures.c	2006-03-06 14:42:03.000000000 +0100
+++ bfd/archures.c	2006-08-28 20:01:10.714097550 +0200
@@ -334,6 +334,7 @@
 .#define bfd_mach_avr3		3
 .#define bfd_mach_avr4		4
 .#define bfd_mach_avr5		5
+.#define bfd_mach_avr6		6
 .  bfd_arch_bfin,        {* ADI Blackfin *}
 .#define bfd_mach_bfin          1
 .  bfd_arch_cr16c,       {* National Semiconductor CompactRISC. *}
diff -Nur bfd/bfd-in2.h bfd/bfd-in2.h
--- bfd/bfd-in2.h	2006-03-26 01:38:42.000000000 +0100
+++ bfd/bfd-in2.h	2006-08-28 20:01:10.743095447 +0200
@@ -1931,6 +1931,7 @@
 #define bfd_mach_avr3          3
 #define bfd_mach_avr4          4
 #define bfd_mach_avr5          5
+#define bfd_mach_avr6          6
   bfd_arch_bfin,        /* ADI Blackfin */
 #define bfd_mach_bfin          1
   bfd_arch_cr16c,       /* National Semiconductor CompactRISC. */
@@ -3539,10 +3540,22 @@
 command address) into 8 bit immediate value of LDI insn.  */
   BFD_RELOC_AVR_LO8_LDI_PM,
 
+/* This is a 16 bit reloc for the AVR that stores 8 bit value
+(command address) into 8 bit immediate value of LDI insn. If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+in the lower 128k.  */
+  BFD_RELOC_AVR_LO8_LDI_GS,
+
 /* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
 of command address) into 8 bit immediate value of LDI insn.  */
   BFD_RELOC_AVR_HI8_LDI_PM,
 
+/* This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+of command address) into 8 bit immediate value of LDI insn.  If the address
+is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+below 128k.  */
+  BFD_RELOC_AVR_HI8_LDI_GS,
+
 /* This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
 of command address) into 8 bit immediate value of LDI insn.  */
   BFD_RELOC_AVR_HH8_LDI_PM,
diff -Nur bfd/cpu-avr.c bfd/cpu-avr.c
--- bfd/cpu-avr.c	2006-03-03 16:54:23.000000000 +0100
+++ bfd/cpu-avr.c	2006-08-28 20:01:10.771093417 +0200
@@ -82,7 +82,10 @@
   N (16, bfd_mach_avr4, "avr:4", FALSE, & arch_info_struct[4]),
 
   /* ATmega161, ATmega163, ATmega32, AT94K.  */
-  N (22, bfd_mach_avr5, "avr:5", FALSE, NULL)
+  N (22, bfd_mach_avr5, "avr:5", FALSE, & arch_info_struct[5]),
+
+  /* ATmega256x.  */
+  N (22, bfd_mach_avr6, "avr:6", FALSE, NULL)
 };
 
 const bfd_arch_info_type bfd_avr_arch =
diff -Nur bfd/elf32-avr.c bfd/elf32-avr.c
--- bfd/elf32-avr.c	2006-03-03 16:54:23.000000000 +0100
+++ bfd/elf32-avr.c	2006-08-28 20:18:20.796399347 +0200
@@ -25,6 +25,92 @@
 #include "libbfd.h"
 #include "elf-bfd.h"
 #include "elf/avr.h"
+#include "elf32-avr.h"
+
+/* Enable debugging printout at stdout with this variable.  */
+static bfd_boolean debug_relax = FALSE;
+
+/* Enable debugging printout at stdout with this variable.  */
+static bfd_boolean debug_stubs = FALSE;
+
+/* Hash table initialization and handling.  Code is taken from the hppa port
+   and adapted to the needs of AVR.  */
+
+/* We use two hash tables to hold information for linking avr objects.
+
+   The first is the elf32_avr_link_hash_tablse which is derived from the
+   stanard ELF linker hash table.  We use this as a place to attach the other
+   hash table and some static information.
+
+   The second is the stub hash table which is derived from the base BFD
+   hash table.  The stub hash table holds the information on the linker
+   stubs.  */
+
+struct elf32_avr_stub_hash_entry
+{
+  /* Base hash table entry structure.  */
+  struct bfd_hash_entry bh_root;
+
+  /* Offset within stub_sec of the beginning of this stub.  */
+  bfd_vma stub_offset;
+
+  /* Given the symbol's value and its section we can determine its final
+     value when building the stubs (so the stub knows where to jump).  */
+  bfd_vma target_value;
+
+  /* This way we could mark stubs to be no longer necessary.  */
+  bfd_boolean is_actually_needed;
+};
+
+struct elf32_avr_link_hash_table
+{
+  /* The main hash table.  */
+  struct elf_link_hash_table etab;
+
+  /* The stub hash table.  */
+  struct bfd_hash_table bstab;
+
+  bfd_boolean no_stubs;
+
+  /* Linker stub bfd.  */
+  bfd *stub_bfd;
+
+  /* The stub section.  */
+  asection *stub_sec;
+
+  /* Usually 0, unless we are generating code for a bootloader.  Will
+     be initialized by elf32_avr_size_stubs to the vma offset of the
+     output section associated with the stub section.  */
+  bfd_vma vector_base;
+
+  /* Assorted information used by elf32_avr_size_stubs.  */
+  unsigned int        bfd_count;
+  int                 top_index;
+  asection **         input_list;
+  Elf_Internal_Sym ** all_local_syms;
+
+  /* Tables for mapping vma beyond the 128k boundary to the address of the
+     corresponding stub.  (AMT)
+     "amt_max_entry_cnt" reflects the number of entries that memory is allocated
+     for in the "amt_stub_offsets" and "amt_destination_addr" arrays.
+     "amt_entry_cnt" informs how many of these entries actually contain
+     useful data.  */
+  unsigned int amt_entry_cnt;
+  unsigned int amt_max_entry_cnt;
+  bfd_vma *    amt_stub_offsets;
+  bfd_vma *    amt_destination_addr;
+};
+
+/* Various hash macros and functions.  */
+#define avr_link_hash_table(p) \
+  ((struct elf32_avr_link_hash_table *) ((p)->hash))
+
+#define avr_stub_hash_entry(ent) \
+  ((struct elf32_avr_stub_hash_entry *)(ent))
+
+#define avr_stub_hash_lookup(table, string, create, copy) \
+  ((struct elf32_avr_stub_hash_entry *) \
+   bfd_hash_lookup ((table), (string), (create), (copy)))
 
 static reloc_howto_type elf_avr_howto_table[] =
 {
@@ -101,7 +187,8 @@
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
 
-  /* A 16 bit absolute relocation for command address.  */
+  /* A 16 bit absolute relocation for command address
+     Will be changed when linker stubs are needed.  */
   HOWTO (R_AVR_16_PM,		/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -207,7 +294,7 @@
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
   /* A low 8 bit absolute relocation of 24 bit program memory address.
-     For LDI command.  */
+     For LDI command.  Will not be changed when linker stubs are needed. */
   HOWTO (R_AVR_LO8_LDI_PM,	/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -221,8 +308,8 @@
 	 0xffff,		/* src_mask */
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
-  /* A high 8 bit absolute relocation of 16 bit program memory address.
-     For LDI command.  */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will not be changed when linker stubs are needed. */
   HOWTO (R_AVR_HI8_LDI_PM,	/* type */
 	 9,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -236,8 +323,8 @@
 	 0xffff,		/* src_mask */
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
-  /* A high 8 bit absolute relocation of 24 bit program memory address.
-     For LDI command.  */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will not be changed when linker stubs are needed. */
   HOWTO (R_AVR_HH8_LDI_PM,	/* type */
 	 17,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -251,8 +338,8 @@
 	 0xffff,		/* src_mask */
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
-  /* A low 8 bit absolute relocation of a negative 24 bit
-     program memory address.  For LDI command.  */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will not be changed when linker stubs are needed. */
   HOWTO (R_AVR_LO8_LDI_PM_NEG,	/* type */
 	 1,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -266,8 +353,8 @@
 	 0xffff,		/* src_mask */
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
-  /* A high 8 bit absolute relocation of a negative 16 bit
-     program memory address.  For LDI command.  */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will not be changed when linker stubs are needed. */
   HOWTO (R_AVR_HI8_LDI_PM_NEG,	/* type */
 	 9,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -281,8 +368,8 @@
 	 0xffff,		/* src_mask */
 	 0xffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
-  /* A high 8 bit absolute relocation of a negative 24 bit
-     program memory address.  For LDI command.  */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will not be changed when linker stubs are needed. */
   HOWTO (R_AVR_HH8_LDI_PM_NEG,	/* type */
 	 17,			/* rightshift */
 	 1,			/* size (0 = byte, 1 = short, 2 = long) */
@@ -382,7 +469,37 @@
 	 FALSE,			/* partial_inplace */
 	 0xffff,		/* src_mask */
 	 0xffff,		/* dst_mask */
-	 FALSE) 		/* pcrel_offset */
+	 FALSE), 		/* pcrel_offset */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will be changed when linker stubs are needed. */
+  HOWTO (R_AVR_LO8_LDI_GS,      /* type */
+         1,                     /* rightshift */
+         1,                     /* size (0 = byte, 1 = short, 2 = long) */
+         8,                     /* bitsize */
+         FALSE,                 /* pc_relative */
+         0,                     /* bitpos */
+         complain_overflow_dont, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_AVR_LO8_LDI_GS",    /* name */
+         FALSE,                 /* partial_inplace */
+         0xffff,                /* src_mask */
+         0xffff,                /* dst_mask */
+         FALSE),                /* pcrel_offset */
+  /* A low 8 bit absolute relocation of 24 bit program memory address.
+     For LDI command.  Will be changed when linker stubs are needed. */
+  HOWTO (R_AVR_HI8_LDI_GS,      /* type */
+         9,                     /* rightshift */
+         1,                     /* size (0 = byte, 1 = short, 2 = long) */
+         8,                     /* bitsize */
+         FALSE,                 /* pc_relative */
+         0,                     /* bitpos */
+         complain_overflow_dont, /* complain_on_overflow */
+         bfd_elf_generic_reloc, /* special_function */
+         "R_AVR_HI8_LDI_GS",    /* name */
+         FALSE,                 /* partial_inplace */
+         0xffff,                /* src_mask */
+         0xffff,                /* dst_mask */
+         FALSE)                 /* pcrel_offset */
 };
 
 /* Map BFD reloc types to AVR ELF reloc types.  */
@@ -393,7 +510,7 @@
   unsigned int elf_reloc_val;
 };
 
- static const struct avr_reloc_map avr_reloc_map[] =
+static const struct avr_reloc_map avr_reloc_map[] =
 {
   { BFD_RELOC_NONE,                 R_AVR_NONE },
   { BFD_RELOC_32,                   R_AVR_32 },
@@ -410,7 +527,9 @@
   { BFD_RELOC_AVR_HH8_LDI_NEG,      R_AVR_HH8_LDI_NEG },
   { BFD_RELOC_AVR_MS8_LDI_NEG,      R_AVR_MS8_LDI_NEG },
   { BFD_RELOC_AVR_LO8_LDI_PM,       R_AVR_LO8_LDI_PM },
+  { BFD_RELOC_AVR_LO8_LDI_GS,       R_AVR_LO8_LDI_GS },
   { BFD_RELOC_AVR_HI8_LDI_PM,       R_AVR_HI8_LDI_PM },
+  { BFD_RELOC_AVR_HI8_LDI_GS,       R_AVR_HI8_LDI_GS },
   { BFD_RELOC_AVR_HH8_LDI_PM,       R_AVR_HH8_LDI_PM },
   { BFD_RELOC_AVR_LO8_LDI_PM_NEG,   R_AVR_LO8_LDI_PM_NEG },
   { BFD_RELOC_AVR_HI8_LDI_PM_NEG,   R_AVR_HI8_LDI_PM_NEG },
@@ -429,8 +548,101 @@
    that we will never suggest a wrap-around jump during relaxation.
    The logic of the source code later on assumes that in
    avr_pc_wrap_around one single bit is set.  */
+static bfd_vma avr_pc_wrap_around = 0x10000000;
+
+/* If this variable holds a value different from zero, the linker relaxation
+   machine will try to optimize call/ret sequences by a single jump
+   instruction. This option could be switched off by a linker switch.  */
+static int avr_replace_call_ret_sequences = 1;
+
+/* Initialize an entry in the stub hash table.  */
+
+static struct bfd_hash_entry *
+stub_hash_newfunc (struct bfd_hash_entry *entry,
+                   struct bfd_hash_table *table,
+                   const char *string)
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+                                 sizeof (struct elf32_avr_stub_hash_entry));
+      if (entry == NULL)
+        return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = bfd_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct elf32_avr_stub_hash_entry *hsh;
 
-unsigned int avr_pc_wrap_around = 0x10000000;
+      /* Initialize the local fields.  */
+      hsh = avr_stub_hash_entry (entry);
+      hsh->stub_offset = 0;
+      hsh->target_value = 0;
+    }
+
+  return entry;
+}
+
+/* Create the derived linker hash table.  The AVR ELF port uses the derived
+   hash table to keep information specific to the AVR ELF linker (without
+   using static variables).  */
+
+static struct bfd_link_hash_table *
+elf32_avr_link_hash_table_create (bfd *abfd)
+{
+  struct elf32_avr_link_hash_table *htab;
+  bfd_size_type amt = sizeof (*htab);
+
+  htab = bfd_malloc (amt);
+  if (htab == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&htab->etab, abfd,
+                                      _bfd_elf_link_hash_newfunc,
+                                      sizeof (struct elf_link_hash_entry)))
+    {
+      free (htab);
+      return NULL;
+    }
+
+  /* Init the stub hash table too.  */
+  if (!bfd_hash_table_init (&htab->bstab, stub_hash_newfunc,
+                            sizeof (struct elf32_avr_stub_hash_entry)))
+    return NULL;
+
+  htab->stub_bfd = NULL;
+  htab->stub_sec = NULL;
+
+  /* Initialize the address mapping table.  */
+  htab->amt_stub_offsets = NULL;
+  htab->amt_destination_addr = NULL;
+  htab->amt_entry_cnt = 0;
+  htab->amt_max_entry_cnt = 0;
+
+  return &htab->etab.root;
+}
+
+/* Free the derived linker hash table.  */
+
+static void
+elf32_avr_link_hash_table_free (struct bfd_link_hash_table *btab)
+{
+  struct elf32_avr_link_hash_table *htab
+    = (struct elf32_avr_link_hash_table *) btab;
+
+  /* Free the address mapping table.  */
+  if (htab->amt_stub_offsets != NULL)
+    free (htab->amt_stub_offsets);
+  if (htab->amt_destination_addr != NULL)
+    free (htab->amt_destination_addr);
+
+  bfd_hash_table_free (&htab->bstab);
+  _bfd_generic_link_hash_table_free (btab);
+}
 
 /* Calculates the effective distance of a pc relative jump/call.  */
 static int
@@ -564,20 +776,57 @@
   return TRUE;
 }
 
+static bfd_boolean
+avr_stub_is_required_for_16_bit_reloc (bfd_vma relocation)
+{
+  return (relocation >= 0x020000);
+}
+
+/* Returns the address of the corresponding stub if there is one.
+   Returns otherwise an address above 0x020000.  This function
+   could also be used, if there is no knowledge on the section where
+   the destination is found.  */
+
+static bfd_vma
+avr_get_stub_addr (bfd_vma srel,
+                   struct elf32_avr_link_hash_table *htab)
+{
+  unsigned int index;
+  bfd_vma stub_sec_addr =
+              (htab->stub_sec->output_section->vma +
+	       htab->stub_sec->output_offset);
+
+  for (index = 0; index < htab->amt_max_entry_cnt; index ++)
+    if (htab->amt_destination_addr[index] == srel)
+      return htab->amt_stub_offsets[index] + stub_sec_addr;
+
+  /* Return an address that could not be reached by 16 bit relocs.  */
+  return 0x020000;
+}
+
 /* Perform a single relocation.  By default we use the standard BFD
    routines, but a few relocs, we have to do them ourselves.  */
 
 static bfd_reloc_status_type
-avr_final_link_relocate (reloc_howto_type *  howto,
-			 bfd *               input_bfd,
-			 asection *          input_section,
-			 bfd_byte *          contents,
-			 Elf_Internal_Rela * rel,
-			 bfd_vma             relocation)
+avr_final_link_relocate (reloc_howto_type *                 howto,
+			 bfd *                              input_bfd,
+			 asection *                         input_section,
+			 bfd_byte *                         contents,
+			 Elf_Internal_Rela *                rel,
+                         bfd_vma                            relocation,
+                         struct elf32_avr_link_hash_table * htab)
 {
   bfd_reloc_status_type r = bfd_reloc_ok;
   bfd_vma               x;
   bfd_signed_vma	srel;
+  bfd_signed_vma	reloc_addr;
+  bfd_boolean           use_stubs = FALSE;
+  /* Usually is 0, unless we are generating code for a bootloader.  */
+  bfd_signed_vma        base_addr = htab->vector_base;
+
+  /* Absolute addr of the reloc in the final excecutable.  */
+  reloc_addr = rel->r_offset + input_section->output_section->vma
+	       + input_section->output_offset;
 
   switch (howto->type)
     {
@@ -748,9 +997,31 @@
       bfd_put_16 (input_bfd, x, contents);
       break;
 
+    case R_AVR_LO8_LDI_GS:
+      use_stubs = (!htab->no_stubs);
+      /* Fall through.  */
     case R_AVR_LO8_LDI_PM:
       contents += rel->r_offset;
       srel = (bfd_signed_vma) relocation + rel->r_addend;
+
+      if (use_stubs
+          && avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
+        {
+          bfd_vma old_srel = srel;
+
+          /* We need to use the address of the stub instead.  */
+          srel = avr_get_stub_addr (srel, htab);
+          if (debug_stubs)
+            printf ("LD: Using jump stub (at 0x%x) with destination 0x%x for "
+                    "reloc at address 0x%x.\n",
+                    (unsigned int) srel,
+                    (unsigned int) old_srel,
+                    (unsigned int) reloc_addr);
+
+	  if (avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
+	    return bfd_reloc_outofrange;
+        }
+
       if (srel & 1)
 	return bfd_reloc_outofrange;
       srel = srel >> 1;
@@ -759,9 +1030,31 @@
       bfd_put_16 (input_bfd, x, contents);
       break;
 
+    case R_AVR_HI8_LDI_GS:
+      use_stubs = (!htab->no_stubs);
+      /* Fall through.  */
     case R_AVR_HI8_LDI_PM:
       contents += rel->r_offset;
       srel = (bfd_signed_vma) relocation + rel->r_addend;
+
+      if (use_stubs
+          && avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
+        {
+          bfd_vma old_srel = srel;
+
+          /* We need to use the address of the stub instead.  */
+          srel = avr_get_stub_addr (srel, htab);
+          if (debug_stubs)
+            printf ("LD: Using jump stub (at 0x%x) with destination 0x%x for "
+                    "reloc at address 0x%x.\n",
+                    (unsigned int) srel,
+                    (unsigned int) old_srel,
+                    (unsigned int) reloc_addr);
+
+	  if (avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
+	    return bfd_reloc_outofrange;
+        }
+
       if (srel & 1)
 	return bfd_reloc_outofrange;
       srel = srel >> 1;
@@ -833,6 +1126,35 @@
       bfd_put_16 (input_bfd, (bfd_vma) srel & 0xffff, contents+2);
       break;
 
+    case R_AVR_16_PM:
+      use_stubs = (!htab->no_stubs);
+      contents += rel->r_offset;
+      srel = (bfd_signed_vma) relocation + rel->r_addend;
+
+      if (use_stubs
+          && avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
+        {
+          bfd_vma old_srel = srel;
+
+          /* We need to use the address of the stub instead.  */
+          srel = avr_get_stub_addr (srel,htab);
+          if (debug_stubs)
+            printf ("LD: Using jump stub (at 0x%x) with destination 0x%x for "
+                    "reloc at address 0x%x.\n",
+                    (unsigned int) srel,
+                    (unsigned int) old_srel,
+                    (unsigned int) reloc_addr);
+
+	  if (avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
+	    return bfd_reloc_outofrange;
+        }
+
+      if (srel & 1)
+	return bfd_reloc_outofrange;
+      srel = srel >> 1;
+      bfd_put_16 (input_bfd, (bfd_vma) srel &0x00ffff, contents);
+      break;
+
     default:
       r = _bfd_final_link_relocate (howto, input_bfd, input_section,
 				    contents, rel->r_offset,
@@ -858,6 +1180,7 @@
   struct elf_link_hash_entry ** sym_hashes;
   Elf_Internal_Rela *           rel;
   Elf_Internal_Rela *           relend;
+  struct elf32_avr_link_hash_table * htab = avr_link_hash_table (info);
 
   if (info->relocatable)
     return TRUE;
@@ -909,7 +1232,7 @@
 	}
 
       r = avr_final_link_relocate (howto, input_bfd, input_section,
-				   contents, rel, relocation);
+				   contents, rel, relocation, htab);
 
       if (r != bfd_reloc_ok)
 	{
@@ -990,6 +1313,10 @@
     case bfd_mach_avr5:
       val = E_AVR_MACH_AVR5;
       break;
+
+    case bfd_mach_avr6:
+      val = E_AVR_MACH_AVR6;
+      break;
     }
 
   elf_elfheader (abfd)->e_machine = EM_AVR;
@@ -1032,6 +1359,10 @@
 	case E_AVR_MACH_AVR5:
 	  e_set = bfd_mach_avr5;
 	  break;
+
+	case E_AVR_MACH_AVR6:
+	  e_set = bfd_mach_avr6;
+	  break;
 	}
     }
   return bfd_default_set_arch_mach (abfd, bfd_arch_avr,
@@ -1039,9 +1370,6 @@
 }
 
 
-/* Enable debugging printout at stdout with a value of 1.  */
-#define DEBUG_RELAX 0
-
 /* Delete some bytes from a section while changing the size of an instruction.
    The parameter "addr" denotes the section-relative offset pointing just
    behind the shrinked instruction. "addr+count" point at the first
@@ -1101,7 +1429,7 @@
       if ((irel->r_offset > addr
            && irel->r_offset < toaddr))
         {
-          if (DEBUG_RELAX)
+          if (debug_relax)
             printf ("Relocation at address 0x%x needs to be moved.\n"
                     "Old section offset: 0x%x, New section offset: 0x%x \n",
                     (unsigned int) old_reloc_address,
@@ -1148,7 +1476,7 @@
                symval += sym_sec->output_section->vma
                          + sym_sec->output_offset;
 
-               if (DEBUG_RELAX)
+               if (debug_relax)
                 printf ("Checking if the relocation's "
                         "addend needs corrections.\n"
                         "Address of anchor symbol: 0x%x \n"
@@ -1163,7 +1491,7 @@
                  {
                    irel->r_addend -= count;
 
-                   if (DEBUG_RELAX)
+                   if (debug_relax)
                      printf ("Anchor symbol and relocation target bracket "
                              "shrinked insn address.\n"
                              "Need for new addend : 0x%x\n",
@@ -1238,7 +1566,7 @@
    contains 4-byte jump instructions whose relative offset must not
    be changed.  */
 
-static  bfd_boolean
+static bfd_boolean
 elf32_avr_relax_section (bfd *abfd,
 			 asection *sec,
                          struct bfd_link_info *link_info,
@@ -1251,10 +1579,37 @@
   Elf_Internal_Sym *isymbuf = NULL;
   static asection *last_input_section = NULL;
   static Elf_Internal_Rela *last_reloc = NULL;
+  struct elf32_avr_link_hash_table *htab;
+
+  htab = avr_link_hash_table (link_info);
 
   /* Assume nothing changes.  */
   *again = FALSE;
 
+  if ((!htab->no_stubs) && (sec == htab->stub_sec))
+    {
+      /* We are just relaxing the stub section.
+	 Let's calculate the size needed again.  */
+      bfd_size_type last_estimated_stub_section_size = htab->stub_sec->size;
+
+      if (debug_relax)
+        printf ("Relaxing the stub section. Size prior to this pass: %i\n",
+                (int) last_estimated_stub_section_size);
+
+      elf32_avr_size_stubs (htab->stub_sec->output_section->owner,
+                            link_info, FALSE);
+
+      /* Check if the number of trampolines changed.  */
+      if (last_estimated_stub_section_size != htab->stub_sec->size)
+        *again = TRUE;
+
+      if (debug_relax)
+        printf ("Size of stub section after this pass: %i\n",
+                (int) htab->stub_sec->size);
+
+      return TRUE;
+    }
+
   /* We don't have to do anything for a relocatable link, if
      this section does not have relocs, or if this is not a
      code section.  */
@@ -1421,7 +1776,7 @@
                 unsigned char code_msb;
                 unsigned char code_lsb;
 
-                if (DEBUG_RELAX)
+                if (debug_relax)
                   printf ("shrinking jump/call instruction at address 0x%x"
                           " in section %s\n\n",
                           (int) dot, sec->name);
@@ -1496,8 +1851,9 @@
                    + sec->output_offset + irel->r_offset);
 
             /* Here we look for rcall/ret or call/ret sequences that could be
-               safely replaced by rjmp/ret or jmp/ret */
-            if (0xd0 == (code_msb & 0xf0))
+               safely replaced by rjmp/ret or jmp/ret.  */
+            if (((code_msb & 0xf0) == 0xd0)
+                && avr_replace_call_ret_sequences)
               {
                 /* This insn is a rcall.  */
                 unsigned char next_insn_msb = 0;
@@ -1517,7 +1873,7 @@
                        into a rjmp instruction.  */
                     code_msb &= 0xef;
                     bfd_put_8 (abfd, code_msb, contents + irel->r_offset + 1);
-                    if (DEBUG_RELAX)
+                    if (debug_relax)
                       printf ("converted rcall/ret sequence at address 0x%x"
                               " into rjmp/ret sequence. Section is %s\n\n",
                               (int) dot, sec->name);
@@ -1526,7 +1882,8 @@
                   }
               }
             else if ((0x94 == (code_msb & 0xfe))
-                      && (0x0e == (code_lsb & 0x0e)))
+		     && (0x0e == (code_lsb & 0x0e))
+		     && avr_replace_call_ret_sequences)
               {
                 /* This insn is a call.  */
                 unsigned char next_insn_msb = 0;
@@ -1547,7 +1904,7 @@
 
                     code_lsb &= 0xfd;
                     bfd_put_8 (abfd, code_lsb, contents + irel->r_offset);
-                    if (DEBUG_RELAX)
+                    if (debug_relax)
                       printf ("converted call/ret sequence at address 0x%x"
                               " into jmp/ret sequence. Section is %s\n\n",
                               (int) dot, sec->name);
@@ -1590,10 +1947,10 @@
 
                     address_of_ret = dot + insn_size;
 
-                    if (DEBUG_RELAX && (insn_size == 2))
+                    if (debug_relax && (insn_size == 2))
                       printf ("found rjmp / ret sequence at address 0x%x\n",
                               (int) dot);
-                    if (DEBUG_RELAX && (insn_size == 4))
+                    if (debug_relax && (insn_size == 4))
                       printf ("found jmp / ret sequence at address 0x%x\n",
                               (int) dot);
 
@@ -1630,7 +1987,7 @@
                           there_is_preceeding_non_skip_insn = 0;
 
                         if (there_is_preceeding_non_skip_insn == 0)
-                          if (DEBUG_RELAX)
+                          if (debug_relax)
                             printf ("preceeding skip insn prevents deletion of"
                                     " ret insn at addr 0x%x in section %s\n",
                                     (int) dot + 2, sec->name);
@@ -1666,7 +2023,7 @@
                                && isym->st_shndx == sec_shndx)
                              {
                                deleting_ret_is_safe = 0;
-                               if (DEBUG_RELAX)
+                               if (debug_relax)
                                  printf ("local label prevents deletion of ret "
                                          "insn at address 0x%x\n",
                                          (int) dot + insn_size);
@@ -1695,7 +2052,7 @@
                                   && sym_hash->root.u.def.value == section_offset_of_ret_insn)
                                 {
                                   deleting_ret_is_safe = 0;
-                                  if (DEBUG_RELAX)
+                                  if (debug_relax)
                                     printf ("global label prevents deletion of "
                                             "ret insn at address 0x%x\n",
                                             (int) dot + insn_size);
@@ -1772,7 +2129,7 @@
                                if (address_of_ret == reloc_target)
                                  {
                                    deleting_ret_is_safe = 0;
-                                   if (DEBUG_RELAX)
+                                   if (debug_relax)
                                      printf ("ret from "
                                              "rjmp/jmp ret sequence at address"
                                              " 0x%x could not be deleted. ret"
@@ -1784,7 +2141,7 @@
 
                          if (deleting_ret_is_safe)
                            {
-                             if (DEBUG_RELAX)
+                             if (debug_relax)
                                printf ("unreachable ret instruction "
                                        "at address 0x%x deleted.\n",
                                        (int) dot + insn_size);
@@ -1952,6 +2309,614 @@
 }
 
 
+/* Determines the hash entry name for a particular reloc. It consists of
+   the identifier of the symbol section and the added reloc addend and
+   symbol offset relative to the section the symbol is attached to.  */
+
+static char *
+avr_stub_name (const asection *symbol_section,
+               const bfd_vma symbol_offset,
+               const Elf_Internal_Rela *rela)
+{
+  char *stub_name;
+  bfd_size_type len;
+
+  len = 8 + 1 + 8 + 1 + 1;
+  stub_name = bfd_malloc (len);
+
+  sprintf (stub_name, "%08x+%08x",
+           symbol_section->id & 0xffffffff,
+           (unsigned int) ((rela->r_addend & 0xffffffff) + symbol_offset));
+
+  return stub_name;
+}
+
+
+/* Add a new stub entry to the stub hash.  Not all fields of the new
+   stub entry are initialised.  */
+
+static struct elf32_avr_stub_hash_entry *
+avr_add_stub (const char *stub_name,
+              struct elf32_avr_link_hash_table *htab)
+{
+  struct elf32_avr_stub_hash_entry *hsh;
+
+  /* Enter this entry into the linker stub hash table.  */
+  hsh = avr_stub_hash_lookup (&htab->bstab, stub_name, TRUE, FALSE);
+
+  if (hsh == NULL)
+    {
+      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
+                             NULL, stub_name);
+      return NULL;
+    }
+
+  hsh->stub_offset = 0;
+  return hsh;
+}
+
+/* We assume that there is already space allocated for the stub section
+   contents and that before building the stubs the section size is
+   initialized to 0.  We assume that within the stub hash table entry,
+   the absolute position of the jmp target has been written in the
+   target_value field.  We write here the offset of the generated jmp insn
+   relative to the trampoline section start to the stub_offset entry in
+   the stub hash table entry.  */
+
+static  bfd_boolean
+avr_build_one_stub (struct bfd_hash_entry *bh, void *in_arg)
+{
+  struct elf32_avr_stub_hash_entry *hsh;
+  struct bfd_link_info *info;
+  struct elf32_avr_link_hash_table *htab;
+  bfd *stub_bfd;
+  bfd_byte *loc;
+  bfd_vma target;
+  bfd_vma starget;
+
+  /* Basic opcode */
+  bfd_vma jmp_insn = 0x0000940c;
+
+  /* Massage our args to the form they really have.  */
+  hsh = avr_stub_hash_entry (bh);
+
+  if (!hsh->is_actually_needed)
+    return TRUE;
+
+  info = (struct bfd_link_info *) in_arg;
+
+  htab = avr_link_hash_table (info);
+
+  target = hsh->target_value;
+
+  /* Make a note of the offset within the stubs for this entry.  */
+  hsh->stub_offset = htab->stub_sec->size;
+  loc = htab->stub_sec->contents + hsh->stub_offset;
+
+  stub_bfd = htab->stub_sec->owner;
+
+  if (debug_stubs)
+    printf ("Building one Stub. Address: 0x%x, Offset: 0x%x\n",
+             (unsigned int) target,
+             (unsigned int) hsh->stub_offset);
+
+  /* We now have to add the information on the jump target to the bare
+     opcode bits already set in jmp_insn.  */
+
+  /* Check for the alignment of the address.  */
+  if (target & 1)
+     return FALSE;
+
+  starget = target >> 1;
+  jmp_insn |= ((starget & 0x10000) | ((starget << 3) & 0x1f00000)) >> 16;
+  bfd_put_16 (stub_bfd, jmp_insn, loc);
+  bfd_put_16 (stub_bfd, (bfd_vma) starget & 0xffff, loc + 2);
+
+  htab->stub_sec->size += 4;
+
+  /* Now add the entries in the address mapping table if there is still
+     space left.  */
+  {
+    unsigned int nr;
+
+    nr = htab->amt_entry_cnt + 1;
+    if (nr <= htab->amt_max_entry_cnt)
+      {
+        htab->amt_entry_cnt = nr;
+
+        htab->amt_stub_offsets[nr - 1] = hsh->stub_offset;
+        htab->amt_destination_addr[nr - 1] = target;
+      }
+  }
+
+  return TRUE;
+}
+
+static bfd_boolean
+avr_mark_stub_not_to_be_necessary (struct bfd_hash_entry *bh,
+                                   void *in_arg)
+{
+  struct elf32_avr_stub_hash_entry *hsh;
+  struct elf32_avr_link_hash_table *htab;
+
+  htab = in_arg;
+  hsh = avr_stub_hash_entry (bh);
+  hsh->is_actually_needed = FALSE;
+
+  return TRUE;
+}
+
+static bfd_boolean
+avr_size_one_stub (struct bfd_hash_entry *bh, void *in_arg)
+{
+  struct elf32_avr_stub_hash_entry *hsh;
+  struct elf32_avr_link_hash_table *htab;
+  int size;
+
+  /* Massage our args to the form they really have.  */
+  hsh = avr_stub_hash_entry (bh);
+  htab = in_arg;
+
+  if (hsh->is_actually_needed)
+    size = 4;
+  else
+    size = 0;
+
+  htab->stub_sec->size += size;
+  return TRUE;
+}
+
+void
+elf32_avr_setup_params (struct bfd_link_info *info,
+                        bfd *avr_stub_bfd,
+                        asection *avr_stub_section,
+                        bfd_boolean no_stubs,
+                        bfd_boolean deb_stubs,
+                        bfd_boolean deb_relax,
+                        bfd_vma pc_wrap_around,
+                        bfd_boolean call_ret_replacement)
+{
+  struct elf32_avr_link_hash_table *htab = avr_link_hash_table(info);
+
+  htab->stub_sec = avr_stub_section;
+  htab->stub_bfd = avr_stub_bfd;
+  htab->no_stubs = no_stubs;
+
+  debug_relax = deb_relax;
+  debug_stubs = deb_stubs;
+  avr_pc_wrap_around = pc_wrap_around;
+  avr_replace_call_ret_sequences = call_ret_replacement;
+}
+
+
+/* Set up various things so that we can make a list of input sections
+   for each output section included in the link.  Returns -1 on error,
+   0 when no stubs will be needed, and 1 on success.  It also sets
+   information on the stubs bfd and the stub section in the info
+   struct.  */
+
+int
+elf32_avr_setup_section_lists (bfd *output_bfd,
+                               struct bfd_link_info *info)
+{
+  bfd *input_bfd;
+  unsigned int bfd_count;
+  int top_id, top_index;
+  asection *section;
+  asection **input_list, **list;
+  bfd_size_type amt;
+  struct elf32_avr_link_hash_table *htab = avr_link_hash_table(info);
+
+  if (htab->no_stubs)
+    return 0;
+
+  /* Count the number of input BFDs and find the top input section id.  */
+  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next)
+    {
+      bfd_count += 1;
+      for (section = input_bfd->sections;
+           section != NULL;
+           section = section->next)
+	if (top_id < section->id)
+	  top_id = section->id;
+    }
+
+  htab->bfd_count = bfd_count;
+
+  /* We can't use output_bfd->section_count here to find the top output
+     section index as some sections may have been removed, and
+     strip_excluded_output_sections doesn't renumber the indices.  */
+  for (section = output_bfd->sections, top_index = 0;
+       section != NULL;
+       section = section->next)
+    if (top_index < section->index)
+      top_index = section->index;
+
+  htab->top_index = top_index;
+  amt = sizeof (asection *) * (top_index + 1);
+  input_list = bfd_malloc (amt);
+  htab->input_list = input_list;
+  if (input_list == NULL)
+    return -1;
+
+  /* For sections we aren't interested in, mark their entries with a
+     value we can check later.  */
+  list = input_list + top_index;
+  do
+    *list = bfd_abs_section_ptr;
+  while (list-- != input_list);
+
+  for (section = output_bfd->sections;
+       section != NULL;
+       section = section->next)
+    if ((section->flags & SEC_CODE) != 0)
+      input_list[section->index] = NULL;
+
+  return 1;
+}
+
+
+/* Read in all local syms for all input bfds, and create hash entries
+   for export stubs if we are building a multi-subspace shared lib.
+   Returns -1 on error, 0 otherwise.  */
+
+static int
+get_local_syms (bfd *input_bfd, struct bfd_link_info *info)
+{
+  unsigned int bfd_indx;
+  Elf_Internal_Sym *local_syms, **all_local_syms;
+  struct elf32_avr_link_hash_table *htab = avr_link_hash_table (info);
+
+  /* We want to read in symbol extension records only once.  To do this
+     we need to read in the local symbols in parallel and save them for
+     later use; so hold pointers to the local symbols in an array.  */
+  bfd_size_type amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
+  all_local_syms = bfd_zmalloc (amt);
+  htab->all_local_syms = all_local_syms;
+  if (all_local_syms == NULL)
+    return -1;
+
+  /* Walk over all the input BFDs, swapping in local symbols.
+     If we are creating a shared library, create hash entries for the
+     export stubs.  */
+  for (bfd_indx = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next, bfd_indx++)
+    {
+      Elf_Internal_Shdr *symtab_hdr;
+
+      /* We'll need the symbol table in a second.  */
+      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+      if (symtab_hdr->sh_info == 0)
+	continue;
+
+      /* We need an array of the local symbols attached to the input bfd.  */
+      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
+      if (local_syms == NULL)
+	{
+	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
+					     symtab_hdr->sh_info, 0,
+					     NULL, NULL, NULL);
+	  /* Cache them for elf_link_input_bfd.  */
+	  symtab_hdr->contents = (unsigned char *) local_syms;
+	}
+      if (local_syms == NULL)
+	return -1;
+
+      all_local_syms[bfd_indx] = local_syms;
+    }
+
+  return 0;
+}
+
+#define ADD_DUMMY_STUBS_FOR_DEBUGGING 0
+
+bfd_boolean
+elf32_avr_size_stubs (bfd *output_bfd,
+                      struct bfd_link_info *info,
+                      bfd_boolean is_prealloc_run)
+{
+ struct elf32_avr_link_hash_table *htab;
+ int stub_changed = 0;
+
+ htab = avr_link_hash_table (info);
+
+ /* At this point we initialize htab->vector_base
+    To the start of the text output section.  */
+ htab->vector_base = htab->stub_sec->output_section->vma;
+
+ if (get_local_syms (info->input_bfds, info))
+   {
+     if (htab->all_local_syms)
+       goto error_ret_free_local;
+     return FALSE;
+   }
+
+  if (ADD_DUMMY_STUBS_FOR_DEBUGGING)
+    {
+      struct elf32_avr_stub_hash_entry *test;
+
+      test = avr_add_stub ("Hugo",htab);
+      test->target_value = 0x123456;
+      test->stub_offset = 13;
+
+      test = avr_add_stub ("Hugo2",htab);
+      test->target_value = 0x84210;
+      test->stub_offset = 14;
+    }
+
+  while (1)
+    {
+      bfd *input_bfd;
+      unsigned int bfd_indx;
+
+      /* We will have to re-generate the stub hash table each time anything
+         in memory has changed.  */
+
+      bfd_hash_traverse (&htab->bstab, avr_mark_stub_not_to_be_necessary, htab);
+      for (input_bfd = info->input_bfds, bfd_indx = 0;
+           input_bfd != NULL;
+           input_bfd = input_bfd->link_next, bfd_indx++)
+        {
+          Elf_Internal_Shdr *symtab_hdr;
+          asection *section;
+          Elf_Internal_Sym *local_syms;
+
+          /* We'll need the symbol table in a second.  */
+          symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+          if (symtab_hdr->sh_info == 0)
+            continue;
+
+          local_syms = htab->all_local_syms[bfd_indx];
+
+          /* Walk over each section attached to the input bfd.  */
+          for (section = input_bfd->sections;
+               section != NULL;
+               section = section->next)
+            {
+              Elf_Internal_Rela *internal_relocs, *irelaend, *irela;
+
+              /* If there aren't any relocs, then there's nothing more
+                 to do.  */
+              if ((section->flags & SEC_RELOC) == 0
+                  || section->reloc_count == 0)
+                continue;
+
+              /* If this section is a link-once section that will be
+                 discarded, then don't create any stubs.  */
+              if (section->output_section == NULL
+                  || section->output_section->owner != output_bfd)
+                continue;
+
+              /* Get the relocs.  */
+              internal_relocs
+                = _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
+                                             info->keep_memory);
+              if (internal_relocs == NULL)
+                goto error_ret_free_local;
+
+              /* Now examine each relocation.  */
+              irela = internal_relocs;
+              irelaend = irela + section->reloc_count;
+              for (; irela < irelaend; irela++)
+                {
+                  unsigned int r_type, r_indx;
+                  struct elf32_avr_stub_hash_entry *hsh;
+                  asection *sym_sec;
+                  bfd_vma sym_value;
+                  bfd_vma destination;
+                  struct elf_link_hash_entry *hh;
+                  char *stub_name;
+
+                  r_type = ELF32_R_TYPE (irela->r_info);
+                  r_indx = ELF32_R_SYM (irela->r_info);
+
+                  /* Only look for 16 bit GS relocs. No other reloc will need a
+                     stub.  */
+                  if (!((r_type == R_AVR_16_PM)
+                        || (r_type == R_AVR_LO8_LDI_GS)
+                        || (r_type == R_AVR_HI8_LDI_GS)))
+                    continue;
+
+                  /* Now determine the call target, its name, value,
+                     section.  */
+                  sym_sec = NULL;
+                  sym_value = 0;
+                  destination = 0;
+                  hh = NULL;
+                  if (r_indx < symtab_hdr->sh_info)
+                    {
+                      /* It's a local symbol.  */
+                      Elf_Internal_Sym *sym;
+                      Elf_Internal_Shdr *hdr;
+
+                      sym = local_syms + r_indx;
+                      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
+                      sym_sec = hdr->bfd_section;
+                      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
+                        sym_value = sym->st_value;
+                      destination = (sym_value + irela->r_addend
+                                     + sym_sec->output_offset
+                                     + sym_sec->output_section->vma);
+                    }
+                  else
+                    {
+                      /* It's an external symbol.  */
+                      int e_indx;
+
+                      e_indx = r_indx - symtab_hdr->sh_info;
+                      hh = elf_sym_hashes (input_bfd)[e_indx];
+
+                      while (hh->root.type == bfd_link_hash_indirect
+                             || hh->root.type == bfd_link_hash_warning)
+                        hh = (struct elf_link_hash_entry *)
+                              (hh->root.u.i.link);
+
+                      if (hh->root.type == bfd_link_hash_defined
+                          || hh->root.type == bfd_link_hash_defweak)
+                        {
+                          sym_sec = hh->root.u.def.section;
+                          sym_value = hh->root.u.def.value;
+                          if (sym_sec->output_section != NULL)
+                          destination = (sym_value + irela->r_addend
+                                         + sym_sec->output_offset
+                                         + sym_sec->output_section->vma);
+                        }
+                      else if (hh->root.type == bfd_link_hash_undefweak)
+                        {
+                          if (! info->shared)
+                            continue;
+                        }
+                      else if (hh->root.type == bfd_link_hash_undefined)
+                        {
+                          if (! (info->unresolved_syms_in_objects == RM_IGNORE
+                                 && (ELF_ST_VISIBILITY (hh->other)
+                                     == STV_DEFAULT)))
+                             continue;
+                        }
+                      else
+                        {
+                          bfd_set_error (bfd_error_bad_value);
+
+                          error_ret_free_internal:
+                          if (elf_section_data (section)->relocs == NULL)
+                            free (internal_relocs);
+                          goto error_ret_free_local;
+                        }
+                    }
+
+                  if (! avr_stub_is_required_for_16_bit_reloc
+		      (destination - htab->vector_base))
+                    {
+                      if (!is_prealloc_run)
+			/* We are having a reloc that does't need a stub.  */
+			continue;
+
+		      /* We don't right now know if a stub will be needed.
+			 Let's rather be on the safe side.  */
+                    }
+
+                  /* Get the name of this stub.  */
+                  stub_name = avr_stub_name (sym_sec, sym_value, irela);
+
+                  if (!stub_name)
+                    goto error_ret_free_internal;
+
+
+                  hsh = avr_stub_hash_lookup (&htab->bstab,
+                                              stub_name,
+                                              FALSE, FALSE);
+                  if (hsh != NULL)
+                    {
+                      /* The proper stub has already been created.  Mark it
+                         to be used and write the possibly changed destination
+                         value.  */
+                      hsh->is_actually_needed = TRUE;
+                      hsh->target_value = destination;
+                      free (stub_name);
+                      continue;
+                    }
+
+                  hsh = avr_add_stub (stub_name, htab);
+                  if (hsh == NULL)
+                    {
+                      free (stub_name);
+                      goto error_ret_free_internal;
+                    }
+
+                  hsh->is_actually_needed = TRUE;
+                  hsh->target_value = destination;
+
+                  if (debug_stubs)
+                    printf ("Adding stub with destination 0x%x to the"
+                            " hash table.\n", (unsigned int) destination);
+                  if (debug_stubs)
+                    printf ("(Pre-Alloc run: %i)\n", is_prealloc_run);
+
+                  stub_changed = TRUE;
+                }
+
+              /* We're done with the internal relocs, free them.  */
+              if (elf_section_data (section)->relocs == NULL)
+                free (internal_relocs);
+            }
+        }
+
+      /* Re-Calculate the number of needed stubs.  */
+      htab->stub_sec->size = 0;
+      bfd_hash_traverse (&htab->bstab, avr_size_one_stub, htab);
+
+      if (!stub_changed)
+        break;
+
+      stub_changed = FALSE;
+    }
+
+  free (htab->all_local_syms);
+  return TRUE;
+
+ error_ret_free_local:
+  free (htab->all_local_syms);
+  return FALSE;
+}
+
+
+/* Build all the stubs associated with the current output file.  The
+   stubs are kept in a hash table attached to the main linker hash
+   table.  We also set up the .plt entries for statically linked PIC
+   functions here.  This function is called via hppaelf_finish in the
+   linker.  */
+
+bfd_boolean
+elf32_avr_build_stubs (struct bfd_link_info *info)
+{
+  asection *stub_sec;
+  struct bfd_hash_table *table;
+  struct elf32_avr_link_hash_table *htab;
+  bfd_size_type total_size = 0;
+
+  htab = avr_link_hash_table (info);
+
+  /* In case that there were several stub sections:  */
+  for (stub_sec = htab->stub_bfd->sections;
+       stub_sec != NULL;
+       stub_sec = stub_sec->next)
+    {
+      bfd_size_type size;
+
+      /* Allocate memory to hold the linker stubs.  */
+      size = stub_sec->size;
+      total_size += size;
+
+      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
+      if (stub_sec->contents == NULL && size != 0)
+	return FALSE;
+      stub_sec->size = 0;
+    }
+
+  /* Allocate memory for the adress mapping table.  */
+  htab->amt_entry_cnt = 0;
+  htab->amt_max_entry_cnt = total_size / 4;
+  htab->amt_stub_offsets = bfd_malloc (sizeof (bfd_vma)
+                                       * htab->amt_max_entry_cnt);
+  htab->amt_destination_addr = bfd_malloc (sizeof (bfd_vma)
+					   * htab->amt_max_entry_cnt );
+
+  if (debug_stubs)
+    printf ("Allocating %i entries in the AMT\n", htab->amt_max_entry_cnt);
+
+  /* Build the stubs as directed by the stub hash table.  */
+  table = &htab->bstab;
+  bfd_hash_traverse (table, avr_build_one_stub, info);
+
+  if (debug_stubs)
+    printf ("Final Stub section Size: %i\n", (int) htab->stub_sec->size);
+
+  return TRUE;
+}
+
 #define ELF_ARCH		bfd_arch_avr
 #define ELF_MACHINE_CODE	EM_AVR
 #define ELF_MACHINE_ALT1	EM_AVR_OLD
@@ -1960,6 +2925,9 @@
 #define TARGET_LITTLE_SYM       bfd_elf32_avr_vec
 #define TARGET_LITTLE_NAME	"elf32-avr"
 
+#define bfd_elf32_bfd_link_hash_table_create elf32_avr_link_hash_table_create
+#define bfd_elf32_bfd_link_hash_table_free   elf32_avr_link_hash_table_free
+
 #define elf_info_to_howto	             avr_info_to_howto_rela
 #define elf_info_to_howto_rel	             NULL
 #define elf_backend_relocate_section         elf32_avr_relocate_section
diff -Nur bfd/elf32-avr.h bfd/elf32-avr.h
--- bfd/elf32-avr.h	1970-01-01 01:00:00.000000000 +0100
+++ bfd/elf32-avr.h	2006-08-28 20:01:10.805090951 +0200
@@ -0,0 +1,38 @@
+/* AVR-specific support for 32-bit ELF.
+   Copyright 2006 Free Software Foundation, Inc.
+
+   Written by Bjoern Haase <bjoern.m.haase@web.de>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, 
+   Boston, MA 02110-1301, USA.  */
+
+
+/* These four functions will be called from the ld back-end.  */
+
+extern void
+elf32_avr_setup_params (struct bfd_link_info *, bfd *, asection *,
+                        bfd_boolean, bfd_boolean, bfd_boolean,
+                        bfd_vma, bfd_boolean);
+
+extern int
+elf32_avr_setup_section_lists (bfd *, struct bfd_link_info *);
+
+extern bfd_boolean
+elf32_avr_size_stubs (bfd *, struct bfd_link_info *, bfd_boolean);
+
+extern bfd_boolean
+elf32_avr_build_stubs (struct bfd_link_info *);
diff -Nur bfd/libbfd.h bfd/libbfd.h
--- bfd/libbfd.h	2006-03-26 01:38:42.000000000 +0100
+++ bfd/libbfd.h	2006-08-28 20:02:16.912297073 +0200
@@ -1509,7 +1509,9 @@
   "BFD_RELOC_AVR_HH8_LDI_NEG",
   "BFD_RELOC_AVR_MS8_LDI_NEG",
   "BFD_RELOC_AVR_LO8_LDI_PM",
+  "BFD_RELOC_AVR_LO8_LDI_GS",
   "BFD_RELOC_AVR_HI8_LDI_PM",
+  "BFD_RELOC_AVR_HI8_LDI_GS",
   "BFD_RELOC_AVR_HH8_LDI_PM",
   "BFD_RELOC_AVR_LO8_LDI_PM_NEG",
   "BFD_RELOC_AVR_HI8_LDI_PM_NEG",
diff -Nur bfd/reloc.c bfd/reloc.c
--- bfd/reloc.c	2006-03-26 01:38:42.000000000 +0100
+++ bfd/reloc.c	2006-08-28 20:02:16.936295332 +0200
@@ -3666,11 +3666,25 @@
   This is a 16 bit reloc for the AVR that stores 8 bit value (usually
   command address) into 8 bit immediate value of LDI insn.
 ENUM
+  BFD_RELOC_AVR_LO8_LDI_GS
+ENUMDOC
+  This is a 16 bit reloc for the AVR that stores 8 bit value 
+  (command address) into 8 bit immediate value of LDI insn. If the address
+  is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+  in the lower 128k.
+ENUM
   BFD_RELOC_AVR_HI8_LDI_PM
 ENUMDOC
   This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
   of command address) into 8 bit immediate value of LDI insn.
 ENUM
+  BFD_RELOC_AVR_HI8_LDI_GS
+ENUMDOC
+  This is a 16 bit reloc for the AVR that stores 8 bit value (high 8 bit
+  of command address) into 8 bit immediate value of LDI insn.  If the address
+  is beyond the 128k boundary, the linker inserts a jump stub for this reloc
+  below 128k.
+ENUM
   BFD_RELOC_AVR_HH8_LDI_PM
 ENUMDOC
   This is a 16 bit reloc for the AVR that stores 8 bit value (most high 8 bit
diff -Nur gas/config/tc-avr.c gas/config/tc-avr.c
--- gas/config/tc-avr.c	2006-04-07 17:18:08.000000000 +0200
+++ gas/config/tc-avr.c	2006-08-28 20:02:16.948294462 +0200
@@ -63,89 +63,92 @@
 
 static struct mcu_type_s mcu_types[] =
 {
-  {"avr1",      AVR_ISA_TINY1,    bfd_mach_avr1},
-  {"avr2",      AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"avr3",      AVR_ISA_M103,     bfd_mach_avr3},
-  {"avr4",      AVR_ISA_M8,       bfd_mach_avr4},
-  {"avr5",      AVR_ISA_ALL,      bfd_mach_avr5},
-  {"at90s1200", AVR_ISA_1200,     bfd_mach_avr1},
-  {"attiny10",  AVR_ISA_TINY1,    bfd_mach_avr1}, /* XXX -> tn11 */
-  {"attiny11",  AVR_ISA_TINY1,    bfd_mach_avr1},
-  {"attiny12",  AVR_ISA_TINY1,    bfd_mach_avr1},
-  {"attiny15",  AVR_ISA_TINY1,    bfd_mach_avr1},
-  {"attiny28",  AVR_ISA_TINY1,    bfd_mach_avr1},
-  {"at90s2313", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at90s2323", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at90s2333", AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 4433 */
-  {"at90s2343", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"attiny22",  AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 2343 */
-  {"attiny26",  AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at90s4433", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at90s4414", AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 8515 */
-  {"at90s4434", AVR_ISA_2xxx,     bfd_mach_avr2}, /* XXX -> 8535 */
-  {"at90s8515", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at90s8535", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at90c8534", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"at86rf401", AVR_ISA_2xxx,     bfd_mach_avr2},
-  {"attiny13",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny2313",AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny261", AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny461", AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny861", AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny24",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny44",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny84",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny25",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny45",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"attiny85",  AVR_ISA_TINY2,    bfd_mach_avr2},
-  {"atmega603", AVR_ISA_M603,     bfd_mach_avr3}, /* XXX -> m103 */
-  {"atmega103", AVR_ISA_M103,     bfd_mach_avr3},
-  {"at43usb320",AVR_ISA_M103,     bfd_mach_avr3},
-  {"at43usb355",AVR_ISA_M603,     bfd_mach_avr3},
-  {"at76c711",  AVR_ISA_M603,     bfd_mach_avr3},
-  {"atmega48",  AVR_ISA_PWMx,     bfd_mach_avr4},
-  {"atmega8",   AVR_ISA_M8,       bfd_mach_avr4},
-  {"atmega83",  AVR_ISA_M8,       bfd_mach_avr4}, /* XXX -> m8535 */
-  {"atmega85",  AVR_ISA_M8,       bfd_mach_avr4}, /* XXX -> m8 */
-  {"atmega88",  AVR_ISA_PWMx,     bfd_mach_avr4},
-  {"atmega8515",AVR_ISA_M8,       bfd_mach_avr4},
-  {"atmega8535",AVR_ISA_M8,       bfd_mach_avr4},
-  {"at90pwm2",  AVR_ISA_PWMx,     bfd_mach_avr4},
-  {"at90pwm3",  AVR_ISA_PWMx,     bfd_mach_avr4},
-  {"atmega16",  AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega161", AVR_ISA_M161,     bfd_mach_avr5},
-  {"atmega162", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega163", AVR_ISA_M161,     bfd_mach_avr5},
-  {"atmega164", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega165", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega168", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega169", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega32",  AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega323", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega324", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega325", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega329", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega3250",AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega3290",AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega406", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega64",  AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega640", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega644", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega128", AVR_ISA_M128,     bfd_mach_avr5},
-  {"atmega1280",AVR_ISA_M128,     bfd_mach_avr5},
-  {"atmega1281",AVR_ISA_M128,     bfd_mach_avr5},
-  {"atmega645", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega649", AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega6450",AVR_ISA_M323,     bfd_mach_avr5},
-  {"atmega6490",AVR_ISA_M323,     bfd_mach_avr5},
-  {"at90can32" ,AVR_ISA_M323,     bfd_mach_avr5},
-  {"at90can64" ,AVR_ISA_M323,     bfd_mach_avr5},
-  {"at90can128",AVR_ISA_M128,     bfd_mach_avr5},
+  {"avr1",       AVR_ISA_TINY1,   bfd_mach_avr1},
+  {"avr2",       AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"avr3",       AVR_ISA_M103,    bfd_mach_avr3},
+  {"avr4",       AVR_ISA_M8,      bfd_mach_avr4},
+  {"avr5",       AVR_ISA_ALL,     bfd_mach_avr5},
+  {"avr6",       AVR_ISA_ALL,     bfd_mach_avr6},
+  {"at90s1200",  AVR_ISA_1200,    bfd_mach_avr1},
+  {"attiny10",   AVR_ISA_TINY1,   bfd_mach_avr1}, /* XXX -> tn11 */
+  {"attiny11",   AVR_ISA_TINY1,   bfd_mach_avr1},
+  {"attiny12",   AVR_ISA_TINY1,   bfd_mach_avr1},
+  {"attiny15",   AVR_ISA_TINY1,   bfd_mach_avr1},
+  {"attiny28",   AVR_ISA_TINY1,   bfd_mach_avr1},
+  {"at90s2313",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at90s2323",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at90s2333",  AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 4433 */
+  {"at90s2343",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"attiny22",   AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 2343 */
+  {"attiny26",   AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at90s4433",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at90s4414",  AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 8515 */
+  {"at90s4434",  AVR_ISA_2xxx,    bfd_mach_avr2}, /* XXX -> 8535 */
+  {"at90s8515",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at90s8535",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at90c8534",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"at86rf401",  AVR_ISA_2xxx,    bfd_mach_avr2},
+  {"attiny13",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny2313", AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny261",  AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny461",  AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny861",  AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny24",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny44",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny84",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny25",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny45",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"attiny85",   AVR_ISA_TINY2,   bfd_mach_avr2},
+  {"atmega603",  AVR_ISA_M603,    bfd_mach_avr3}, /* XXX -> m103 */
+  {"atmega103",  AVR_ISA_M103,    bfd_mach_avr3},
+  {"at43usb320", AVR_ISA_M103,    bfd_mach_avr3},
+  {"at43usb355", AVR_ISA_M603,    bfd_mach_avr3},
+  {"at76c711",   AVR_ISA_M603,    bfd_mach_avr3},
+  {"atmega48",   AVR_ISA_PWMx,    bfd_mach_avr4},
+  {"atmega8",    AVR_ISA_M8,      bfd_mach_avr4},
+  {"atmega83",   AVR_ISA_M8,      bfd_mach_avr4}, /* XXX -> m8535 */
+  {"atmega85",   AVR_ISA_M8,      bfd_mach_avr4}, /* XXX -> m8 */
+  {"atmega88",   AVR_ISA_PWMx,    bfd_mach_avr4},
+  {"atmega8515", AVR_ISA_M8,      bfd_mach_avr4},
+  {"atmega8535", AVR_ISA_M8,      bfd_mach_avr4},
+  {"at90pwm2",   AVR_ISA_PWMx,    bfd_mach_avr4},
+  {"at90pwm3",   AVR_ISA_PWMx,    bfd_mach_avr4},
+  {"atmega16",   AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega161",  AVR_ISA_M161,    bfd_mach_avr5},
+  {"atmega162",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega163",  AVR_ISA_M161,    bfd_mach_avr5},
+  {"atmega164",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega165",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega168",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega169",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega32",   AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega323",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega324",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega325",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega329",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega3250", AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega3290", AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega406",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega64",   AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega640",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega644",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega128",  AVR_ISA_M128,    bfd_mach_avr5},
+  {"atmega1280", AVR_ISA_M128,    bfd_mach_avr5},
+  {"atmega1281", AVR_ISA_M128,    bfd_mach_avr5},
+  {"atmega645",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega649",  AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega6450", AVR_ISA_M323,    bfd_mach_avr5},
+  {"atmega6490", AVR_ISA_M323,    bfd_mach_avr5},
+  {"at90can32" , AVR_ISA_M323,    bfd_mach_avr5},
+  {"at90can64" , AVR_ISA_M323,    bfd_mach_avr5},
+  {"at90can128", AVR_ISA_M128,    bfd_mach_avr5},
   {"at90usb646", AVR_ISA_M323,    bfd_mach_avr5},
   {"at90usb647", AVR_ISA_M323,    bfd_mach_avr5},
   {"at90usb1286",AVR_ISA_M128,    bfd_mach_avr5},
   {"at90usb1287",AVR_ISA_M128,    bfd_mach_avr5},
-  {"at94k",     AVR_ISA_94K,      bfd_mach_avr5},
+  {"at94k",      AVR_ISA_94K,     bfd_mach_avr5},
+  {"atmega2560", AVR_ISA_ALL,     bfd_mach_avr6},
+  {"atmega2561", AVR_ISA_ALL,     bfd_mach_avr6},
   {NULL, 0, 0}
 };
 
@@ -512,7 +515,7 @@
   if (exp->X_op == O_constant)
     {
       int x = exp->X_add_number;
-      
+
       if (x < -255 || x > 255)
 	as_warn (_("constant out of 8-bit range: %d"), x);
     }
@@ -544,6 +547,8 @@
   char *tmp;
   char op[8];
   int mod;
+  int linker_stubs_should_be_generated = 0;
+
   tmp = str;
 
   str = extract_word (str, op, sizeof (op));
@@ -551,7 +556,7 @@
   if (op[0])
     {
       mod_index m;
-      
+
       m.ptr = hash_find (avr_mod_hash, op);
       mod = m.index;
 
@@ -564,11 +569,14 @@
 
 	  if (*str == '(')
 	    {
+	      bfd_reloc_code_real_type  reloc_to_return;
 	      int neg_p = 0;
 
 	      ++str;
 
 	      if (strncmp ("pm(", str, 3) == 0
+                  || strncmp ("gs(",str,3) == 0
+                  || strncmp ("-(gs(",str,5) == 0
 		  || strncmp ("-(pm(", str, 5) == 0)
 		{
 		  if (HAVE_PM_P (mod))
@@ -579,6 +587,9 @@
 		  else
 		    as_bad (_("illegal expression"));
 
+                  if (str[0] == 'g' || str[2] == 'g')
+                    linker_stubs_should_be_generated = 1;
+
 		  if (*str == '-')
 		    {
 		      neg_p = 1;
@@ -610,7 +621,24 @@
 		}
 	      while (closes--);
 
-	      return neg_p ? EXP_MOD_NEG_RELOC (mod) : EXP_MOD_RELOC (mod);
+	      reloc_to_return =
+		neg_p ? EXP_MOD_NEG_RELOC (mod) : EXP_MOD_RELOC (mod);
+	      if (linker_stubs_should_be_generated)
+		{
+		  switch (reloc_to_return)
+		    {
+		    case BFD_RELOC_AVR_LO8_LDI_PM:
+		      reloc_to_return = BFD_RELOC_AVR_LO8_LDI_GS;
+		      break;
+		    case BFD_RELOC_AVR_HI8_LDI_PM:
+		      reloc_to_return = BFD_RELOC_AVR_HI8_LDI_GS;
+		      break;
+
+		    default:
+		      break; /* as_warn (_("expression dangerous with linker stubs")); *//* Bjoern agreed. :) */
+		    }
+		}
+	      return reloc_to_return;
 	    }
 	}
     }
@@ -1227,7 +1255,7 @@
           return NULL;
         }
 
-      /* We are dealing with two symbols defined in the same section. 
+      /* We are dealing with two symbols defined in the same section.
          Let us fix-up them here.  */
       value += S_GET_VALUE (fixp->fx_addsy);
       value -= S_GET_VALUE (fixp->fx_subsy);
@@ -1310,7 +1338,8 @@
 static int exp_mod_pm = 0;
 
 /* Parse special CONS expression: pm (expression)
-   which is used for addressing to a program memory.
+   or alternatively: gs (expression).
+   These are used for addressing program memory.
    Relocation: BFD_RELOC_AVR_16_PM.  */
 
 void
@@ -1324,10 +1353,13 @@
 
   if (nbytes == 2)
     {
-      char *pm_name = "pm";
-      int len = strlen (pm_name);
+      char *pm_name1 = "pm";
+      char *pm_name2 = "gs";
+      int len = strlen (pm_name1);
+      /* len must be the same for both pm identifiers.  */
 
-      if (strncasecmp (input_line_pointer, pm_name, len) == 0)
+      if (strncasecmp (input_line_pointer, pm_name1, len) == 0
+          || strncasecmp (input_line_pointer, pm_name2, len) == 0)
 	{
 	  input_line_pointer = skip_space (input_line_pointer + len);
 
diff -Nur gas/config/tc-avr.h gas/config/tc-avr.h
--- gas/config/tc-avr.h	2006-05-17 18:04:30.000000000 +0200
+++ gas/config/tc-avr.h	2006-08-28 20:02:16.952294172 +0200
@@ -125,16 +125,21 @@
    We will need them in case that we want to do linker relaxation.
    We could in principle keep these fixups in gas when not relaxing.
    However, there is no serious performance penilty when making the linker
-   make the fixup work.  */
-#define TC_VALIDATE_FIX(FIXP,SEG,SKIP)                     \
- if (   (FIXP->fx_r_type == BFD_RELOC_AVR_7_PCREL          \
-      || FIXP->fx_r_type == BFD_RELOC_AVR_13_PCREL         \
-      || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_PM       \
-      || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_PM       \
-      || FIXP->fx_r_type == BFD_RELOC_AVR_HH8_LDI_PM       \
-      || FIXP->fx_r_type == BFD_RELOC_AVR_16_PM)           \
-     && (FIXP->fx_addsy))                                  \
-   {                                                       \
-     goto SKIP;                                            \
+   make the fixup work.  Check also that fx_addsy is not NULL, in order to make
+   sure that the fixup refers to some sort of lable.  */
+#define TC_VALIDATE_FIX(FIXP,SEG,SKIP)                       \
+  if (   (FIXP->fx_r_type == BFD_RELOC_AVR_7_PCREL           \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_13_PCREL          \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_PM        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_GS        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_PM        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_GS        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HH8_LDI_PM        \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_LO8_LDI_PM_NEG    \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HI8_LDI_PM_NEG    \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_HH8_LDI_PM_NEG    \
+       || FIXP->fx_r_type == BFD_RELOC_AVR_16_PM)            \
+      && (FIXP->fx_addsy))			             \
+    {                                                        \
+      goto SKIP;                                             \
    }
-
diff -Nur include/elf/avr.h include/elf/avr.h
--- include/elf/avr.h	2006-03-03 16:25:30.000000000 +0100
+++ include/elf/avr.h	2006-08-28 20:02:16.998290837 +0200
@@ -1,5 +1,5 @@
 /* AVR ELF support for BFD.
-   Copyright 1999, 2000, 2004 Free Software Foundation, Inc.
+   Copyright 1999, 2000, 2004, 2006 Free Software Foundation, Inc.
    Contributed by Denis Chertykov <denisc@overta.ru>
 
    This file is part of BFD, the Binary File Descriptor library.
@@ -35,6 +35,7 @@
 #define E_AVR_MACH_AVR3 3
 #define E_AVR_MACH_AVR4 4
 #define E_AVR_MACH_AVR5 5
+#define E_AVR_MACH_AVR6 6 
 
 /* Relocations.  */
 START_RELOC_NUMBERS (elf_avr_reloc_type)
@@ -62,6 +63,8 @@
      RELOC_NUMBER (R_AVR_6_ADIW,               21)
      RELOC_NUMBER (R_AVR_MS8_LDI,              22)
      RELOC_NUMBER (R_AVR_MS8_LDI_NEG,          23)
+     RELOC_NUMBER (R_AVR_LO8_LDI_GS,	       24)
+     RELOC_NUMBER (R_AVR_HI8_LDI_GS,	       25)
 END_RELOC_NUMBERS (R_AVR_max)
 
 #endif /* _ELF_AVR_H */
diff -Nur include/elf/ChangeLog include/elf/ChangeLog
--- include/elf/ChangeLog	2006-03-22 10:28:12.000000000 +0100
+++ include/elf/ChangeLog	2006-08-28 20:02:17.001290619 +0200
@@ -1,3 +1,7 @@
+2006-05-24  Bjoern Haase  <bjoern.m.haase@web.de> 
+	
+	* avr.h: Add E_AVR_MACH_AVR6, R_AVR_LO8_LDI_GS and R_AVR_HI8_LDI_GS.
+
 2006-03-22  Richard Sandiford  <richard@codesourcery.com>
 	    Daniel Jacobowitz  <dan@codesourcery.com>
 	    Phil Edwards  <phil@codesourcery.com>
diff -Nur ld/configure.tgt ld/configure.tgt
--- ld/configure.tgt	2006-04-05 14:41:57.000000000 +0200
+++ ld/configure.tgt	2006-08-28 20:02:17.029288589 +0200
@@ -81,7 +81,7 @@
 xscale-*-elf)		targ_emul=armelf
 			;;
 avr-*-*)		targ_emul=avr2
-			targ_extra_emuls="avr1 avr3 avr4 avr5"
+			targ_extra_emuls="avr1 avr3 avr4 avr5 avr6"
 			;;
 bfin-*-elf)		targ_emul=elf32bfin; targ_extra_emuls="elf32bfinfd" ;;
 bfin-*-uclinux*)	targ_emul=elf32bfin; targ_extra_emuls="elf32bfinfd" ;;
diff -Nur ld/emulparams/avr1.sh ld/emulparams/avr1.sh
--- ld/emulparams/avr1.sh	2002-05-16 21:51:08.000000000 +0200
+++ ld/emulparams/avr1.sh	2006-08-28 20:02:17.031288444 +0200
@@ -4,7 +4,8 @@
 OUTPUT_FORMAT="elf32-avr"
 MAXPAGESIZE=1
 EMBEDDED=yes
-TEMPLATE_NAME=generic
+TEMPLATE_NAME=elf32
 
 TEXT_LENGTH=8K
 DATA_LENGTH=0
+EXTRA_EM_FILE=avrelf
diff -Nur ld/emulparams/avr2.sh ld/emulparams/avr2.sh
--- ld/emulparams/avr2.sh	2002-05-16 21:51:08.000000000 +0200
+++ ld/emulparams/avr2.sh	2006-08-28 20:02:17.033288299 +0200
@@ -4,7 +4,8 @@
 OUTPUT_FORMAT="elf32-avr"
 MAXPAGESIZE=1
 EMBEDDED=yes
-TEMPLATE_NAME=generic
+TEMPLATE_NAME=elf32
 
 TEXT_LENGTH=8K
 DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -Nur ld/emulparams/avr3.sh ld/emulparams/avr3.sh
--- ld/emulparams/avr3.sh	2002-05-16 21:51:08.000000000 +0200
+++ ld/emulparams/avr3.sh	2006-08-28 20:02:17.036288081 +0200
@@ -4,7 +4,8 @@
 OUTPUT_FORMAT="elf32-avr"
 MAXPAGESIZE=1
 EMBEDDED=yes
-TEMPLATE_NAME=generic
+TEMPLATE_NAME=elf32
 
 TEXT_LENGTH=128K
 DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -Nur ld/emulparams/avr4.sh ld/emulparams/avr4.sh
--- ld/emulparams/avr4.sh	2002-05-16 21:51:08.000000000 +0200
+++ ld/emulparams/avr4.sh	2006-08-28 20:02:17.038287936 +0200
@@ -4,7 +4,8 @@
 OUTPUT_FORMAT="elf32-avr"
 MAXPAGESIZE=1
 EMBEDDED=yes
-TEMPLATE_NAME=generic
+TEMPLATE_NAME=elf32
 
 TEXT_LENGTH=8K
 DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -Nur ld/emulparams/avr5.sh ld/emulparams/avr5.sh
--- ld/emulparams/avr5.sh	2002-05-16 21:51:08.000000000 +0200
+++ ld/emulparams/avr5.sh	2006-08-28 20:02:17.040287791 +0200
@@ -4,7 +4,8 @@
 OUTPUT_FORMAT="elf32-avr"
 MAXPAGESIZE=1
 EMBEDDED=yes
-TEMPLATE_NAME=generic
+TEMPLATE_NAME=elf32
 
 TEXT_LENGTH=128K
 DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -Nur ld/emulparams/avr6.sh ld/emulparams/avr6.sh
--- ld/emulparams/avr6.sh	1970-01-01 01:00:00.000000000 +0100
+++ ld/emulparams/avr6.sh	2006-08-28 20:02:17.043287574 +0200
@@ -0,0 +1,11 @@
+ARCH=avr:6
+MACHINE=
+SCRIPT_NAME=avr
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_LENGTH=1024K
+DATA_LENGTH=0xffa0
+EXTRA_EM_FILE=avrelf
diff -Nur ld/emultempl/avrelf.em ld/emultempl/avrelf.em
--- ld/emultempl/avrelf.em	1970-01-01 01:00:00.000000000 +0100
+++ ld/emultempl/avrelf.em	2006-08-28 20:02:17.047287284 +0200
@@ -0,0 +1,267 @@
+# This shell script emits a C file. -*- C -*-
+#   Copyright 2006
+#   Free Software Foundation, Inc.
+#
+# This file is part of GLD, the Gnu Linker.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, 
+# MA 02110-1301 USA.
+
+# This file is sourced from elf32.em, and defines extra avr-elf
+# specific routines.  It is used to generate the trampolines for the avr6
+# family devices where one needs to address the issue that it is not possible
+# to reach the whole program memory by using 16 bit pointers.
+
+cat >>e${EMULATION_NAME}.c <<EOF
+
+#include "elf32-avr.h"
+#include "ldctor.h"
+
+/* The fake file and it's corresponding section meant to hold 
+   the linker stubs if needed.  */
+
+static lang_input_statement_type *stub_file;
+static asection *avr_stub_section;
+
+/* Variables set by the command-line parameters and transfered
+   to the bfd without use of global shared variables.  */
+
+static bfd_boolean avr_no_stubs = FALSE;
+static bfd_boolean avr_debug_relax = FALSE;
+static bfd_boolean avr_debug_stubs = FALSE;
+static bfd_boolean avr_replace_call_ret_sequences = TRUE;
+static bfd_vma avr_pc_wrap_around = 0x10000000;
+
+/* Transfers information to the bfd frontend.  */
+
+static void
+avr_elf_set_global_bfd_parameters (void)
+{
+  elf32_avr_setup_params (& link_info,
+                          stub_file->the_bfd,
+                          avr_stub_section,
+                          avr_no_stubs,
+                          avr_debug_stubs,
+                          avr_debug_relax,
+                          avr_pc_wrap_around,
+                          avr_replace_call_ret_sequences);
+}
+
+
+/* Makes a conservative estimate of the trampoline section size that could
+   be corrected later on.  */
+
+static void
+avr_elf_${EMULATION_NAME}_before_allocation (void)
+{
+  int ret;
+
+  gld${EMULATION_NAME}_before_allocation ();
+
+  /* We only need stubs for the avr6 family.  */
+  if (strcmp ("${EMULATION_NAME}","avr6"))
+    avr_no_stubs = TRUE;
+
+  avr_elf_set_global_bfd_parameters ();
+
+  /* If generating a relocatable output file, then
+     we don't  have to generate the trampolines.  */
+  if (link_info.relocatable)
+    avr_no_stubs = TRUE;
+
+  if (avr_no_stubs)
+    return;
+
+  ret = elf32_avr_setup_section_lists (output_bfd, &link_info);
+
+  if (ret < 0)
+    einfo ("%X%P: can not setup the input section list: %E\n");
+
+  if (ret <= 0)
+    return;
+
+  /* Call into the BFD backend to do the real "stub"-work.  */
+  if (! elf32_avr_size_stubs (output_bfd, &link_info, TRUE))
+    einfo ("%X%P: can not size stub section: %E\n");
+}
+
+/* This is called before the input files are opened.  We create a new
+   fake input file to hold the stub section and generate the section itself.  */
+
+static void
+avr_elf_create_output_section_statements (void)
+{
+  flagword flags;
+
+  stub_file = lang_add_input_file ("linker stubs",
+                                   lang_input_file_is_fake_enum,
+                                   NULL);
+
+  stub_file->the_bfd = bfd_create ("linker stubs", output_bfd);
+  if (stub_file->the_bfd == NULL
+      || !bfd_set_arch_mach (stub_file->the_bfd,
+                             bfd_get_arch (output_bfd),
+                             bfd_get_mach (output_bfd)))
+    {
+      einfo ("%X%P: can not create stub BFD %E\n");
+      return;
+    }
+
+  /* Now we add the stub section.  */
+
+  avr_stub_section = bfd_make_section_anyway (stub_file->the_bfd,
+                                              ".trampolines");
+  if (avr_stub_section == NULL)
+    goto err_ret;
+  
+  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
+           | SEC_HAS_CONTENTS | SEC_RELOC | SEC_IN_MEMORY | SEC_KEEP);
+  if (!bfd_set_section_flags (stub_file->the_bfd, avr_stub_section, flags))
+    goto err_ret;
+
+  avr_stub_section->alignment_power = 1;
+  
+  ldlang_add_file (stub_file);
+
+  return;
+
+  err_ret:
+   einfo ("%X%P: can not make stub section: %E\n");
+   return;
+}
+
+/* Re-calculates the size of the stubs so that we won't waste space.  */
+
+static void
+avr_elf_finish (void)
+{ 
+  if (!avr_no_stubs)
+    {
+      /* Now build the linker stubs.  */
+      if (stub_file->the_bfd->sections != NULL)
+       {
+         /* Call again the trampoline analyzer to initialize the trampoline
+            stubs with the correct symbol addresses.  Since there could have
+            been relaxation, the symbol addresses that were found during
+            first call may no longer be correct.  */
+         if (!elf32_avr_size_stubs (output_bfd, &link_info, FALSE))
+           {
+             einfo ("%X%P: can not size stub section: %E\n");
+             return;
+           }
+
+         if (!elf32_avr_build_stubs (&link_info))
+           einfo ("%X%P: can not build stubs: %E\n");
+       }
+    }
+
+  gld${EMULATION_NAME}_finish ();
+}
+
+
+EOF
+
+
+PARSE_AND_LIST_PROLOGUE='
+
+#define OPTION_NO_CALL_RET_REPLACEMENT 301
+#define OPTION_PMEM_WRAP_AROUND        302
+#define OPTION_NO_STUBS                303
+#define OPTION_DEBUG_STUBS             304
+#define OPTION_DEBUG_RELAX             305
+'
+
+PARSE_AND_LIST_LONGOPTS='
+  { "no-call-ret-replacement", no_argument, 
+     NULL, OPTION_NO_CALL_RET_REPLACEMENT},
+  { "pmem-wrap-around", required_argument, 
+    NULL, OPTION_PMEM_WRAP_AROUND},
+  { "no-stubs", no_argument, 
+    NULL, OPTION_NO_STUBS},
+  { "debug-stubs", no_argument, 
+    NULL, OPTION_DEBUG_STUBS},
+  { "debug-relax", no_argument, 
+    NULL, OPTION_DEBUG_RELAX},
+'
+
+PARSE_AND_LIST_OPTIONS='
+  fprintf (file, _("     --pmem-wrap-around=<val> "
+                           "Make the linker relaxation machine assume that a\n"
+                   "                              "
+                           "program counter wrap-around occures at address\n"
+                   "                              "
+                           "<val>. Supported values are 16k, 32k and 64k.\n"));
+  fprintf (file, _("     --no-call-ret-replacement "
+                           "The relaxation machine normally will\n"
+                   "                               "
+                           "substitute two immediately following call/ret\n"
+                   "                               "
+                           "instructions by a single jump instruction.\n"
+                   "                               "
+                           "This option disables this optimization.\n"));
+  fprintf (file, _("     --no-stubs "
+                           "If the linker detects to attempt to access\n"
+                   "                               "
+                           "an instruction beyond 128k by a reloc that\n"
+                   "                               "
+                           "is limited to 128k max, it inserts a jump\n"
+                   "                               "
+                           "stub. You can de-active this with this switch.\n"));
+  fprintf (file, _("     --debug-stubs Used for debugging avr-ld.\n"));
+  fprintf (file, _("     --debug-relax Used for debugging avr-ld.\n"));
+'
+
+PARSE_AND_LIST_ARGS_CASES='
+
+    case OPTION_PMEM_WRAP_AROUND:
+      { 
+        /* This variable is defined in the bfd library.  */
+        if ((!strcmp (optarg,"32k"))      || (!strcmp (optarg,"32K")))
+          avr_pc_wrap_around = 32768;
+        else if ((!strcmp (optarg,"16k")) || (!strcmp (optarg,"16K")))
+          avr_pc_wrap_around = 16384;
+        else if ((!strcmp (optarg,"64k")) || (!strcmp (optarg,"64K")))
+          avr_pc_wrap_around = 0x10000;
+        else
+          return FALSE;
+      }
+      break;
+
+    case OPTION_DEBUG_STUBS:
+      avr_debug_stubs = TRUE;
+      break;
+
+    case OPTION_DEBUG_RELAX:
+      avr_debug_relax = TRUE;
+      break;
+
+    case OPTION_NO_STUBS:
+      avr_no_stubs = TRUE;
+      break;
+
+    case OPTION_NO_CALL_RET_REPLACEMENT:
+      {
+        /* This variable is defined in the bfd library.  */
+        avr_replace_call_ret_sequences = FALSE;
+      }
+      break;
+'
+
+#
+# Put these extra avr-elf routines in ld_${EMULATION_NAME}_emulation
+#
+LDEMUL_BEFORE_ALLOCATION=avr_elf_${EMULATION_NAME}_before_allocation
+LDEMUL_FINISH=avr_elf_finish
+LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=avr_elf_create_output_section_statements
diff -Nur ld/Makefile.am ld/Makefile.am
--- ld/Makefile.am	2006-06-03 06:45:50.000000000 +0200
+++ ld/Makefile.am	2006-08-28 20:02:17.055286703 +0200
@@ -133,6 +133,7 @@
 	eavr3.o \
 	eavr4.o \
 	eavr5.o \
+	eavr6.o \
 	ecoff_i860.o \
 	ecoff_sparc.o \
 	ecrisaout.o \
@@ -595,6 +596,10 @@
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avr5 "$(tdir_avr2)"
+eavr6.c: $(srcdir)/emulparams/avr6.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr6 "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -Nur ld/Makefile.in ld/Makefile.in
--- ld/Makefile.in	2006-06-03 06:45:50.000000000 +0200
+++ ld/Makefile.in	2006-08-28 20:02:17.072285471 +0200
@@ -357,6 +357,7 @@
 	eavr3.o \
 	eavr4.o \
 	eavr5.o \
+	eavr6.o \
 	ecoff_i860.o \
 	ecoff_sparc.o \
 	ecrisaout.o \
@@ -1406,6 +1407,10 @@
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avr5 "$(tdir_avr2)"
+eavr6.c: $(srcdir)/emulparams/avr6.sh \
+  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/avr.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avr6 "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -Nur ld/scripttempl/avr.sc ld/scripttempl/avr.sc
--- ld/scripttempl/avr.sc	2006-03-03 16:25:31.000000000 +0100
+++ ld/scripttempl/avr.sc	2006-08-28 20:02:17.078285036 +0200
@@ -71,12 +71,32 @@
   .rel.plt     ${RELOCATING-0} : { *(.rel.plt)		}
   .rela.plt    ${RELOCATING-0} : { *(.rela.plt)		}
 
-  /* Internal text space or external memory */
+  /* Internal text space or external memory.  */
   .text :
   {
     *(.vectors)
     KEEP(*(.vectors))
 
+    /* For data that needs to reside in the lower 64k of progmem.  */
+    *(.progmem.gcc*)
+    *(.progmem*)
+    ${RELOCATING+. = ALIGN(2);}
+
+    ${CONSTRUCTING+ __trampolines_start = . ; }
+    /* The jump trampolines for the 16-bit limited relocs will reside here.  */
+    *(.trampolines)
+    *(.trampolines*)
+    ${CONSTRUCTING+ __trampolines_end = . ; }
+
+    /* For future tablejump instruction arrays for 3 byte pc devices.
+       We don't relax jump/call instructions within these sections.  */
+    *(.jumptables) 
+    *(.jumptables*) 
+
+    /* For code that needs to reside in the lower 128k progmem.  */
+    *(.lowtext)
+    *(.lowtext*)
+
     ${CONSTRUCTING+ __ctors_start = . ; }
     ${CONSTRUCTING+ *(.ctors) }
     ${CONSTRUCTING+ __ctors_end = . ; }
@@ -86,18 +106,8 @@
     KEEP(SORT(*)(.ctors))
     KEEP(SORT(*)(.dtors))
 
-    /* For data that needs to reside in the lower 64k of progmem */
-    *(.progmem.gcc*)
-    *(.progmem*)
-    ${RELOCATING+. = ALIGN(2);}
-    
-    /* for future tablejump instruction arrays for 3 byte pc devices */
-    *(.jumptables) 
-    *(.jumptables*) 
-    /* for code that needs to reside in the lower 128k progmem */
-    *(.lowtext)
-    *(.lowtext*)  
-
+    /* From this point on, we don't bother about wether the insns are
+       below or above the 16 bits boundary.  */
     *(.init0)  /* Start here after reset.  */
     KEEP (*(.init0))
     *(.init1)
